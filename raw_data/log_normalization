 
******************************
Original:
if (data[c] &gt;= 128)
    sum += data[c];
******************************
Normalized:
******************************
Original:
if (data[c] &gt;= 128)
    sum += data[c];
******************************
Normalized:
if (data[c] &gt;= 128)
    sum += data[c];
******************************
Original:
class RetrieveFeedTask extends AsyncTask&lt;String, Void, RSSFeed&gt; {

    private Exception exception;

    protected RSSFeed doInBackground(String... urls) {
        try {
            URL url = new URL(urls[0]);
            SAXParserFactory factory = SAXParserFactory.newInstance();
            SAXParser parser = factory.newSAXParser();
            XMLReader xmlreader = parser.getXMLReader();
            RssHandler theRSSHandler = new RssHandler();
            xmlreader.setContentHandler(theRSSHandler);
            InputSource is = new InputSource(url.openStream());
            xmlreader.parse(is);

            return theRSSHandler.getFeed();
        } catch (Exception e) {
            this.exception = e;

            return null;
        } finally {
            is.close();
        }
    }

    protected void onPostExecute(RSSFeed feed) {
        // TODO: check this.exception
        // TODO: do something with the feed
    }
}
******************************
Normalized:
******************************
Original:
class RetrieveFeedTask extends AsyncTask&lt;String, Void, RSSFeed&gt; {

    private Exception exception;

    protected RSSFeed doInBackground(String... urls) {
        try {
            URL url = new URL(urls[0]);
            SAXParserFactory factory = SAXParserFactory.newInstance();
            SAXParser parser = factory.newSAXParser();
            XMLReader xmlreader = parser.getXMLReader();
            RssHandler theRSSHandler = new RssHandler();
            xmlreader.setContentHandler(theRSSHandler);
            InputSource is = new InputSource(url.openStream());
            xmlreader.parse(is);

            return theRSSHandler.getFeed();
        } catch (Exception e) {
            this.exception = e;

            return null;
        } finally {
            is.close();
        }
    }

    protected void onPostExecute(RSSFeed feed) {
        // TODO: check this.exception
        // TODO: do something with the feed
    }
}
******************************
Normalized:
class RetrieveFeedTask extends AsyncTask&lt;String, Void, RSSFeed&gt; {

    private Exception exception;

    protected RSSFeed doInBackground(String... urls) {
        try {
            URL url = new URL(urls[0]);
            SAXParserFactory factory = SAXParserFactory.newInstance();
            SAXParser parser = factory.newSAXParser();
            XMLReader xmlreader = parser.getXMLReader();
            RssHandler theRSSHandler = new RssHandler();
            xmlreader.setContentHandler(theRSSHandler);
            InputSource is = new InputSource(url.openStream());
            xmlreader.parse(is);

            return theRSSHandler.getFeed();
        } catch (Exception e) {
            this.exception = e;

            return null;
        } finally {
            is.close();
        }
    }

    protected void onPostExecute(RSSFeed feed) {
        // TODO: check this.exception
        // TODO: do something with the feed
    }
}
******************************
Original:
Java SE 14 = 58,
Java SE 13 = 57,
Java SE 12 = 56,
Java SE 11 = 55,
Java SE 10 = 54,
Java SE 9 = 53,
Java SE 8 = 52,
Java SE 7 = 51,
Java SE 6.0 = 50,
Java SE 5.0 = 49,
JDK 1.4 = 48,
JDK 1.3 = 47,
JDK 1.2 = 46,
JDK 1.1 = 45
******************************
Normalized:
******************************
Original:
Java SE 14 = 58,
Java SE 13 = 57,
Java SE 12 = 56,
Java SE 11 = 55,
Java SE 10 = 54,
Java SE 9 = 53,
Java SE 8 = 52,
Java SE 7 = 51,
Java SE 6.0 = 50,
Java SE 5.0 = 49,
JDK 1.4 = 48,
JDK 1.3 = 47,
JDK 1.2 = 46,
JDK 1.1 = 45
******************************
Normalized:
Java SE 14 = 58,
Java SE 13 = 57,
Java SE 12 = 56,
Java SE 11 = 55,
Java SE 10 = 54,
Java SE 9 = 53,
Java SE 8 = 52,
Java SE 7 = 51,
Java SE 6.0 = 50,
Java SE 5.0 = 49,
JDK 1.4 = 48,
JDK 1.3 = 47,
JDK 1.2 = 46,
JDK 1.1 = 45
******************************
Original:
java [ &lt;options&gt; ] &lt;class-name&gt; [&lt;arg&gt; ...]
******************************
Normalized:
******************************
Original:
java [ &lt;options&gt; ] &lt;class-name&gt; [&lt;arg&gt; ...]
******************************
Normalized:
java [ &lt;options&gt; ] &lt;class-name&gt; [&lt;arg&gt; ...]
******************************
Original:
mvn install:install-file \
   -Dfile=&lt;path-to-file&gt; \
   -DgroupId=&lt;group-id&gt; \
   -DartifactId=&lt;artifact-id&gt; \
   -Dversion=&lt;version&gt; \
   -Dpackaging=&lt;packaging&gt; \
   -DgeneratePom=true
******************************
Normalized:
******************************
Original:
mvn install:install-file \
   -Dfile=&lt;path-to-file&gt; \
   -DgroupId=&lt;group-id&gt; \
   -DartifactId=&lt;artifact-id&gt; \
   -Dversion=&lt;version&gt; \
   -Dpackaging=&lt;packaging&gt; \
   -DgeneratePom=true
******************************
Normalized:
mvn install:install-file \
   -Dfile=&lt;path-to-file&gt; \
   -DgroupId=&lt;group-id&gt; \
   -DartifactId=&lt;artifact-id&gt; \
   -Dversion=&lt;version&gt; \
   -Dpackaging=&lt;packaging&gt; \
   -DgeneratePom=true
******************************
Original:
// this works for up to 10 elements:
Map&lt;String, String&gt; test1 = Map.of(
    "a", "b",
    "c", "d"
);

// this works for any number of elements:
import static java.util.Map.entry;    
Map&lt;String, String&gt; test2 = Map.ofEntries(
    entry("a", "b"),
    entry("c", "d")
);
******************************
Normalized:
******************************
Original:
// this works for up to 10 elements:
Map&lt;String, String&gt; test1 = Map.of(
    "a", "b",
    "c", "d"
);

// this works for any number of elements:
import static java.util.Map.entry;    
Map&lt;String, String&gt; test2 = Map.ofEntries(
    entry("a", "b"),
    entry("c", "d")
);
******************************
Normalized:
// this works for up to 10 elements:
Map&lt;String, String&gt; test1 = Map.of(
    "a", "b",
    "c", "d"
);

// this works for any number of elements:
import static java.util.Map.entry;    
Map&lt;String, String&gt; test2 = Map.ofEntries(
    entry("a", "b"),
    entry("c", "d")
);
******************************
Original:
java -Xms256m -Xmx2048m
******************************
Normalized:
******************************
Original:
java -Xms256m -Xmx2048m
******************************
Normalized:
java -Xms256m -Xmx2048m
******************************
Original:
class ClassNameTest {
    public static void main(final String... arguments) {
        printNamesForClass(
            int.class,
            "int.class (primitive)");
        printNamesForClass(
            String.class,
            "String.class (ordinary class)");
        printNamesForClass(
            java.util.HashMap.SimpleEntry.class,
            "java.util.HashMap.SimpleEntry.class (nested class)");
        printNamesForClass(
            new java.io.Serializable(){}.getClass(),
            "new java.io.Serializable(){}.getClass() (anonymous inner class)");
    }

    private static void printNamesForClass(final Class&lt;?&gt; clazz, final String label) {
        System.out.println(label + ":");
        System.out.println("    getName():          " + clazz.getName());
        System.out.println("    getCanonicalName(): " + clazz.getCanonicalName());
        System.out.println("    getSimpleName():    " + clazz.getSimpleName());
        System.out.println("    getTypeName():      " + clazz.getTypeName()); // added in Java 8
        System.out.println();
    }
}
******************************
Normalized:
******************************
Original:
class ClassNameTest {
    public static void main(final String... arguments) {
        printNamesForClass(
            int.class,
            "int.class (primitive)");
        printNamesForClass(
            String.class,
            "String.class (ordinary class)");
        printNamesForClass(
            java.util.HashMap.SimpleEntry.class,
            "java.util.HashMap.SimpleEntry.class (nested class)");
        printNamesForClass(
            new java.io.Serializable(){}.getClass(),
            "new java.io.Serializable(){}.getClass() (anonymous inner class)");
    }

    private static void printNamesForClass(final Class&lt;?&gt; clazz, final String label) {
        System.out.println(label + ":");
        System.out.println("    getName():          " + clazz.getName());
        System.out.println("    getCanonicalName(): " + clazz.getCanonicalName());
        System.out.println("    getSimpleName():    " + clazz.getSimpleName());
        System.out.println("    getTypeName():      " + clazz.getTypeName()); // added in Java 8
        System.out.println();
    }
}
******************************
Normalized:
class ClassNameTest {
    public static void main(final String... arguments) {
        printNamesForClass(
            int.class,
            "int.class (primitive)");
        printNamesForClass(
            String.class,
            "String.class (ordinary class)");
        printNamesForClass(
            java.util.HashMap.SimpleEntry.class,
            "java.util.HashMap.SimpleEntry.class (nested class)");
        printNamesForClass(
            new java.io.Serializable(){}.getClass(),
            "new java.io.Serializable(){}.getClass() (anonymous inner class)");
    }

    private static void printNamesForClass(final Class&lt;?&gt; clazz, final String label) {
        System.out.println(label + ":");
        System.out.println("    getName():          " + clazz.getName());
        System.out.println("    getCanonicalName(): " + clazz.getCanonicalName());
        System.out.println("    getSimpleName():    " + clazz.getSimpleName());
        System.out.println("    getTypeName():      " + clazz.getTypeName()); // added in Java 8
        System.out.println();
    }
}
******************************
Original:
public class ReactiveAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; {
    String[] mDataset = { "Data", "In", "Adapter" };

    private final PublishSubject&lt;String&gt; onClickSubject = PublishSubject.create();

    @Override 
    public void onBindViewHolder(final ViewHolder holder, int position) {
        final String element = mDataset[position];

        holder.itemView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
               onClickSubject.onNext(element);
            }
        });
    }

    public Observable&lt;String&gt; getPositionClicks(){
        return onClickSubject.asObservable();
    }
}
******************************
Normalized:
******************************
Original:
public class ReactiveAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; {
    String[] mDataset = { "Data", "In", "Adapter" };

    private final PublishSubject&lt;String&gt; onClickSubject = PublishSubject.create();

    @Override 
    public void onBindViewHolder(final ViewHolder holder, int position) {
        final String element = mDataset[position];

        holder.itemView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
               onClickSubject.onNext(element);
            }
        });
    }

    public Observable&lt;String&gt; getPositionClicks(){
        return onClickSubject.asObservable();
    }
}
******************************
Normalized:
public class ReactiveAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; {
    String[] mDataset = { "Data", "In", "Adapter" };

    private final PublishSubject&lt;String&gt; onClickSubject = PublishSubject.create();

    @Override 
    public void onBindViewHolder(final ViewHolder holder, int position) {
        final String element = mDataset[position];

        holder.itemView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
               onClickSubject.onNext(element);
            }
        });
    }

    public Observable&lt;String&gt; getPositionClicks(){
        return onClickSubject.asObservable();
    }
}
******************************
Original:
public class MyAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; {
    class ViewHolder0 extends RecyclerView.ViewHolder {
        ...
        public ViewHolder0(View itemView){
        ...
        }
    }

    class ViewHolder2 extends RecyclerView.ViewHolder {
        ...
        public ViewHolder2(View itemView){
        ...
    }

    @Override
    public int getItemViewType(int position) {
        // Just as an example, return 0 or 2 depending on position
        // Note that unlike in ListView adapters, types don't have to be contiguous
        return position % 2 * 2;
    }

    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
         switch (viewType) {
             case 0: return new ViewHolder0(...);
             case 2: return new ViewHolder2(...);
             ...
         }
    }

    @Override
    public void onBindViewHolder(final RecyclerView.ViewHolder holder, final int position) {
        switch (holder.getItemViewType()) {
            case 0:
                ViewHolder0 viewHolder0 = (ViewHolder0)holder;
                ...
                break;

            case 2:
                ViewHolder2 viewHolder2 = (ViewHolder2)holder;
                ...
                break;
        }
    }
}
******************************
Normalized:
******************************
Original:
public class MyAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; {
    class ViewHolder0 extends RecyclerView.ViewHolder {
        ...
        public ViewHolder0(View itemView){
        ...
        }
    }

    class ViewHolder2 extends RecyclerView.ViewHolder {
        ...
        public ViewHolder2(View itemView){
        ...
    }

    @Override
    public int getItemViewType(int position) {
        // Just as an example, return 0 or 2 depending on position
        // Note that unlike in ListView adapters, types don't have to be contiguous
        return position % 2 * 2;
    }

    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
         switch (viewType) {
             case 0: return new ViewHolder0(...);
             case 2: return new ViewHolder2(...);
             ...
         }
    }

    @Override
    public void onBindViewHolder(final RecyclerView.ViewHolder holder, final int position) {
        switch (holder.getItemViewType()) {
            case 0:
                ViewHolder0 viewHolder0 = (ViewHolder0)holder;
                ...
                break;

            case 2:
                ViewHolder2 viewHolder2 = (ViewHolder2)holder;
                ...
                break;
        }
    }
}
******************************
Normalized:
public class MyAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; {
    class ViewHolder0 extends RecyclerView.ViewHolder {
        ...
        public ViewHolder0(View itemView){
        ...
        }
    }

    class ViewHolder2 extends RecyclerView.ViewHolder {
        ...
        public ViewHolder2(View itemView){
        ...
    }

    @Override
    public int getItemViewType(int position) {
        // Just as an example, return 0 or 2 depending on position
        // Note that unlike in ListView adapters, types don't have to be contiguous
        return position % 2 * 2;
    }

    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
         switch (viewType) {
             case 0: return new ViewHolder0(...);
             case 2: return new ViewHolder2(...);
             ...
         }
    }

    @Override
    public void onBindViewHolder(final RecyclerView.ViewHolder holder, final int position) {
        switch (holder.getItemViewType()) {
            case 0:
                ViewHolder0 viewHolder0 = (ViewHolder0)holder;
                ...
                break;

            case 2:
                ViewHolder2 viewHolder2 = (ViewHolder2)holder;
                ...
                break;
        }
    }
}
******************************
Original:
iconst_2
     iload0
     iload0
     imul
     imul
     iadd
******************************
Normalized:
******************************
Original:
iconst_2
     iload0
     iload0
     imul
     imul
     iadd
******************************
Normalized:
iconst_2
     iload0
     iload0
     imul
     imul
     iadd
******************************
Original:
java.activation
java.corba
java.transaction
java.xml.bind  &lt;&lt; This one contains the JAXB APIs
java.xml.ws
java.xml.ws.annotation
******************************
Normalized:
******************************
Original:
java.activation
java.corba
java.transaction
java.xml.bind  &lt;&lt; This one contains the JAXB APIs
java.xml.ws
java.xml.ws.annotation
******************************
Normalized:
java.activation
java.corba
java.transaction
java.xml.bind  &lt;&lt; This one contains the JAXB APIs
java.xml.ws
java.xml.ws.annotation
******************************
Original:
import com.fasterxml.jackson.databind.ObjectMapper;// in play 2.3
ObjectMapper mapper = new ObjectMapper();
******************************
Normalized:
******************************
Original:
import com.fasterxml.jackson.databind.ObjectMapper;// in play 2.3
ObjectMapper mapper = new ObjectMapper();
******************************
Normalized:
import com.fasterxml.jackson.databind.ObjectMapper;// in play 2.3
ObjectMapper mapper = new ObjectMapper();
******************************
Original:
private static final char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();
public static String bytesToHex(byte[] bytes) {
    char[] hexChars = new char[bytes.length * 2];
    for (int j = 0; j &lt; bytes.length; j++) {
        int v = bytes[j] &amp; 0xFF;
        hexChars[j * 2] = HEX_ARRAY[v &gt;&gt;&gt; 4];
        hexChars[j * 2 + 1] = HEX_ARRAY[v &amp; 0x0F];
    }
    return new String(hexChars);
}
******************************
Normalized:
******************************
Original:
private static final char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();
public static String bytesToHex(byte[] bytes) {
    char[] hexChars = new char[bytes.length * 2];
    for (int j = 0; j &lt; bytes.length; j++) {
        int v = bytes[j] &amp; 0xFF;
        hexChars[j * 2] = HEX_ARRAY[v &gt;&gt;&gt; 4];
        hexChars[j * 2 + 1] = HEX_ARRAY[v &amp; 0x0F];
    }
    return new String(hexChars);
}
******************************
Normalized:
private static final char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();
public static String bytesToHex(byte[] bytes) {
    char[] hexChars = new char[bytes.length * 2];
    for (int j = 0; j &lt; bytes.length; j++) {
        int v = bytes[j] &amp; 0xFF;
        hexChars[j * 2] = HEX_ARRAY[v &gt;&gt;&gt; 4];
        hexChars[j * 2 + 1] = HEX_ARRAY[v &amp; 0x0F];
    }
    return new String(hexChars);
}
******************************
Original:
Exception in thread "main" java.lang.NullPointerException
        at com.example.myproject.Book.getTitle(Book.java:16)
        at com.example.myproject.Author.getBookTitles(Author.java:25)
        at com.example.myproject.Bootstrap.main(Bootstrap.java:14)
******************************
Normalized:
******************************
Original:
Exception in thread "main" java.lang.NullPointerException
        at com.example.myproject.Book.getTitle(Book.java:16)
        at com.example.myproject.Author.getBookTitles(Author.java:25)
        at com.example.myproject.Bootstrap.main(Bootstrap.java:14)
******************************
Normalized:
Exception in thread "main" java.lang.NullPointerException
        at com.example.myproject.Book.getTitle(Book.java:16)
        at com.example.myproject.Author.getBookTitles(Author.java:25)
        at com.example.myproject.Bootstrap.main(Bootstrap.java:14)
******************************
Original:
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;

// ...

verify(dependency, never()).someMethod();
******************************
Normalized:
******************************
Original:
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;

// ...

verify(dependency, never()).someMethod();
******************************
Normalized:
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;

// ...

verify(dependency, never()).someMethod();
******************************
Original:
repositories {
   flatDir {
       dirs 'libs'
   }
}


dependencies {
   implementation name: 'gson-2.2.4'
}
******************************
Normalized:
******************************
Original:
repositories {
   flatDir {
       dirs 'libs'
   }
}


dependencies {
   implementation name: 'gson-2.2.4'
}
******************************
Normalized:
repositories {
   flatDir {
       dirs 'libs'
   }
}


dependencies {
   implementation name: 'gson-2.2.4'
}
******************************
Original:
export JAVA_HOME="$(/usr/libexec/java_home -v 1.6)"
or
export JAVA_HOME="$(/usr/libexec/java_home -v 1.7)"
or
export JAVA_HOME="$(/usr/libexec/java_home -v 1.8)"
******************************
Normalized:
******************************
Original:
export JAVA_HOME="$(/usr/libexec/java_home -v 1.6)"
or
export JAVA_HOME="$(/usr/libexec/java_home -v 1.7)"
or
export JAVA_HOME="$(/usr/libexec/java_home -v 1.8)"
******************************
Normalized:
export JAVA_HOME="$(/usr/libexec/java_home -v 1.6)"
or
export JAVA_HOME="$(/usr/libexec/java_home -v 1.7)"
or
export JAVA_HOME="$(/usr/libexec/java_home -v 1.8)"
******************************
Original:
sudo add-apt-repository ppa:openjdk-r/ppa  # only Ubuntu 17.4 and earlier
sudo apt update
******************************
Normalized:
******************************
Original:
sudo add-apt-repository ppa:openjdk-r/ppa  # only Ubuntu 17.4 and earlier
sudo apt update
******************************
Normalized:
sudo add-apt-repository ppa:openjdk-r/ppa  # only Ubuntu 17.4 and earlier
sudo apt update
******************************
Original:
List&lt;String&gt; items = Arrays.asList(str.split("\\s*,\\s*"));
******************************
Normalized:
******************************
Original:
List&lt;String&gt; items = Arrays.asList(str.split("\\s*,\\s*"));
******************************
Normalized:
List&lt;String&gt; items = Arrays.asList(str.split("\\s*,\\s*"));
******************************
Original:
List&lt;List&lt;Object&gt;&gt; list = ...
List&lt;Object&gt; flat = 
    list.stream()
        .flatMap(List::stream)
        .collect(Collectors.toList());
******************************
Normalized:
******************************
Original:
List&lt;List&lt;Object&gt;&gt; list = ...
List&lt;Object&gt; flat = 
    list.stream()
        .flatMap(List::stream)
        .collect(Collectors.toList());
******************************
Normalized:
List&lt;List&lt;Object&gt;&gt; list = ...
List&lt;Object&gt; flat = 
    list.stream()
        .flatMap(List::stream)
        .collect(Collectors.toList());
******************************
Original:
TreeSet&lt;String&gt; set = new TreeSet&lt;String&gt;();
set.add("lol");
set.add("cat");
// automatically sorts natural order when adding

for (String s : set) {
    System.out.println(s);
}
// Prints out "cat" and "lol"
******************************
Normalized:
******************************
Original:
TreeSet&lt;String&gt; set = new TreeSet&lt;String&gt;();
set.add("lol");
set.add("cat");
// automatically sorts natural order when adding

for (String s : set) {
    System.out.println(s);
}
// Prints out "cat" and "lol"
******************************
Normalized:
TreeSet&lt;String&gt; set = new TreeSet&lt;String&gt;();
set.add("lol");
set.add("cat");
// automatically sorts natural order when adding

for (String s : set) {
    System.out.println(s);
}
// Prints out "cat" and "lol"
******************************
Original:
import android.os.Vibrator;
...
Vibrator v = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
// Vibrate for 500 milliseconds
if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {
    v.vibrate(VibrationEffect.createOneShot(500, VibrationEffect.DEFAULT_AMPLITUDE));
} else {
    //deprecated in API 26 
    v.vibrate(500);
}
******************************
Normalized:
******************************
Original:
import android.os.Vibrator;
...
Vibrator v = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
// Vibrate for 500 milliseconds
if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {
    v.vibrate(VibrationEffect.createOneShot(500, VibrationEffect.DEFAULT_AMPLITUDE));
} else {
    //deprecated in API 26 
    v.vibrate(500);
}
******************************
Normalized:
import android.os.Vibrator;
...
Vibrator v = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
// Vibrate for 500 milliseconds
if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {
    v.vibrate(VibrationEffect.createOneShot(500, VibrationEffect.DEFAULT_AMPLITUDE));
} else {
    //deprecated in API 26 
    v.vibrate(500);
}
******************************
Original:
HashMap&lt;String, HashMap&gt; selects = new HashMap&lt;String, HashMap&gt;();

for(Map.Entry&lt;String, HashMap&gt; entry : selects.entrySet()) {
    String key = entry.getKey();
    HashMap value = entry.getValue();

    // do what you have to do here
    // In your case, another loop.
}
******************************
Normalized:
******************************
Original:
HashMap&lt;String, HashMap&gt; selects = new HashMap&lt;String, HashMap&gt;();

for(Map.Entry&lt;String, HashMap&gt; entry : selects.entrySet()) {
    String key = entry.getKey();
    HashMap value = entry.getValue();

    // do what you have to do here
    // In your case, another loop.
}
******************************
Normalized:
HashMap&lt;String, HashMap&gt; selects = new HashMap&lt;String, HashMap&gt;();

for(Map.Entry&lt;String, HashMap&gt; entry : selects.entrySet()) {
    String key = entry.getKey();
    HashMap value = entry.getValue();

    // do what you have to do here
    // In your case, another loop.
}
******************************
Original:
import java.nio.charset.StandardCharsets;

...

StandardCharsets.UTF_8.name();
******************************
Normalized:
******************************
Original:
import java.nio.charset.StandardCharsets;

...

StandardCharsets.UTF_8.name();
******************************
Normalized:
import java.nio.charset.StandardCharsets;

...

StandardCharsets.UTF_8.name();
******************************
Original:
/** Counts number of foobangs.
 * @param type Type of foobangs to count. Can be 1=green foobangs,
 * 2=wrinkled foobangs, 3=sweet foobangs, 0=all types.
 * @return number of foobangs of type
 */
public int countFoobangs(int type)
******************************
Normalized:
******************************
Original:
/** Counts number of foobangs.
 * @param type Type of foobangs to count. Can be 1=green foobangs,
 * 2=wrinkled foobangs, 3=sweet foobangs, 0=all types.
 * @return number of foobangs of type
 */
public int countFoobangs(int type)
******************************
Normalized:
/** Counts number of foobangs.
 * @param type Type of foobangs to count. Can be 1=green foobangs,
 * 2=wrinkled foobangs, 3=sweet foobangs, 0=all types.
 * @return number of foobangs of type
 */
public int countFoobangs(int type)
******************************
Original:
public String method(String str) {
    if (str != null &amp;&amp; str.length() &gt; 0 &amp;&amp; str.charAt(str.length() - 1) == 'x') {
        str = str.substring(0, str.length() - 1);
    }
    return str;
}
******************************
Normalized:
******************************
Original:
public String method(String str) {
    if (str != null &amp;&amp; str.length() &gt; 0 &amp;&amp; str.charAt(str.length() - 1) == 'x') {
        str = str.substring(0, str.length() - 1);
    }
    return str;
}
******************************
Normalized:
public String method(String str) {
    if (str != null &amp;&amp; str.length() &gt; 0 &amp;&amp; str.charAt(str.length() - 1) == 'x') {
        str = str.substring(0, str.length() - 1);
    }
    return str;
}
******************************
Original:
Iterator&lt;String&gt; sourceIterator = Arrays.asList("A", "B", "C").iterator();
Stream&lt;String&gt; targetStream = StreamSupport.stream(
          Spliterators.spliteratorUnknownSize(sourceIterator, Spliterator.ORDERED),
          false);
******************************
Normalized:
******************************
Original:
Iterator&lt;String&gt; sourceIterator = Arrays.asList("A", "B", "C").iterator();
Stream&lt;String&gt; targetStream = StreamSupport.stream(
          Spliterators.spliteratorUnknownSize(sourceIterator, Spliterator.ORDERED),
          false);
******************************
Normalized:
Iterator&lt;String&gt; sourceIterator = Arrays.asList("A", "B", "C").iterator();
Stream&lt;String&gt; targetStream = StreamSupport.stream(
          Spliterators.spliteratorUnknownSize(sourceIterator, Spliterator.ORDERED),
          false);
******************************
Original:
@FunctionalInterface
public interface CheckedFunction&lt;T, R&gt; {
   R apply(T t) throws IOException;
}
******************************
Normalized:
******************************
Original:
@FunctionalInterface
public interface CheckedFunction&lt;T, R&gt; {
   R apply(T t) throws IOException;
}
******************************
Normalized:
@FunctionalInterface
public interface CheckedFunction&lt;T, R&gt; {
   R apply(T t) throws IOException;
}
******************************
Original:
List&lt;String&gt; list = new LinkedList();
******************************
Normalized:
******************************
Original:
List&lt;String&gt; list = new LinkedList();
******************************
Normalized:
List&lt;String&gt; list = new LinkedList();
******************************
Original:
verify(mockBar, times(2)).doSomething(...)
******************************
Normalized:
******************************
Original:
verify(mockBar, times(2)).doSomething(...)
******************************
Normalized:
verify(mockBar, times(2)).doSomething(...)
******************************
Original:
android {
    buildTypes {
        debug {
            buildConfigField "int", "FOO", "42"
            buildConfigField "String", "FOO_STRING", "\"foo\""
            buildConfigField "boolean", "LOG", "true"
        }

        release {
            buildConfigField "int", "FOO", "52"
            buildConfigField "String", "FOO_STRING", "\"bar\""
            buildConfigField "boolean", "LOG", "false"
        }
    }
}
******************************
Normalized:
******************************
Original:
android {
    buildTypes {
        debug {
            buildConfigField "int", "FOO", "42"
            buildConfigField "String", "FOO_STRING", "\"foo\""
            buildConfigField "boolean", "LOG", "true"
        }

        release {
            buildConfigField "int", "FOO", "52"
            buildConfigField "String", "FOO_STRING", "\"bar\""
            buildConfigField "boolean", "LOG", "false"
        }
    }
}
******************************
Normalized:
android {
    buildTypes {
        debug {
            buildConfigField "int", "FOO", "42"
            buildConfigField "String", "FOO_STRING", "\"foo\""
            buildConfigField "boolean", "LOG", "true"
        }

        release {
            buildConfigField "int", "FOO", "52"
            buildConfigField "String", "FOO_STRING", "\"bar\""
            buildConfigField "boolean", "LOG", "false"
        }
    }
}
******************************
Original:
if (a != 0 &amp;&amp; b != 0)
******************************
Normalized:
******************************
Original:
if (a != 0 &amp;&amp; b != 0)
******************************
Normalized:
if (a != 0 &amp;&amp; b != 0)
******************************
Original:
keytool -v -list -keystore .keystore
******************************
Normalized:
******************************
Original:
keytool -v -list -keystore .keystore
******************************
Normalized:
keytool -v -list -keystore .keystore
******************************
Original:
Interface List&lt;E&gt;
******************************
Normalized:
******************************
Original:
Interface List&lt;E&gt;
******************************
Normalized:
Interface List&lt;E&gt;
******************************
Original:
Long.parseLong("0", 10)        // returns 0L
 Long.parseLong("473", 10)      // returns 473L
 Long.parseLong("-0", 10)       // returns 0L
 Long.parseLong("-FF", 16)      // returns -255L
 Long.parseLong("1100110", 2)   // returns 102L
 Long.parseLong("99", 8)        // throws a NumberFormatException
 Long.parseLong("Hazelnut", 10) // throws a NumberFormatException
 Long.parseLong("Hazelnut", 36) // returns 1356099454469L
 Long.parseLong("999")          // returns 999L
******************************
Normalized:
******************************
Original:
Long.parseLong("0", 10)        // returns 0L
 Long.parseLong("473", 10)      // returns 473L
 Long.parseLong("-0", 10)       // returns 0L
 Long.parseLong("-FF", 16)      // returns -255L
 Long.parseLong("1100110", 2)   // returns 102L
 Long.parseLong("99", 8)        // throws a NumberFormatException
 Long.parseLong("Hazelnut", 10) // throws a NumberFormatException
 Long.parseLong("Hazelnut", 36) // returns 1356099454469L
 Long.parseLong("999")          // returns 999L
******************************
Normalized:
Long.parseLong("0", 10)        // returns 0L
 Long.parseLong("473", 10)      // returns 473L
 Long.parseLong("-0", 10)       // returns 0L
 Long.parseLong("-FF", 16)      // returns -255L
 Long.parseLong("1100110", 2)   // returns 102L
 Long.parseLong("99", 8)        // throws a NumberFormatException
 Long.parseLong("Hazelnut", 10) // throws a NumberFormatException
 Long.parseLong("Hazelnut", 36) // returns 1356099454469L
 Long.parseLong("999")          // returns 999L
******************************
Original:
String strings[] = ...
if (strings.charAt(3)) { ... }
// maybe that should be 'strings[0].charAt(3)'
******************************
Normalized:
******************************
Original:
String strings[] = ...
if (strings.charAt(3)) { ... }
// maybe that should be 'strings[0].charAt(3)'
******************************
Normalized:
String strings[] = ...
if (strings.charAt(3)) { ... }
// maybe that should be 'strings[0].charAt(3)'
******************************
Original:
Looper.myLooper() == Looper.getMainLooper()
******************************
Normalized:
******************************
Original:
Looper.myLooper() == Looper.getMainLooper()
******************************
Normalized:
Looper.myLooper() == Looper.getMainLooper()
******************************
Original:
return new ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST);
******************************
Normalized:
******************************
Original:
return new ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST);
******************************
Normalized:
return new ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST);
******************************
Original:
"'(.*?)'"
******************************
Normalized:
******************************
Original:
"'(.*?)'"
******************************
Normalized:
"'(.*?)'"
******************************
Original:
String[] names = {"Sam", "Pamela", "Dave", "Pascal", "Erik"};
IntStream.range(0, names.length)
         .filter(i -&gt; names[i].length() &lt;= i)
         .mapToObj(i -&gt; names[i])
         .collect(Collectors.toList());
******************************
Normalized:
******************************
Original:
String[] names = {"Sam", "Pamela", "Dave", "Pascal", "Erik"};
IntStream.range(0, names.length)
         .filter(i -&gt; names[i].length() &lt;= i)
         .mapToObj(i -&gt; names[i])
         .collect(Collectors.toList());
******************************
Normalized:
String[] names = {"Sam", "Pamela", "Dave", "Pascal", "Erik"};
IntStream.range(0, names.length)
         .filter(i -&gt; names[i].length() &lt;= i)
         .mapToObj(i -&gt; names[i])
         .collect(Collectors.toList());
******************************
Original:
integers.values().stream().mapToInt(i -&gt; i.intValue()).sum();
integers.values().stream().mapToInt(Integer::intValue).sum();
******************************
Normalized:
******************************
Original:
integers.values().stream().mapToInt(i -&gt; i.intValue()).sum();
integers.values().stream().mapToInt(Integer::intValue).sum();
******************************
Normalized:
integers.values().stream().mapToInt(i -&gt; i.intValue()).sum();
integers.values().stream().mapToInt(Integer::intValue).sum();
******************************
Original:
@OneToMany(fetch = FetchType.EAGER, mappedBy = "topic", cascade = CascadeType.ALL)
private Collection&lt;Comment&gt; comments = new LinkedHashSet&lt;Comment&gt;();
******************************
Normalized:
******************************
Original:
@OneToMany(fetch = FetchType.EAGER, mappedBy = "topic", cascade = CascadeType.ALL)
private Collection&lt;Comment&gt; comments = new LinkedHashSet&lt;Comment&gt;();
******************************
Normalized:
@OneToMany(fetch = FetchType.EAGER, mappedBy = "topic", cascade = CascadeType.ALL)
private Collection&lt;Comment&gt; comments = new LinkedHashSet&lt;Comment&gt;();
******************************
Original:
Iterator&lt;String&gt; iter = myArrayList.iterator();

while (iter.hasNext()) {
    String str = iter.next();

    if (someCondition)
        iter.remove();
}
******************************
Normalized:
******************************
Original:
Iterator&lt;String&gt; iter = myArrayList.iterator();

while (iter.hasNext()) {
    String str = iter.next();

    if (someCondition)
        iter.remove();
}
******************************
Normalized:
Iterator&lt;String&gt; iter = myArrayList.iterator();

while (iter.hasNext()) {
    String str = iter.next();

    if (someCondition)
        iter.remove();
}
******************************
Original:
interface A { 
    default void foo() { ... }
}

interface B { 
}

class C implements A, B { 
}
******************************
Normalized:
******************************
Original:
interface A { 
    default void foo() { ... }
}

interface B { 
}

class C implements A, B { 
}
******************************
Normalized:
interface A { 
    default void foo() { ... }
}

interface B { 
}

class C implements A, B { 
}
******************************
Original:
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
******************************
Normalized:
******************************
Original:
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
******************************
Normalized:
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
******************************
Original:
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;title&gt;SO question 4112686&lt;/title&gt;
        &lt;script src="http://code.jquery.com/jquery-latest.min.js"&gt;&lt;/script&gt;
        &lt;script&gt;
            $(document).on("click", "#somebutton", function() { // When HTML DOM "click" event is invoked on element with ID "somebutton", execute the following function...
                $.get("someservlet", function(responseText) {   // Execute Ajax GET request on URL of "someservlet" and execute the following function with Ajax response text...
                    $("#somediv").text(responseText);           // Locate HTML DOM element with ID "somediv" and set its text content with the response text.
                });
            });
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;button id="somebutton"&gt;press here&lt;/button&gt;
        &lt;div id="somediv"&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
******************************
Normalized:
******************************
Original:
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;title&gt;SO question 4112686&lt;/title&gt;
        &lt;script src="http://code.jquery.com/jquery-latest.min.js"&gt;&lt;/script&gt;
        &lt;script&gt;
            $(document).on("click", "#somebutton", function() { // When HTML DOM "click" event is invoked on element with ID "somebutton", execute the following function...
                $.get("someservlet", function(responseText) {   // Execute Ajax GET request on URL of "someservlet" and execute the following function with Ajax response text...
                    $("#somediv").text(responseText);           // Locate HTML DOM element with ID "somediv" and set its text content with the response text.
                });
            });
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;button id="somebutton"&gt;press here&lt;/button&gt;
        &lt;div id="somediv"&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
******************************
Normalized:
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;title&gt;SO question 4112686&lt;/title&gt;
        &lt;script src="http://code.jquery.com/jquery-latest.min.js"&gt;&lt;/script&gt;
        &lt;script&gt;
            $(document).on("click", "#somebutton", function() { // When HTML DOM "click" event is invoked on element with ID "somebutton", execute the following function...
                $.get("someservlet", function(responseText) {   // Execute Ajax GET request on URL of "someservlet" and execute the following function with Ajax response text...
                    $("#somediv").text(responseText);           // Locate HTML DOM element with ID "somediv" and set its text content with the response text.
                });
            });
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;button id="somebutton"&gt;press here&lt;/button&gt;
        &lt;div id="somediv"&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
******************************
Original:
&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
    version="3.0"&gt;
    &lt;display-name&gt;Servlet 3.0 Web Application&lt;/display-name&gt;
&lt;/web-app&gt;
******************************
Normalized:
******************************
Original:
&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
    version="3.0"&gt;
    &lt;display-name&gt;Servlet 3.0 Web Application&lt;/display-name&gt;
&lt;/web-app&gt;
******************************
Normalized:
&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
    version="3.0"&gt;
    &lt;display-name&gt;Servlet 3.0 Web Application&lt;/display-name&gt;
&lt;/web-app&gt;
******************************
Original:
Stream&lt;String&gt; s = ...;
long nonEmptyStrings = s.filter(Predicate.not(String::isEmpty)).count();
******************************
Normalized:
******************************
Original:
Stream&lt;String&gt; s = ...;
long nonEmptyStrings = s.filter(Predicate.not(String::isEmpty)).count();
******************************
Normalized:
Stream&lt;String&gt; s = ...;
long nonEmptyStrings = s.filter(Predicate.not(String::isEmpty)).count();
******************************
Original:
import java.util.Scanner; 
Scanner scan = new Scanner(System.in);
String s = scan.next();
int i = scan.nextInt();
******************************
Normalized:
******************************
Original:
import java.util.Scanner; 
Scanner scan = new Scanner(System.in);
String s = scan.next();
int i = scan.nextInt();
******************************
Normalized:
import java.util.Scanner; 
Scanner scan = new Scanner(System.in);
String s = scan.next();
int i = scan.nextInt();
******************************
Original:
-Xms128m
-Xmx2048m
-XX:MaxPermSize=350m
-XX:ReservedCodeCacheSize=64m
-XX:+UseCodeCacheFlushing
-XX:+UseCompressedOops
******************************
Normalized:
******************************
Original:
-Xms128m
-Xmx2048m
-XX:MaxPermSize=350m
-XX:ReservedCodeCacheSize=64m
-XX:+UseCodeCacheFlushing
-XX:+UseCompressedOops
******************************
Normalized:
-Xms128m
-Xmx2048m
-XX:MaxPermSize=350m
-XX:ReservedCodeCacheSize=64m
-XX:+UseCodeCacheFlushing
-XX:+UseCompressedOops
******************************
Original:
private ReentrantLock lock;

public void foo() {
  ...
  lock.lock();
  ...
}

public void bar() {
  ...
  lock.unlock();
  ...
}
******************************
Normalized:
******************************
Original:
private ReentrantLock lock;

public void foo() {
  ...
  lock.lock();
  ...
}

public void bar() {
  ...
  lock.unlock();
  ...
}
******************************
Normalized:
private ReentrantLock lock;

public void foo() {
  ...
  lock.lock();
  ...
}

public void bar() {
  ...
  lock.unlock();
  ...
}
******************************
Original:
AtomicReference&lt;Object&gt; cache = new AtomicReference&lt;Object&gt;();

Object cachedValue = new Object();
cache.set(cachedValue);

//... time passes ...
Object cachedValueToUpdate = cache.get();
//... do some work to transform cachedValueToUpdate into a new version
Object newValue = someFunctionOfOld(cachedValueToUpdate);
boolean success = cache.compareAndSet(cachedValue,cachedValueToUpdate);
******************************
Normalized:
******************************
Original:
AtomicReference&lt;Object&gt; cache = new AtomicReference&lt;Object&gt;();

Object cachedValue = new Object();
cache.set(cachedValue);

//... time passes ...
Object cachedValueToUpdate = cache.get();
//... do some work to transform cachedValueToUpdate into a new version
Object newValue = someFunctionOfOld(cachedValueToUpdate);
boolean success = cache.compareAndSet(cachedValue,cachedValueToUpdate);
******************************
Normalized:
AtomicReference&lt;Object&gt; cache = new AtomicReference&lt;Object&gt;();

Object cachedValue = new Object();
cache.set(cachedValue);

//... time passes ...
Object cachedValueToUpdate = cache.get();
//... do some work to transform cachedValueToUpdate into a new version
Object newValue = someFunctionOfOld(cachedValueToUpdate);
boolean success = cache.compareAndSet(cachedValue,cachedValueToUpdate);
******************************
Original:
for(int i = 0; i &lt; sparseArray.size(); i++) {
   int key = sparseArray.keyAt(i);
   // get the object by the key.
   Object obj = sparseArray.get(key);
}
******************************
Normalized:
******************************
Original:
for(int i = 0; i &lt; sparseArray.size(); i++) {
   int key = sparseArray.keyAt(i);
   // get the object by the key.
   Object obj = sparseArray.get(key);
}
******************************
Normalized:
for(int i = 0; i &lt; sparseArray.size(); i++) {
   int key = sparseArray.keyAt(i);
   // get the object by the key.
   Object obj = sparseArray.get(key);
}
******************************
Original:
Optional&lt;SomeObject&gt; result =
    someObjects.stream().filter(obj -&gt; some_condition_met).findFirst();
******************************
Normalized:
******************************
Original:
Optional&lt;SomeObject&gt; result =
    someObjects.stream().filter(obj -&gt; some_condition_met).findFirst();
******************************
Normalized:
Optional&lt;SomeObject&gt; result =
    someObjects.stream().filter(obj -&gt; some_condition_met).findFirst();
******************************
Original:
brew update
******************************
Normalized:
******************************
Original:
brew update
******************************
Normalized:
brew update
******************************
Original:
$ which java
******************************
Normalized:
******************************
Original:
$ which java
******************************
Normalized:
$ which java
******************************
Original:
public class Test{

    @Mock
    private Service service;

    @Captor
    private ArgumentCaptor&lt;ArrayList&lt;SomeType&gt;&gt; captor;

    @Before
    public void init(){
        MockitoAnnotations.initMocks(this);
    }

    @Test 
    public void shouldDoStuffWithListValues() {
        //...
        verify(service).doStuff(captor.capture()));
    }
}
******************************
Normalized:
******************************
Original:
public class Test{

    @Mock
    private Service service;

    @Captor
    private ArgumentCaptor&lt;ArrayList&lt;SomeType&gt;&gt; captor;

    @Before
    public void init(){
        MockitoAnnotations.initMocks(this);
    }

    @Test 
    public void shouldDoStuffWithListValues() {
        //...
        verify(service).doStuff(captor.capture()));
    }
}
******************************
Normalized:
public class Test{

    @Mock
    private Service service;

    @Captor
    private ArgumentCaptor&lt;ArrayList&lt;SomeType&gt;&gt; captor;

    @Before
    public void init(){
        MockitoAnnotations.initMocks(this);
    }

    @Test 
    public void shouldDoStuffWithListValues() {
        //...
        verify(service).doStuff(captor.capture()));
    }
}
******************************
Original:
1/3 + 2/3 + 2/3 = (0.3333 + 0.6667) + 0.6667
                = 1.000 + 0.6667 (no rounding needed!)
                = 1.667 (where 1.6667 is rounded to 1.667)

2/3 + 2/3 + 1/3 = (0.6667 + 0.6667) + 0.3333
                = 1.333 + 0.3333 (where 1.3334 is rounded to 1.333)
                = 1.666 (where 1.6663 is rounded to 1.666)
******************************
Normalized:
******************************
Original:
1/3 + 2/3 + 2/3 = (0.3333 + 0.6667) + 0.6667
                = 1.000 + 0.6667 (no rounding needed!)
                = 1.667 (where 1.6667 is rounded to 1.667)

2/3 + 2/3 + 1/3 = (0.6667 + 0.6667) + 0.3333
                = 1.333 + 0.3333 (where 1.3334 is rounded to 1.333)
                = 1.666 (where 1.6663 is rounded to 1.666)
******************************
Normalized:
1/3 + 2/3 + 2/3 = (0.3333 + 0.6667) + 0.6667
                = 1.000 + 0.6667 (no rounding needed!)
                = 1.667 (where 1.6667 is rounded to 1.667)

2/3 + 2/3 + 1/3 = (0.6667 + 0.6667) + 0.3333
                = 1.333 + 0.3333 (where 1.3334 is rounded to 1.333)
                = 1.666 (where 1.6663 is rounded to 1.666)
******************************
Original:
public void clear() {
    modCount++;

    // Let gc do its work
    for (int i = 0; i &lt; size; i++)
        elementData[i] = null;

    size = 0;
}
******************************
Normalized:
******************************
Original:
public void clear() {
    modCount++;

    // Let gc do its work
    for (int i = 0; i &lt; size; i++)
        elementData[i] = null;

    size = 0;
}
******************************
Normalized:
public void clear() {
    modCount++;

    // Let gc do its work
    for (int i = 0; i &lt; size; i++)
        elementData[i] = null;

    size = 0;
}
******************************
Original:
final int sdk = android.os.Build.VERSION.SDK_INT;
if(sdk &lt; android.os.Build.VERSION_CODES.JELLY_BEAN) {
    layout.setBackgroundDrawable(ContextCompat.getDrawable(context, R.drawable.ready) );
} else {
    layout.setBackground(ContextCompat.getDrawable(context, R.drawable.ready));
}
******************************
Normalized:
******************************
Original:
final int sdk = android.os.Build.VERSION.SDK_INT;
if(sdk &lt; android.os.Build.VERSION_CODES.JELLY_BEAN) {
    layout.setBackgroundDrawable(ContextCompat.getDrawable(context, R.drawable.ready) );
} else {
    layout.setBackground(ContextCompat.getDrawable(context, R.drawable.ready));
}
******************************
Normalized:
final int sdk = android.os.Build.VERSION.SDK_INT;
if(sdk &lt; android.os.Build.VERSION_CODES.JELLY_BEAN) {
    layout.setBackgroundDrawable(ContextCompat.getDrawable(context, R.drawable.ready) );
} else {
    layout.setBackground(ContextCompat.getDrawable(context, R.drawable.ready));
}
******************************
Original:
compileJava.options.fork = true
compileJava.options.forkOptions.executable = /path_to_javac
******************************
Normalized:
******************************
Original:
compileJava.options.fork = true
compileJava.options.forkOptions.executable = /path_to_javac
******************************
Normalized:
compileJava.options.fork = true
compileJava.options.forkOptions.executable = /path_to_javac
******************************
Original:
[Verified Entry Point]
  # {method} 'multiplyByPowerOfTen' '(DI)D' in 'javaapplication4/Test1'
  # parm0:    xmm0:xmm0   = double
  # parm1:    rdx       = int
  #           [sp+0x20]  (sp of caller)
  0x00000000024f0160: mov    DWORD PTR [rsp-0x6000],eax
                                                ;   {no_reloc}
  0x00000000024f0167: push   rbp
  0x00000000024f0168: sub    rsp,0x10           ;*synchronization entry
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@-1 (line 56)
  0x00000000024f016c: cmp    edx,0x3
  0x00000000024f016f: je     0x00000000024f01c3
  0x00000000024f0171: cmp    edx,0x3
  0x00000000024f0174: jg     0x00000000024f01a5
  0x00000000024f0176: cmp    edx,0x1
  0x00000000024f0179: je     0x00000000024f019b
  0x00000000024f017b: cmp    edx,0x1
  0x00000000024f017e: jg     0x00000000024f0191
  0x00000000024f0180: test   edx,edx
  0x00000000024f0182: je     0x00000000024f01cb
  0x00000000024f0184: mov    ebp,edx
  0x00000000024f0186: mov    edx,0x17
  0x00000000024f018b: call   0x00000000024c90a0  ; OopMap{off=48}
                                                ;*new  ; - javaapplication4.Test1::multiplyByPowerOfTen@72 (line 83)
                                                ;   {runtime_call}
  0x00000000024f0190: int3                      ;*new  ; - javaapplication4.Test1::multiplyByPowerOfTen@72 (line 83)
  0x00000000024f0191: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffffa7]        # 0x00000000024f0140
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@52 (line 62)
                                                ;   {section_word}
  0x00000000024f0199: jmp    0x00000000024f01cb
  0x00000000024f019b: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffff8d]        # 0x00000000024f0130
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@46 (line 60)
                                                ;   {section_word}
  0x00000000024f01a3: jmp    0x00000000024f01cb
  0x00000000024f01a5: cmp    edx,0x5
  0x00000000024f01a8: je     0x00000000024f01b9
  0x00000000024f01aa: cmp    edx,0x5
  0x00000000024f01ad: jg     0x00000000024f0184  ;*tableswitch
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56)
  0x00000000024f01af: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffff81]        # 0x00000000024f0138
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@64 (line 66)
                                                ;   {section_word}
  0x00000000024f01b7: jmp    0x00000000024f01cb
  0x00000000024f01b9: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffff67]        # 0x00000000024f0128
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@70 (line 68)
                                                ;   {section_word}
  0x00000000024f01c1: jmp    0x00000000024f01cb
  0x00000000024f01c3: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffff55]        # 0x00000000024f0120
                                                ;*tableswitch
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56)
                                                ;   {section_word}
  0x00000000024f01cb: add    rsp,0x10
  0x00000000024f01cf: pop    rbp
  0x00000000024f01d0: test   DWORD PTR [rip+0xfffffffffdf3fe2a],eax        # 0x0000000000430000
                                                ;   {poll_return}
  0x00000000024f01d6: ret
******************************
Normalized:
******************************
Original:
[Verified Entry Point]
  # {method} 'multiplyByPowerOfTen' '(DI)D' in 'javaapplication4/Test1'
  # parm0:    xmm0:xmm0   = double
  # parm1:    rdx       = int
  #           [sp+0x20]  (sp of caller)
  0x00000000024f0160: mov    DWORD PTR [rsp-0x6000],eax
                                                ;   {no_reloc}
  0x00000000024f0167: push   rbp
  0x00000000024f0168: sub    rsp,0x10           ;*synchronization entry
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@-1 (line 56)
  0x00000000024f016c: cmp    edx,0x3
  0x00000000024f016f: je     0x00000000024f01c3
  0x00000000024f0171: cmp    edx,0x3
  0x00000000024f0174: jg     0x00000000024f01a5
  0x00000000024f0176: cmp    edx,0x1
  0x00000000024f0179: je     0x00000000024f019b
  0x00000000024f017b: cmp    edx,0x1
  0x00000000024f017e: jg     0x00000000024f0191
  0x00000000024f0180: test   edx,edx
  0x00000000024f0182: je     0x00000000024f01cb
  0x00000000024f0184: mov    ebp,edx
  0x00000000024f0186: mov    edx,0x17
  0x00000000024f018b: call   0x00000000024c90a0  ; OopMap{off=48}
                                                ;*new  ; - javaapplication4.Test1::multiplyByPowerOfTen@72 (line 83)
                                                ;   {runtime_call}
  0x00000000024f0190: int3                      ;*new  ; - javaapplication4.Test1::multiplyByPowerOfTen@72 (line 83)
  0x00000000024f0191: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffffa7]        # 0x00000000024f0140
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@52 (line 62)
                                                ;   {section_word}
  0x00000000024f0199: jmp    0x00000000024f01cb
  0x00000000024f019b: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffff8d]        # 0x00000000024f0130
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@46 (line 60)
                                                ;   {section_word}
  0x00000000024f01a3: jmp    0x00000000024f01cb
  0x00000000024f01a5: cmp    edx,0x5
  0x00000000024f01a8: je     0x00000000024f01b9
  0x00000000024f01aa: cmp    edx,0x5
  0x00000000024f01ad: jg     0x00000000024f0184  ;*tableswitch
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56)
  0x00000000024f01af: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffff81]        # 0x00000000024f0138
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@64 (line 66)
                                                ;   {section_word}
  0x00000000024f01b7: jmp    0x00000000024f01cb
  0x00000000024f01b9: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffff67]        # 0x00000000024f0128
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@70 (line 68)
                                                ;   {section_word}
  0x00000000024f01c1: jmp    0x00000000024f01cb
  0x00000000024f01c3: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffff55]        # 0x00000000024f0120
                                                ;*tableswitch
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56)
                                                ;   {section_word}
  0x00000000024f01cb: add    rsp,0x10
  0x00000000024f01cf: pop    rbp
  0x00000000024f01d0: test   DWORD PTR [rip+0xfffffffffdf3fe2a],eax        # 0x0000000000430000
                                                ;   {poll_return}
  0x00000000024f01d6: ret
******************************
Normalized:
[Verified Entry Point]
  # {method} 'multiplyByPowerOfTen' '(DI)D' in 'javaapplication4/Test1'
  # parm0:    xmm0:xmm0   = double
  # parm1:    rdx       = int
  #           [sp+0x20]  (sp of caller)
  0x00000000024f0160: mov    DWORD PTR [rsp-0x6000],eax
                                                ;   {no_reloc}
  0x00000000024f0167: push   rbp
  0x00000000024f0168: sub    rsp,0x10           ;*synchronization entry
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@-1 (line 56)
  0x00000000024f016c: cmp    edx,0x3
  0x00000000024f016f: je     0x00000000024f01c3
  0x00000000024f0171: cmp    edx,0x3
  0x00000000024f0174: jg     0x00000000024f01a5
  0x00000000024f0176: cmp    edx,0x1
  0x00000000024f0179: je     0x00000000024f019b
  0x00000000024f017b: cmp    edx,0x1
  0x00000000024f017e: jg     0x00000000024f0191
  0x00000000024f0180: test   edx,edx
  0x00000000024f0182: je     0x00000000024f01cb
  0x00000000024f0184: mov    ebp,edx
  0x00000000024f0186: mov    edx,0x17
  0x00000000024f018b: call   0x00000000024c90a0  ; OopMap{off=48}
                                                ;*new  ; - javaapplication4.Test1::multiplyByPowerOfTen@72 (line 83)
                                                ;   {runtime_call}
  0x00000000024f0190: int3                      ;*new  ; - javaapplication4.Test1::multiplyByPowerOfTen@72 (line 83)
  0x00000000024f0191: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffffa7]        # 0x00000000024f0140
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@52 (line 62)
                                                ;   {section_word}
  0x00000000024f0199: jmp    0x00000000024f01cb
  0x00000000024f019b: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffff8d]        # 0x00000000024f0130
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@46 (line 60)
                                                ;   {section_word}
  0x00000000024f01a3: jmp    0x00000000024f01cb
  0x00000000024f01a5: cmp    edx,0x5
  0x00000000024f01a8: je     0x00000000024f01b9
  0x00000000024f01aa: cmp    edx,0x5
  0x00000000024f01ad: jg     0x00000000024f0184  ;*tableswitch
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56)
  0x00000000024f01af: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffff81]        # 0x00000000024f0138
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@64 (line 66)
                                                ;   {section_word}
  0x00000000024f01b7: jmp    0x00000000024f01cb
  0x00000000024f01b9: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffff67]        # 0x00000000024f0128
                                                ;*dmul
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@70 (line 68)
                                                ;   {section_word}
  0x00000000024f01c1: jmp    0x00000000024f01cb
  0x00000000024f01c3: mulsd  xmm0,QWORD PTR [rip+0xffffffffffffff55]        # 0x00000000024f0120
                                                ;*tableswitch
                                                ; - javaapplication4.Test1::multiplyByPowerOfTen@1 (line 56)
                                                ;   {section_word}
  0x00000000024f01cb: add    rsp,0x10
  0x00000000024f01cf: pop    rbp
  0x00000000024f01d0: test   DWORD PTR [rip+0xfffffffffdf3fe2a],eax        # 0x0000000000430000
                                                ;   {poll_return}
  0x00000000024f01d6: ret
******************************
Original:
f.then((s -&gt; aStringFunction(s)).thenAsync(s -&gt; ...);
******************************
Normalized:
******************************
Original:
f.then((s -&gt; aStringFunction(s)).thenAsync(s -&gt; ...);
******************************
Normalized:
f.then((s -&gt; aStringFunction(s)).thenAsync(s -&gt; ...);
******************************
Original:
Class&lt;?&gt; enclosingClass = getClass().getEnclosingClass();
if (enclosingClass != null) {
  System.out.println(enclosingClass.getName());
} else {
  System.out.println(getClass().getName());
}
******************************
Normalized:
******************************
Original:
Class&lt;?&gt; enclosingClass = getClass().getEnclosingClass();
if (enclosingClass != null) {
  System.out.println(enclosingClass.getName());
} else {
  System.out.println(getClass().getName());
}
******************************
Normalized:
Class&lt;?&gt; enclosingClass = getClass().getEnclosingClass();
if (enclosingClass != null) {
  System.out.println(enclosingClass.getName());
} else {
  System.out.println(getClass().getName());
}
******************************
Original:
&lt;plugins&gt;
    &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
******************************
Normalized:
******************************
Original:
&lt;plugins&gt;
    &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
******************************
Normalized:
&lt;plugins&gt;
    &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
******************************
Original:
interface I {
  void do();
}

class A implements I { void do() { doA() } ... }
class B implements I { void do() { doB() } ... }
class C implements I { void do() { doC() } ... }
******************************
Normalized:
******************************
Original:
interface I {
  void do();
}

class A implements I { void do() { doA() } ... }
class B implements I { void do() { doB() } ... }
class C implements I { void do() { doC() } ... }
******************************
Normalized:
interface I {
  void do();
}

class A implements I { void do() { doA() } ... }
class B implements I { void do() { doB() } ... }
class C implements I { void do() { doC() } ... }
******************************
Original:
public class OptionalConsumer&lt;T&gt; {
    private Optional&lt;T&gt; optional;

    private OptionalConsumer(Optional&lt;T&gt; optional) {
        this.optional = optional;
    }

    public static &lt;T&gt; OptionalConsumer&lt;T&gt; of(Optional&lt;T&gt; optional) {
        return new OptionalConsumer&lt;&gt;(optional);
    }

    public OptionalConsumer&lt;T&gt; ifPresent(Consumer&lt;T&gt; c) {
        optional.ifPresent(c);
        return this;
    }

    public OptionalConsumer&lt;T&gt; ifNotPresent(Runnable r) {
        if (!optional.isPresent()) {
            r.run();
        }
        return this;
    }
}
******************************
Normalized:
******************************
Original:
public class OptionalConsumer&lt;T&gt; {
    private Optional&lt;T&gt; optional;

    private OptionalConsumer(Optional&lt;T&gt; optional) {
        this.optional = optional;
    }

    public static &lt;T&gt; OptionalConsumer&lt;T&gt; of(Optional&lt;T&gt; optional) {
        return new OptionalConsumer&lt;&gt;(optional);
    }

    public OptionalConsumer&lt;T&gt; ifPresent(Consumer&lt;T&gt; c) {
        optional.ifPresent(c);
        return this;
    }

    public OptionalConsumer&lt;T&gt; ifNotPresent(Runnable r) {
        if (!optional.isPresent()) {
            r.run();
        }
        return this;
    }
}
******************************
Normalized:
public class OptionalConsumer&lt;T&gt; {
    private Optional&lt;T&gt; optional;

    private OptionalConsumer(Optional&lt;T&gt; optional) {
        this.optional = optional;
    }

    public static &lt;T&gt; OptionalConsumer&lt;T&gt; of(Optional&lt;T&gt; optional) {
        return new OptionalConsumer&lt;&gt;(optional);
    }

    public OptionalConsumer&lt;T&gt; ifPresent(Consumer&lt;T&gt; c) {
        optional.ifPresent(c);
        return this;
    }

    public OptionalConsumer&lt;T&gt; ifNotPresent(Runnable r) {
        if (!optional.isPresent()) {
            r.run();
        }
        return this;
    }
}
******************************
Original:
%20 is space
%5B is '['
and %5D is ']'
******************************
Normalized:
******************************
Original:
%20 is space
%5B is '['
and %5D is ']'
******************************
Normalized:
%20 is space
%5B is '['
and %5D is ']'
******************************
Original:
-Xmx83886080
           -Xmx81920k
           -Xmx80m
******************************
Normalized:
******************************
Original:
-Xmx83886080
           -Xmx81920k
           -Xmx80m
******************************
Normalized:
-Xmx83886080
           -Xmx81920k
           -Xmx80m
******************************
Original:
&lt;project&gt;
  [...]
  &lt;build&gt;
    [...]
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;version&gt;(whatever version is current)&lt;/version&gt;
        &lt;configuration&gt;
          &lt;!-- or whatever version you use --&gt;
          &lt;source&gt;1.7&lt;/source&gt;
          &lt;target&gt;1.7&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
    [...]
  &lt;/build&gt;
  [...]
&lt;/project&gt;
******************************
Normalized:
******************************
Original:
&lt;project&gt;
  [...]
  &lt;build&gt;
    [...]
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;version&gt;(whatever version is current)&lt;/version&gt;
        &lt;configuration&gt;
          &lt;!-- or whatever version you use --&gt;
          &lt;source&gt;1.7&lt;/source&gt;
          &lt;target&gt;1.7&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
    [...]
  &lt;/build&gt;
  [...]
&lt;/project&gt;
******************************
Normalized:
&lt;project&gt;
  [...]
  &lt;build&gt;
    [...]
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;version&gt;(whatever version is current)&lt;/version&gt;
        &lt;configuration&gt;
          &lt;!-- or whatever version you use --&gt;
          &lt;source&gt;1.7&lt;/source&gt;
          &lt;target&gt;1.7&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
    [...]
  &lt;/build&gt;
  [...]
&lt;/project&gt;
******************************
Original:
@GET
@Path("retrieve/{uuid}")
public Response retrieveSomething(@PathParam("uuid") String uuid) {
    if(uuid == null || uuid.trim().length() == 0) {
        return Response.serverError().entity("UUID cannot be blank").build();
    }
    Entity entity = service.getById(uuid);
    if(entity == null) {
        return Response.status(Response.Status.NOT_FOUND).entity("Entity not found for UUID: " + uuid).build();
    }
    String json = //convert entity to json
    return Response.ok(json, MediaType.APPLICATION_JSON).build();
}
******************************
Normalized:
******************************
Original:
@GET
@Path("retrieve/{uuid}")
public Response retrieveSomething(@PathParam("uuid") String uuid) {
    if(uuid == null || uuid.trim().length() == 0) {
        return Response.serverError().entity("UUID cannot be blank").build();
    }
    Entity entity = service.getById(uuid);
    if(entity == null) {
        return Response.status(Response.Status.NOT_FOUND).entity("Entity not found for UUID: " + uuid).build();
    }
    String json = //convert entity to json
    return Response.ok(json, MediaType.APPLICATION_JSON).build();
}
******************************
Normalized:
@GET
@Path("retrieve/{uuid}")
public Response retrieveSomething(@PathParam("uuid") String uuid) {
    if(uuid == null || uuid.trim().length() == 0) {
        return Response.serverError().entity("UUID cannot be blank").build();
    }
    Entity entity = service.getById(uuid);
    if(entity == null) {
        return Response.status(Response.Status.NOT_FOUND).entity("Entity not found for UUID: " + uuid).build();
    }
    String json = //convert entity to json
    return Response.ok(json, MediaType.APPLICATION_JSON).build();
}
******************************
Original:
&lt;foo&gt;hello 
wor
ld&lt;/foo&gt;
******************************
Normalized:
******************************
Original:
&lt;foo&gt;hello 
wor
ld&lt;/foo&gt;
******************************
Normalized:
&lt;foo&gt;hello 
wor
ld&lt;/foo&gt;
******************************
Original:
Stream&lt;T&gt; stream()
******************************
Normalized:
******************************
Original:
Stream&lt;T&gt; stream()
******************************
Normalized:
Stream&lt;T&gt; stream()
******************************
Original:
// Scala
val lines = fromString(data).getLines
val registrants = lines.map(Registrant)
registrants.foreach(println)
registrants.foreach(println)
******************************
Normalized:
******************************
Original:
// Scala
val lines = fromString(data).getLines
val registrants = lines.map(Registrant)
registrants.foreach(println)
registrants.foreach(println)
******************************
Normalized:
// Scala
val lines = fromString(data).getLines
val registrants = lines.map(Registrant)
registrants.foreach(println)
registrants.foreach(println)
******************************
Original:
public enum Tax {
    NONE(0), SALES(10), IMPORT(5);

    private final int value;
    private Tax(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }
}

...

public int getTaxValue() {
    Tax tax = Tax.NONE; // Or whatever
    return tax.getValue();
}
******************************
Normalized:
******************************
Original:
public enum Tax {
    NONE(0), SALES(10), IMPORT(5);

    private final int value;
    private Tax(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }
}

...

public int getTaxValue() {
    Tax tax = Tax.NONE; // Or whatever
    return tax.getValue();
}
******************************
Normalized:
public enum Tax {
    NONE(0), SALES(10), IMPORT(5);

    private final int value;
    private Tax(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }
}

...

public int getTaxValue() {
    Tax tax = Tax.NONE; // Or whatever
    return tax.getValue();
}
******************************
Original:
.andExpect(content().string("\"Username already taken - please try with different username\""));
******************************
Normalized:
******************************
Original:
.andExpect(content().string("\"Username already taken - please try with different username\""));
******************************
Normalized:
.andExpect(content().string("\"Username already taken - please try with different username\""));
******************************
Original:
public class ListExample {

    public static void main(String[] args) {
        List&lt;Model&gt; models = new ArrayList&lt;&gt;();

        // TODO: First create your model and add to models ArrayList, to prevent NullPointerException for trying this example

        // Print the name from the list....
        for(Model model : models) {
            System.out.println(model.getName());
        }

        // Or like this...
        for(int i = 0; i &lt; models.size(); i++) {
            System.out.println(models.get(i).getName());
        }
    }
}

class Model {

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
******************************
Normalized:
******************************
Original:
public class ListExample {

    public static void main(String[] args) {
        List&lt;Model&gt; models = new ArrayList&lt;&gt;();

        // TODO: First create your model and add to models ArrayList, to prevent NullPointerException for trying this example

        // Print the name from the list....
        for(Model model : models) {
            System.out.println(model.getName());
        }

        // Or like this...
        for(int i = 0; i &lt; models.size(); i++) {
            System.out.println(models.get(i).getName());
        }
    }
}

class Model {

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
******************************
Normalized:
public class ListExample {

    public static void main(String[] args) {
        List&lt;Model&gt; models = new ArrayList&lt;&gt;();

        // TODO: First create your model and add to models ArrayList, to prevent NullPointerException for trying this example

        // Print the name from the list....
        for(Model model : models) {
            System.out.println(model.getName());
        }

        // Or like this...
        for(int i = 0; i &lt; models.size(); i++) {
            System.out.println(models.get(i).getName());
        }
    }
}

class Model {

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
******************************
Original:
-Dmaven.javadoc.skip=true
******************************
Normalized:
******************************
Original:
-Dmaven.javadoc.skip=true
******************************
Normalized:
-Dmaven.javadoc.skip=true
******************************
Original:
.getMap(locations.toArray(new WorldLocation[locations.size()]))
******************************
Normalized:
******************************
Original:
.getMap(locations.toArray(new WorldLocation[locations.size()]))
******************************
Normalized:
.getMap(locations.toArray(new WorldLocation[locations.size()]))
******************************
Original:
keytool -importcert -file certificate.cer -keystore keystore.jks -alias "Alias"
******************************
Normalized:
******************************
Original:
keytool -importcert -file certificate.cer -keystore keystore.jks -alias "Alias"
******************************
Normalized:
keytool -importcert -file certificate.cer -keystore keystore.jks -alias "Alias"
******************************
Original:
List&lt;String&gt; classNames = new ArrayList&lt;String&gt;();
ZipInputStream zip = new ZipInputStream(new FileInputStream("/path/to/jar/file.jar"));
for (ZipEntry entry = zip.getNextEntry(); entry != null; entry = zip.getNextEntry()) {
    if (!entry.isDirectory() &amp;&amp; entry.getName().endsWith(".class")) {
        // This ZipEntry represents a class. Now, what class does it represent?
        String className = entry.getName().replace('/', '.'); // including ".class"
        classNames.add(className.substring(0, className.length() - ".class".length()));
    }
}
******************************
Normalized:
******************************
Original:
List&lt;String&gt; classNames = new ArrayList&lt;String&gt;();
ZipInputStream zip = new ZipInputStream(new FileInputStream("/path/to/jar/file.jar"));
for (ZipEntry entry = zip.getNextEntry(); entry != null; entry = zip.getNextEntry()) {
    if (!entry.isDirectory() &amp;&amp; entry.getName().endsWith(".class")) {
        // This ZipEntry represents a class. Now, what class does it represent?
        String className = entry.getName().replace('/', '.'); // including ".class"
        classNames.add(className.substring(0, className.length() - ".class".length()));
    }
}
******************************
Normalized:
List&lt;String&gt; classNames = new ArrayList&lt;String&gt;();
ZipInputStream zip = new ZipInputStream(new FileInputStream("/path/to/jar/file.jar"));
for (ZipEntry entry = zip.getNextEntry(); entry != null; entry = zip.getNextEntry()) {
    if (!entry.isDirectory() &amp;&amp; entry.getName().endsWith(".class")) {
        // This ZipEntry represents a class. Now, what class does it represent?
        String className = entry.getName().replace('/', '.'); // including ".class"
        classNames.add(className.substring(0, className.length() - ".class".length()));
    }
}
******************************
Original:
public class YourActivity extends Activity {

    private ListView lv;

    public void onCreate(Bundle saveInstanceState) {
         setContentView(R.layout.your_layout);

         lv = (ListView) findViewById(R.id.your_list_view_id);

         // Instanciating an array list (you don't need to do this, 
         // you already have yours).
         List&lt;String&gt; your_array_list = new ArrayList&lt;String&gt;();
         your_array_list.add("foo");
         your_array_list.add("bar");

         // This is the array adapter, it takes the context of the activity as a 
         // first parameter, the type of list view as a second parameter and your 
         // array as a third parameter.
         ArrayAdapter&lt;String&gt; arrayAdapter = new ArrayAdapter&lt;String&gt;(
                 this, 
                 android.R.layout.simple_list_item_1,
                 your_array_list );

         lv.setAdapter(arrayAdapter); 
    }
}
******************************
Normalized:
******************************
Original:
public class YourActivity extends Activity {

    private ListView lv;

    public void onCreate(Bundle saveInstanceState) {
         setContentView(R.layout.your_layout);

         lv = (ListView) findViewById(R.id.your_list_view_id);

         // Instanciating an array list (you don't need to do this, 
         // you already have yours).
         List&lt;String&gt; your_array_list = new ArrayList&lt;String&gt;();
         your_array_list.add("foo");
         your_array_list.add("bar");

         // This is the array adapter, it takes the context of the activity as a 
         // first parameter, the type of list view as a second parameter and your 
         // array as a third parameter.
         ArrayAdapter&lt;String&gt; arrayAdapter = new ArrayAdapter&lt;String&gt;(
                 this, 
                 android.R.layout.simple_list_item_1,
                 your_array_list );

         lv.setAdapter(arrayAdapter); 
    }
}
******************************
Normalized:
public class YourActivity extends Activity {

    private ListView lv;

    public void onCreate(Bundle saveInstanceState) {
         setContentView(R.layout.your_layout);

         lv = (ListView) findViewById(R.id.your_list_view_id);

         // Instanciating an array list (you don't need to do this, 
         // you already have yours).
         List&lt;String&gt; your_array_list = new ArrayList&lt;String&gt;();
         your_array_list.add("foo");
         your_array_list.add("bar");

         // This is the array adapter, it takes the context of the activity as a 
         // first parameter, the type of list view as a second parameter and your 
         // array as a third parameter.
         ArrayAdapter&lt;String&gt; arrayAdapter = new ArrayAdapter&lt;String&gt;(
                 this, 
                 android.R.layout.simple_list_item_1,
                 your_array_list );

         lv.setAdapter(arrayAdapter); 
    }
}
******************************
Original:
{
    "objects" : ["One", "Two", "Three"]
}
******************************
Normalized:
******************************
Original:
{
    "objects" : ["One", "Two", "Three"]
}
******************************
Normalized:
{
    "objects" : ["One", "Two", "Three"]
}
******************************
Original:
public String[] split(CharSequence input, int limit) {
    int index = 0;
    boolean matchLimited = limit &gt; 0;
    ArrayList&lt;String&gt; matchList = new ArrayList&lt;&gt;();
    Matcher m = matcher(input);

    // Add segments before each match found
    while(m.find()) {
        if (!matchLimited || matchList.size() &lt; limit - 1) {
            String match = input.subSequence(index, m.start()).toString();
            matchList.add(match);
            index = m.end();
        } else if (matchList.size() == limit - 1) { // last one
            String match = input.subSequence(index,
                                             input.length()).toString();
            matchList.add(match);
            index = m.end();
        }
    }

    // If no match was found, return this
    if (index == 0)
        return new String[] {input.toString()};

    // Add remaining segment
    if (!matchLimited || matchList.size() &lt; limit)
        matchList.add(input.subSequence(index, input.length()).toString());

    // Construct result
    int resultSize = matchList.size();
    if (limit == 0)
        while (resultSize &gt; 0 &amp;&amp; matchList.get(resultSize-1).equals(""))
            resultSize--;
    String[] result = new String[resultSize];
    return matchList.subList(0, resultSize).toArray(result);
}
******************************
Normalized:
******************************
Original:
public String[] split(CharSequence input, int limit) {
    int index = 0;
    boolean matchLimited = limit &gt; 0;
    ArrayList&lt;String&gt; matchList = new ArrayList&lt;&gt;();
    Matcher m = matcher(input);

    // Add segments before each match found
    while(m.find()) {
        if (!matchLimited || matchList.size() &lt; limit - 1) {
            String match = input.subSequence(index, m.start()).toString();
            matchList.add(match);
            index = m.end();
        } else if (matchList.size() == limit - 1) { // last one
            String match = input.subSequence(index,
                                             input.length()).toString();
            matchList.add(match);
            index = m.end();
        }
    }

    // If no match was found, return this
    if (index == 0)
        return new String[] {input.toString()};

    // Add remaining segment
    if (!matchLimited || matchList.size() &lt; limit)
        matchList.add(input.subSequence(index, input.length()).toString());

    // Construct result
    int resultSize = matchList.size();
    if (limit == 0)
        while (resultSize &gt; 0 &amp;&amp; matchList.get(resultSize-1).equals(""))
            resultSize--;
    String[] result = new String[resultSize];
    return matchList.subList(0, resultSize).toArray(result);
}
******************************
Normalized:
public String[] split(CharSequence input, int limit) {
    int index = 0;
    boolean matchLimited = limit &gt; 0;
    ArrayList&lt;String&gt; matchList = new ArrayList&lt;&gt;();
    Matcher m = matcher(input);

    // Add segments before each match found
    while(m.find()) {
        if (!matchLimited || matchList.size() &lt; limit - 1) {
            String match = input.subSequence(index, m.start()).toString();
            matchList.add(match);
            index = m.end();
        } else if (matchList.size() == limit - 1) { // last one
            String match = input.subSequence(index,
                                             input.length()).toString();
            matchList.add(match);
            index = m.end();
        }
    }

    // If no match was found, return this
    if (index == 0)
        return new String[] {input.toString()};

    // Add remaining segment
    if (!matchLimited || matchList.size() &lt; limit)
        matchList.add(input.subSequence(index, input.length()).toString());

    // Construct result
    int resultSize = matchList.size();
    if (limit == 0)
        while (resultSize &gt; 0 &amp;&amp; matchList.get(resultSize-1).equals(""))
            resultSize--;
    String[] result = new String[resultSize];
    return matchList.subList(0, resultSize).toArray(result);
}
******************************
Original:
",test" split ','
******************************
Normalized:
******************************
Original:
",test" split ','
******************************
Normalized:
",test" split ','
******************************
Original:
ArgumentCaptor&lt;String&gt; argument = ArgumentCaptor.forClass(String.class);

verify(errors, atLeastOnce()).add(argument.capture(), any(ActionMessage.class));

List&lt;String&gt; values = argument.getAllValues();

assertTrue(values.contains("exception.message"));
assertTrue(values.contains("exception.detail"));
******************************
Normalized:
******************************
Original:
ArgumentCaptor&lt;String&gt; argument = ArgumentCaptor.forClass(String.class);

verify(errors, atLeastOnce()).add(argument.capture(), any(ActionMessage.class));

List&lt;String&gt; values = argument.getAllValues();

assertTrue(values.contains("exception.message"));
assertTrue(values.contains("exception.detail"));
******************************
Normalized:
ArgumentCaptor&lt;String&gt; argument = ArgumentCaptor.forClass(String.class);

verify(errors, atLeastOnce()).add(argument.capture(), any(ActionMessage.class));

List&lt;String&gt; values = argument.getAllValues();

assertTrue(values.contains("exception.message"));
assertTrue(values.contains("exception.detail"));
******************************
Original:
@Autowired
private Environment environment;
....

this.environment.getActiveProfiles();
******************************
Normalized:
******************************
Original:
@Autowired
private Environment environment;
....

this.environment.getActiveProfiles();
******************************
Normalized:
@Autowired
private Environment environment;
....

this.environment.getActiveProfiles();
******************************
Original:
spring.data.rest.basePath=/api
******************************
Normalized:
******************************
Original:
spring.data.rest.basePath=/api
******************************
Normalized:
spring.data.rest.basePath=/api
******************************
Original:
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class Test {
    public static void main(String[] s) {
        Map&lt;String, Boolean&gt; whoLetDogsOut = new ConcurrentHashMap&lt;&gt;();
        whoLetDogsOut.computeIfAbsent("snoop", k -&gt; f(k));
        whoLetDogsOut.computeIfAbsent("snoop", k -&gt; f(k));
    }
    static boolean f(String s) {
        System.out.println("creating a value for \""+s+'"');
        return s.isEmpty();
    }
}
******************************
Normalized:
******************************
Original:
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class Test {
    public static void main(String[] s) {
        Map&lt;String, Boolean&gt; whoLetDogsOut = new ConcurrentHashMap&lt;&gt;();
        whoLetDogsOut.computeIfAbsent("snoop", k -&gt; f(k));
        whoLetDogsOut.computeIfAbsent("snoop", k -&gt; f(k));
    }
    static boolean f(String s) {
        System.out.println("creating a value for \""+s+'"');
        return s.isEmpty();
    }
}
******************************
Normalized:
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class Test {
    public static void main(String[] s) {
        Map&lt;String, Boolean&gt; whoLetDogsOut = new ConcurrentHashMap&lt;&gt;();
        whoLetDogsOut.computeIfAbsent("snoop", k -&gt; f(k));
        whoLetDogsOut.computeIfAbsent("snoop", k -&gt; f(k));
    }
    static boolean f(String s) {
        System.out.println("creating a value for \""+s+'"');
        return s.isEmpty();
    }
}
******************************
Original:
Set&lt;MyClass&gt; set = myStream.collect(Collectors.toCollection(LinkedHashSet::new));
******************************
Normalized:
******************************
Original:
Set&lt;MyClass&gt; set = myStream.collect(Collectors.toCollection(LinkedHashSet::new));
******************************
Normalized:
Set&lt;MyClass&gt; set = myStream.collect(Collectors.toCollection(LinkedHashSet::new));
******************************
Original:
ClassModifiers:
    ClassModifier
    ClassModifiers ClassModifier

ClassModifier: one of
    Annotation public protected private
    abstract static final strictfp
******************************
Normalized:
******************************
Original:
ClassModifiers:
    ClassModifier
    ClassModifiers ClassModifier

ClassModifier: one of
    Annotation public protected private
    abstract static final strictfp
******************************
Normalized:
ClassModifiers:
    ClassModifier
    ClassModifiers ClassModifier

ClassModifier: one of
    Annotation public protected private
    abstract static final strictfp
******************************
Original:
Reference,Title,Description
1,"My little title","My description, which may contain ""speech marks"" and commas."
2,"My other little title","My other description, which may also contain ""speech marks"" and commas."
******************************
Normalized:
******************************
Original:
Reference,Title,Description
1,"My little title","My description, which may contain ""speech marks"" and commas."
2,"My other little title","My other description, which may also contain ""speech marks"" and commas."
******************************
Normalized:
Reference,Title,Description
1,"My little title","My description, which may contain ""speech marks"" and commas."
2,"My other little title","My other description, which may also contain ""speech marks"" and commas."
******************************
Original:
(test1=false) || (test1 == false)
******************************
Normalized:
******************************
Original:
(test1=false) || (test1 == false)
******************************
Normalized:
(test1=false) || (test1 == false)
******************************
Original:
&lt;context-param&gt;
    &lt;param-name&gt;com.sun.faces.numberOfLogicalViews&lt;/param-name&gt;
    &lt;param-value&gt;15&lt;/param-value&gt;
&lt;/context-param&gt;
******************************
Normalized:
******************************
Original:
&lt;context-param&gt;
    &lt;param-name&gt;com.sun.faces.numberOfLogicalViews&lt;/param-name&gt;
    &lt;param-value&gt;15&lt;/param-value&gt;
&lt;/context-param&gt;
******************************
Normalized:
&lt;context-param&gt;
    &lt;param-name&gt;com.sun.faces.numberOfLogicalViews&lt;/param-name&gt;
    &lt;param-value&gt;15&lt;/param-value&gt;
&lt;/context-param&gt;
******************************
Original:
window.addMouseListener(object : MouseAdapter() { 
    override fun mouseClicked(e : MouseEvent) { 
    // ... 
}
******************************
Normalized:
******************************
Original:
window.addMouseListener(object : MouseAdapter() { 
    override fun mouseClicked(e : MouseEvent) { 
    // ... 
}
******************************
Normalized:
window.addMouseListener(object : MouseAdapter() { 
    override fun mouseClicked(e : MouseEvent) { 
    // ... 
}
******************************
Original:
Array
Arrays
ArrayUtil
ArrayUtils
ArrayHelper
******************************
Normalized:
******************************
Original:
Array
Arrays
ArrayUtil
ArrayUtils
ArrayHelper
******************************
Normalized:
Array
Arrays
ArrayUtil
ArrayUtils
ArrayHelper
******************************
Original:
keytool -importkeystore -srckeystore mypfxfile.pfx -srcstoretype pkcs12 
-destkeystore clientcert.jks -deststoretype JKS
******************************
Normalized:
******************************
Original:
keytool -importkeystore -srckeystore mypfxfile.pfx -srcstoretype pkcs12 
-destkeystore clientcert.jks -deststoretype JKS
******************************
Normalized:
keytool -importkeystore -srckeystore mypfxfile.pfx -srcstoretype pkcs12 
-destkeystore clientcert.jks -deststoretype JKS
******************************
Original:
Function&lt;Integer,Integer&gt; f = (x,y) -&gt; x + y
******************************
Normalized:
******************************
Original:
Function&lt;Integer,Integer&gt; f = (x,y) -&gt; x + y
******************************
Normalized:
Function&lt;Integer,Integer&gt; f = (x,y) -&gt; x + y
******************************
Original:
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;spring-source-download&lt;/groupId&gt;
  &lt;artifactId&gt;SpringDependencies&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
  &lt;/properties&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
      &lt;version&gt;3.2.4.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.8&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;download-dependencies&lt;/id&gt;
            &lt;phase&gt;generate-resources&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;copy-dependencies&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;outputDirectory&gt;${project.build.directory}/dependencies&lt;/outputDirectory&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
******************************
Normalized:
******************************
Original:
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;spring-source-download&lt;/groupId&gt;
  &lt;artifactId&gt;SpringDependencies&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
  &lt;/properties&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
      &lt;version&gt;3.2.4.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.8&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;download-dependencies&lt;/id&gt;
            &lt;phase&gt;generate-resources&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;copy-dependencies&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;outputDirectory&gt;${project.build.directory}/dependencies&lt;/outputDirectory&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
******************************
Normalized:
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;spring-source-download&lt;/groupId&gt;
  &lt;artifactId&gt;SpringDependencies&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
  &lt;/properties&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
      &lt;version&gt;3.2.4.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.8&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;download-dependencies&lt;/id&gt;
            &lt;phase&gt;generate-resources&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;copy-dependencies&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;outputDirectory&gt;${project.build.directory}/dependencies&lt;/outputDirectory&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
******************************
Original:
import java.io.File;
...
  File dir = new File(myDirectoryPath);
  File[] directoryListing = dir.listFiles();
  if (directoryListing != null) {
    for (File child : directoryListing) {
      // Do something with child
    }
  } else {
    // Handle the case where dir is not really a directory.
    // Checking dir.isDirectory() above would not be sufficient
    // to avoid race conditions with another process that deletes
    // directories.
  }
******************************
Normalized:
******************************
Original:
import java.io.File;
...
  File dir = new File(myDirectoryPath);
  File[] directoryListing = dir.listFiles();
  if (directoryListing != null) {
    for (File child : directoryListing) {
      // Do something with child
    }
  } else {
    // Handle the case where dir is not really a directory.
    // Checking dir.isDirectory() above would not be sufficient
    // to avoid race conditions with another process that deletes
    // directories.
  }
******************************
Normalized:
import java.io.File;
...
  File dir = new File(myDirectoryPath);
  File[] directoryListing = dir.listFiles();
  if (directoryListing != null) {
    for (File child : directoryListing) {
      // Do something with child
    }
  } else {
    // Handle the case where dir is not really a directory.
    // Checking dir.isDirectory() above would not be sufficient
    // to avoid race conditions with another process that deletes
    // directories.
  }
******************************
Original:
Name:  Oxygen  
Location:  http://download.eclipse.org/releases/oxygen/
******************************
Normalized:
******************************
Original:
Name:  Oxygen  
Location:  http://download.eclipse.org/releases/oxygen/
******************************
Normalized:
Name:  Oxygen  
Location:  http://download.eclipse.org/releases/oxygen/
******************************
Original:
{
        Date dt2 = new DateAndTime().getCurrentDateTime();

        long diff = dt2.getTime() - dt1.getTime();
        long diffSeconds = diff / 1000 % 60;
        long diffMinutes = diff / (60 * 1000) % 60;
        long diffHours = diff / (60 * 60 * 1000);
        int diffInDays = (int) ((dt2.getTime() - dt1.getTime()) / (1000 * 60 * 60 * 24));

        if (diffInDays &gt; 1) {
            System.err.println("Difference in number of days (2) : " + diffInDays);
            return false;
        } else if (diffHours &gt; 24) {

            System.err.println("&gt;24");
            return false;
        } else if ((diffHours == 24) &amp;&amp; (diffMinutes &gt;= 1)) {
            System.err.println("minutes");
            return false;
        }
        return true;
}
******************************
Normalized:
******************************
Original:
{
        Date dt2 = new DateAndTime().getCurrentDateTime();

        long diff = dt2.getTime() - dt1.getTime();
        long diffSeconds = diff / 1000 % 60;
        long diffMinutes = diff / (60 * 1000) % 60;
        long diffHours = diff / (60 * 60 * 1000);
        int diffInDays = (int) ((dt2.getTime() - dt1.getTime()) / (1000 * 60 * 60 * 24));

        if (diffInDays &gt; 1) {
            System.err.println("Difference in number of days (2) : " + diffInDays);
            return false;
        } else if (diffHours &gt; 24) {

            System.err.println("&gt;24");
            return false;
        } else if ((diffHours == 24) &amp;&amp; (diffMinutes &gt;= 1)) {
            System.err.println("minutes");
            return false;
        }
        return true;
}
******************************
Normalized:
{
        Date dt2 = new DateAndTime().getCurrentDateTime();

        long diff = dt2.getTime() - dt1.getTime();
        long diffSeconds = diff / 1000 % 60;
        long diffMinutes = diff / (60 * 1000) % 60;
        long diffHours = diff / (60 * 60 * 1000);
        int diffInDays = (int) ((dt2.getTime() - dt1.getTime()) / (1000 * 60 * 60 * 24));

        if (diffInDays &gt; 1) {
            System.err.println("Difference in number of days (2) : " + diffInDays);
            return false;
        } else if (diffHours &gt; 24) {

            System.err.println("&gt;24");
            return false;
        } else if ((diffHours == 24) &amp;&amp; (diffMinutes &gt;= 1)) {
            System.err.println("minutes");
            return false;
        }
        return true;
}
******************************
Original:
&lt;c:forEach var="categoryName" items="${categoriesList}" varStatus="loop"&gt;
    &lt;li&gt;&lt;a onclick="getCategoryIndex(${loop.index})" href="#"&gt;${categoryName}&lt;/a&gt;&lt;/li&gt;
&lt;/c:forEach&gt;
******************************
Normalized:
******************************
Original:
&lt;c:forEach var="categoryName" items="${categoriesList}" varStatus="loop"&gt;
    &lt;li&gt;&lt;a onclick="getCategoryIndex(${loop.index})" href="#"&gt;${categoryName}&lt;/a&gt;&lt;/li&gt;
&lt;/c:forEach&gt;
******************************
Normalized:
&lt;c:forEach var="categoryName" items="${categoriesList}" varStatus="loop"&gt;
    &lt;li&gt;&lt;a onclick="getCategoryIndex(${loop.index})" href="#"&gt;${categoryName}&lt;/a&gt;&lt;/li&gt;
&lt;/c:forEach&gt;
******************************
Original:
zip -d file.jar unwanted_file.txt
******************************
Normalized:
******************************
Original:
zip -d file.jar unwanted_file.txt
******************************
Normalized:
zip -d file.jar unwanted_file.txt
******************************
Original:
scala&gt; Option(null)
res4: Option[Null] = None

scala&gt; Option(3)   
res5: Option[Int] = Some(3)
******************************
Normalized:
******************************
Original:
scala&gt; Option(null)
res4: Option[Null] = None

scala&gt; Option(3)   
res5: Option[Int] = Some(3)
******************************
Normalized:
scala&gt; Option(null)
res4: Option[Null] = None

scala&gt; Option(3)   
res5: Option[Int] = Some(3)
******************************
Original:
//Written by K@stackoverflow
public class Main {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        ArrayList&lt;Person&gt; people = new ArrayList&lt;Person&gt;();
        people.add(new Person("Subash Adhikari", 28));
        people.add(new Person("K", 28));
        people.add(new Person("StackOverflow", 4));
        people.add(new Person("Subash Adhikari", 28));

        for (int i = 0; i &lt; people.size() - 1; i++) {
            for (int y = i + 1; y &lt;= people.size() - 1; y++) {
                boolean check = people.get(i).equals(people.get(y));

                System.out.println("-- " + people.get(i).getName() + " - VS - " + people.get(y).getName());
                System.out.println(check);
            }
        }
    }
}

//written by K@stackoverflow
public class Person {
    private String name;
    private int age;

    public Person(String name, int age){
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }

        if (!Person.class.isAssignableFrom(obj.getClass())) {
            return false;
        }

        final Person other = (Person) obj;
        if ((this.name == null) ? (other.name != null) : !this.name.equals(other.name)) {
            return false;
        }

        if (this.age != other.age) {
            return false;
        }

        return true;
    }

    @Override
    public int hashCode() {
        int hash = 3;
        hash = 53 * hash + (this.name != null ? this.name.hashCode() : 0);
        hash = 53 * hash + this.age;
        return hash;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
******************************
Normalized:
******************************
Original:
//Written by K@stackoverflow
public class Main {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        ArrayList&lt;Person&gt; people = new ArrayList&lt;Person&gt;();
        people.add(new Person("Subash Adhikari", 28));
        people.add(new Person("K", 28));
        people.add(new Person("StackOverflow", 4));
        people.add(new Person("Subash Adhikari", 28));

        for (int i = 0; i &lt; people.size() - 1; i++) {
            for (int y = i + 1; y &lt;= people.size() - 1; y++) {
                boolean check = people.get(i).equals(people.get(y));

                System.out.println("-- " + people.get(i).getName() + " - VS - " + people.get(y).getName());
                System.out.println(check);
            }
        }
    }
}

//written by K@stackoverflow
public class Person {
    private String name;
    private int age;

    public Person(String name, int age){
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }

        if (!Person.class.isAssignableFrom(obj.getClass())) {
            return false;
        }

        final Person other = (Person) obj;
        if ((this.name == null) ? (other.name != null) : !this.name.equals(other.name)) {
            return false;
        }

        if (this.age != other.age) {
            return false;
        }

        return true;
    }

    @Override
    public int hashCode() {
        int hash = 3;
        hash = 53 * hash + (this.name != null ? this.name.hashCode() : 0);
        hash = 53 * hash + this.age;
        return hash;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
******************************
Normalized:
//Written by K@stackoverflow
public class Main {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        ArrayList&lt;Person&gt; people = new ArrayList&lt;Person&gt;();
        people.add(new Person("Subash Adhikari", 28));
        people.add(new Person("K", 28));
        people.add(new Person("StackOverflow", 4));
        people.add(new Person("Subash Adhikari", 28));

        for (int i = 0; i &lt; people.size() - 1; i++) {
            for (int y = i + 1; y &lt;= people.size() - 1; y++) {
                boolean check = people.get(i).equals(people.get(y));

                System.out.println("-- " + people.get(i).getName() + " - VS - " + people.get(y).getName());
                System.out.println(check);
            }
        }
    }
}

//written by K@stackoverflow
public class Person {
    private String name;
    private int age;

    public Person(String name, int age){
        this.name = name;
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }

        if (!Person.class.isAssignableFrom(obj.getClass())) {
            return false;
        }

        final Person other = (Person) obj;
        if ((this.name == null) ? (other.name != null) : !this.name.equals(other.name)) {
            return false;
        }

        if (this.age != other.age) {
            return false;
        }

        return true;
    }

    @Override
    public int hashCode() {
        int hash = 3;
        hash = 53 * hash + (this.name != null ? this.name.hashCode() : 0);
        hash = 53 * hash + this.age;
        return hash;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
******************************
Original:
EntityManager em = … // obtain an EntityManager
JpaRepositoryFactory factory = new JpaRepositoryFactory(em);
UserRepository repository = factory.getRepository(UserRepository.class);
******************************
Normalized:
******************************
Original:
EntityManager em = … // obtain an EntityManager
JpaRepositoryFactory factory = new JpaRepositoryFactory(em);
UserRepository repository = factory.getRepository(UserRepository.class);
******************************
Normalized:
EntityManager em = … // obtain an EntityManager
JpaRepositoryFactory factory = new JpaRepositoryFactory(em);
UserRepository repository = factory.getRepository(UserRepository.class);
******************************
Original:
org.apache.commons.lang.time.StopWatch
******************************
Normalized:
******************************
Original:
org.apache.commons.lang.time.StopWatch
******************************
Normalized:
org.apache.commons.lang.time.StopWatch
******************************
Original:
public static boolean openWebpage(URI uri) {
    Desktop desktop = Desktop.isDesktopSupported() ? Desktop.getDesktop() : null;
    if (desktop != null &amp;&amp; desktop.isSupported(Desktop.Action.BROWSE)) {
        try {
            desktop.browse(uri);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    return false;
}

public static boolean openWebpage(URL url) {
    try {
        return openWebpage(url.toURI());
    } catch (URISyntaxException e) {
        e.printStackTrace();
    }
    return false;
}
******************************
Normalized:
******************************
Original:
public static boolean openWebpage(URI uri) {
    Desktop desktop = Desktop.isDesktopSupported() ? Desktop.getDesktop() : null;
    if (desktop != null &amp;&amp; desktop.isSupported(Desktop.Action.BROWSE)) {
        try {
            desktop.browse(uri);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    return false;
}

public static boolean openWebpage(URL url) {
    try {
        return openWebpage(url.toURI());
    } catch (URISyntaxException e) {
        e.printStackTrace();
    }
    return false;
}
******************************
Normalized:
public static boolean openWebpage(URI uri) {
    Desktop desktop = Desktop.isDesktopSupported() ? Desktop.getDesktop() : null;
    if (desktop != null &amp;&amp; desktop.isSupported(Desktop.Action.BROWSE)) {
        try {
            desktop.browse(uri);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    return false;
}

public static boolean openWebpage(URL url) {
    try {
        return openWebpage(url.toURI());
    } catch (URISyntaxException e) {
        e.printStackTrace();
    }
    return false;
}
******************************
Original:
&lt;SOAP-ENV:Envelope
  xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
  SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;
  &lt;SOAP-ENV:Body&gt;
    &lt;m:GetBookPrice xmlns:m="http://namespaces.my-example-book-info.com"&gt;
      &lt;ISBN&gt;978-0451524935&lt;/ISBN&gt;
      &lt;Title&gt;1984&lt;/Title&gt;
      &lt;NumPages&gt;328&lt;/NumPages&gt;
    &lt;/m:GetBookPrice&gt;
  &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;
******************************
Normalized:
******************************
Original:
&lt;SOAP-ENV:Envelope
  xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
  SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;
  &lt;SOAP-ENV:Body&gt;
    &lt;m:GetBookPrice xmlns:m="http://namespaces.my-example-book-info.com"&gt;
      &lt;ISBN&gt;978-0451524935&lt;/ISBN&gt;
      &lt;Title&gt;1984&lt;/Title&gt;
      &lt;NumPages&gt;328&lt;/NumPages&gt;
    &lt;/m:GetBookPrice&gt;
  &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;
******************************
Normalized:
&lt;SOAP-ENV:Envelope
  xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
  SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;
  &lt;SOAP-ENV:Body&gt;
    &lt;m:GetBookPrice xmlns:m="http://namespaces.my-example-book-info.com"&gt;
      &lt;ISBN&gt;978-0451524935&lt;/ISBN&gt;
      &lt;Title&gt;1984&lt;/Title&gt;
      &lt;NumPages&gt;328&lt;/NumPages&gt;
    &lt;/m:GetBookPrice&gt;
  &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;
******************************
Original:
Set&lt;Integer&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();
 linkedHashSet.add(3);
 linkedHashSet.add(1);
 linkedHashSet.add(2);

 for (int i : linkedHashSet) {
     System.out.println(i);
 }
******************************
Normalized:
******************************
Original:
Set&lt;Integer&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();
 linkedHashSet.add(3);
 linkedHashSet.add(1);
 linkedHashSet.add(2);

 for (int i : linkedHashSet) {
     System.out.println(i);
 }
******************************
Normalized:
Set&lt;Integer&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();
 linkedHashSet.add(3);
 linkedHashSet.add(1);
 linkedHashSet.add(2);

 for (int i : linkedHashSet) {
     System.out.println(i);
 }
******************************
Original:
stack=1, locals=2, args_size=1
         0: bipush        30  // directly push 30 into "s"
         2: istore_1      
         3: return
******************************
Normalized:
******************************
Original:
stack=1, locals=2, args_size=1
         0: bipush        30  // directly push 30 into "s"
         2: istore_1      
         3: return
******************************
Normalized:
stack=1, locals=2, args_size=1
         0: bipush        30  // directly push 30 into "s"
         2: istore_1      
         3: return
******************************
Original:
Set&lt;String&gt; set = Stream.of("a","b","c").collect(Collectors.toSet());
******************************
Normalized:
******************************
Original:
Set&lt;String&gt; set = Stream.of("a","b","c").collect(Collectors.toSet());
******************************
Normalized:
Set&lt;String&gt; set = Stream.of("a","b","c").collect(Collectors.toSet());
******************************
Original:
@SuppressWarnings("unchecked")
public static final &lt;T&gt; List&lt;T&gt; emptyList() {
    return (List&lt;T&gt;) EMPTY_LIST;
}
******************************
Normalized:
******************************
Original:
@SuppressWarnings("unchecked")
public static final &lt;T&gt; List&lt;T&gt; emptyList() {
    return (List&lt;T&gt;) EMPTY_LIST;
}
******************************
Normalized:
@SuppressWarnings("unchecked")
public static final &lt;T&gt; List&lt;T&gt; emptyList() {
    return (List&lt;T&gt;) EMPTY_LIST;
}
******************************
Original:
Class&lt;?&gt; clazz = Class.forName("java.util.Date");
Object date = clazz.newInstance();
******************************
Normalized:
******************************
Original:
Class&lt;?&gt; clazz = Class.forName("java.util.Date");
Object date = clazz.newInstance();
******************************
Normalized:
Class&lt;?&gt; clazz = Class.forName("java.util.Date");
Object date = clazz.newInstance();
******************************
Original:
@GET
@Produces(MediaType.APPLICATION_OCTET_STREAM)
public Response getFile() {
  File file = ... // Initialize this to the File path you want to serve.
  return Response.ok(file, MediaType.APPLICATION_OCTET_STREAM)
      .header("Content-Disposition", "attachment; filename=\"" + file.getName() + "\"" ) //optional
      .build();
}
******************************
Normalized:
******************************
Original:
@GET
@Produces(MediaType.APPLICATION_OCTET_STREAM)
public Response getFile() {
  File file = ... // Initialize this to the File path you want to serve.
  return Response.ok(file, MediaType.APPLICATION_OCTET_STREAM)
      .header("Content-Disposition", "attachment; filename=\"" + file.getName() + "\"" ) //optional
      .build();
}
******************************
Normalized:
@GET
@Produces(MediaType.APPLICATION_OCTET_STREAM)
public Response getFile() {
  File file = ... // Initialize this to the File path you want to serve.
  return Response.ok(file, MediaType.APPLICATION_OCTET_STREAM)
      .header("Content-Disposition", "attachment; filename=\"" + file.getName() + "\"" ) //optional
      .build();
}
******************************
Original:
android:scrollHorizontally="true"
android:ellipsize="end" 
android:maxLines="1"
******************************
Normalized:
******************************
Original:
android:scrollHorizontally="true"
android:ellipsize="end" 
android:maxLines="1"
******************************
Normalized:
android:scrollHorizontally="true"
android:ellipsize="end" 
android:maxLines="1"
******************************
Original:
if (list.size() &gt; 0) {
  Collections.sort(list, new Comparator&lt;Campaign&gt;() {
      @Override
      public int compare(final Campaign object1, final Campaign object2) {
          return object1.getName().compareTo(object2.getName());
      }
  });
}
******************************
Normalized:
******************************
Original:
if (list.size() &gt; 0) {
  Collections.sort(list, new Comparator&lt;Campaign&gt;() {
      @Override
      public int compare(final Campaign object1, final Campaign object2) {
          return object1.getName().compareTo(object2.getName());
      }
  });
}
******************************
Normalized:
if (list.size() &gt; 0) {
  Collections.sort(list, new Comparator&lt;Campaign&gt;() {
      @Override
      public int compare(final Campaign object1, final Campaign object2) {
          return object1.getName().compareTo(object2.getName());
      }
  });
}
******************************
Original:
class A {
   public void foo() throws IOException {..}
}

class B extends A {
   @Override
   public void foo() throws SocketException {..} // allowed

   @Override
   public void foo() throws SQLException {..} // NOT allowed
}
******************************
Normalized:
******************************
Original:
class A {
   public void foo() throws IOException {..}
}

class B extends A {
   @Override
   public void foo() throws SocketException {..} // allowed

   @Override
   public void foo() throws SQLException {..} // NOT allowed
}
******************************
Normalized:
class A {
   public void foo() throws IOException {..}
}

class B extends A {
   @Override
   public void foo() throws SocketException {..} // allowed

   @Override
   public void foo() throws SQLException {..} // NOT allowed
}
******************************
Original:
/etc/init.d/tomcat5.5 start
/etc/init.d/tomcat5.5 stop
/etc/init.d/tomcat5.5 restart
******************************
Normalized:
******************************
Original:
/etc/init.d/tomcat5.5 start
/etc/init.d/tomcat5.5 stop
/etc/init.d/tomcat5.5 restart
******************************
Normalized:
/etc/init.d/tomcat5.5 start
/etc/init.d/tomcat5.5 stop
/etc/init.d/tomcat5.5 restart
******************************
Original:
if (newStr4.startsWith("Mon") || newStr4.startsWith("Tues") || ...)
******************************
Normalized:
******************************
Original:
if (newStr4.startsWith("Mon") || newStr4.startsWith("Tues") || ...)
******************************
Normalized:
if (newStr4.startsWith("Mon") || newStr4.startsWith("Tues") || ...)
******************************
Original:
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;

    &lt;style name="boldText"&gt;
        &lt;item name="android:textStyle"&gt;bold|italic&lt;/item&gt;
        &lt;item name="android:textColor"&gt;#FFFFFF&lt;/item&gt;
    &lt;/style&gt;

    &lt;style name="normalText"&gt;
        &lt;item name="android:textStyle"&gt;normal&lt;/item&gt;
        &lt;item name="android:textColor"&gt;#C0C0C0&lt;/item&gt;
    &lt;/style&gt;

&lt;/resources&gt;
******************************
Normalized:
******************************
Original:
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;

    &lt;style name="boldText"&gt;
        &lt;item name="android:textStyle"&gt;bold|italic&lt;/item&gt;
        &lt;item name="android:textColor"&gt;#FFFFFF&lt;/item&gt;
    &lt;/style&gt;

    &lt;style name="normalText"&gt;
        &lt;item name="android:textStyle"&gt;normal&lt;/item&gt;
        &lt;item name="android:textColor"&gt;#C0C0C0&lt;/item&gt;
    &lt;/style&gt;

&lt;/resources&gt;
******************************
Normalized:
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;

    &lt;style name="boldText"&gt;
        &lt;item name="android:textStyle"&gt;bold|italic&lt;/item&gt;
        &lt;item name="android:textColor"&gt;#FFFFFF&lt;/item&gt;
    &lt;/style&gt;

    &lt;style name="normalText"&gt;
        &lt;item name="android:textStyle"&gt;normal&lt;/item&gt;
        &lt;item name="android:textColor"&gt;#C0C0C0&lt;/item&gt;
    &lt;/style&gt;

&lt;/resources&gt;
******************************
Original:
LocalDate date = ...;
ZoneId zoneId = ZoneId.systemDefault(); // or: ZoneId.of("Europe/Oslo");
long epoch = date.atStartOfDay(zoneId).toEpochSecond();
******************************
Normalized:
******************************
Original:
LocalDate date = ...;
ZoneId zoneId = ZoneId.systemDefault(); // or: ZoneId.of("Europe/Oslo");
long epoch = date.atStartOfDay(zoneId).toEpochSecond();
******************************
Normalized:
LocalDate date = ...;
ZoneId zoneId = ZoneId.systemDefault(); // or: ZoneId.of("Europe/Oslo");
long epoch = date.atStartOfDay(zoneId).toEpochSecond();
******************************
Original:
keytool -import -file &lt;the cert file&gt; -alias &lt;some meaningful name&gt; -keystore &lt;path to cacerts file&gt;
******************************
Normalized:
******************************
Original:
keytool -import -file &lt;the cert file&gt; -alias &lt;some meaningful name&gt; -keystore &lt;path to cacerts file&gt;
******************************
Normalized:
keytool -import -file &lt;the cert file&gt; -alias &lt;some meaningful name&gt; -keystore &lt;path to cacerts file&gt;
******************************
Original:
public class UserEventDeserializer extends StdDeserializer&lt;User&gt; implements ResolvableDeserializer
{
  private static final long serialVersionUID = 7923585097068641765L;

  private final JsonDeserializer&lt;?&gt; defaultDeserializer;

  public UserEventDeserializer(JsonDeserializer&lt;?&gt; defaultDeserializer)
  {
    super(User.class);
    this.defaultDeserializer = defaultDeserializer;
  }

  @Override public User deserialize(JsonParser jp, DeserializationContext ctxt)
      throws IOException, JsonProcessingException
  {
    User deserializedUser = (User) defaultDeserializer.deserialize(jp, ctxt);

    // Special logic

    return deserializedUser;
  }

  // for some reason you have to implement ResolvableDeserializer when modifying BeanDeserializer
  // otherwise deserializing throws JsonMappingException??
  @Override public void resolve(DeserializationContext ctxt) throws JsonMappingException
  {
    ((ResolvableDeserializer) defaultDeserializer).resolve(ctxt);
  }


  public static void main(String[] args) throws JsonParseException, JsonMappingException, IOException
  {
    SimpleModule module = new SimpleModule();
    module.setDeserializerModifier(new BeanDeserializerModifier()
    {
      @Override public JsonDeserializer&lt;?&gt; modifyDeserializer(DeserializationConfig config, BeanDescription beanDesc, JsonDeserializer&lt;?&gt; deserializer)
      {
        if (beanDesc.getBeanClass() == User.class)
          return new UserEventDeserializer(deserializer);
        return deserializer;
      }
    });


    ObjectMapper mapper = new ObjectMapper();
    mapper.registerModule(module);
    User user = mapper.readValue(new File("test.json"), User.class);
  }
}
******************************
Normalized:
******************************
Original:
public class UserEventDeserializer extends StdDeserializer&lt;User&gt; implements ResolvableDeserializer
{
  private static final long serialVersionUID = 7923585097068641765L;

  private final JsonDeserializer&lt;?&gt; defaultDeserializer;

  public UserEventDeserializer(JsonDeserializer&lt;?&gt; defaultDeserializer)
  {
    super(User.class);
    this.defaultDeserializer = defaultDeserializer;
  }

  @Override public User deserialize(JsonParser jp, DeserializationContext ctxt)
      throws IOException, JsonProcessingException
  {
    User deserializedUser = (User) defaultDeserializer.deserialize(jp, ctxt);

    // Special logic

    return deserializedUser;
  }

  // for some reason you have to implement ResolvableDeserializer when modifying BeanDeserializer
  // otherwise deserializing throws JsonMappingException??
  @Override public void resolve(DeserializationContext ctxt) throws JsonMappingException
  {
    ((ResolvableDeserializer) defaultDeserializer).resolve(ctxt);
  }


  public static void main(String[] args) throws JsonParseException, JsonMappingException, IOException
  {
    SimpleModule module = new SimpleModule();
    module.setDeserializerModifier(new BeanDeserializerModifier()
    {
      @Override public JsonDeserializer&lt;?&gt; modifyDeserializer(DeserializationConfig config, BeanDescription beanDesc, JsonDeserializer&lt;?&gt; deserializer)
      {
        if (beanDesc.getBeanClass() == User.class)
          return new UserEventDeserializer(deserializer);
        return deserializer;
      }
    });


    ObjectMapper mapper = new ObjectMapper();
    mapper.registerModule(module);
    User user = mapper.readValue(new File("test.json"), User.class);
  }
}
******************************
Normalized:
public class UserEventDeserializer extends StdDeserializer&lt;User&gt; implements ResolvableDeserializer
{
  private static final long serialVersionUID = 7923585097068641765L;

  private final JsonDeserializer&lt;?&gt; defaultDeserializer;

  public UserEventDeserializer(JsonDeserializer&lt;?&gt; defaultDeserializer)
  {
    super(User.class);
    this.defaultDeserializer = defaultDeserializer;
  }

  @Override public User deserialize(JsonParser jp, DeserializationContext ctxt)
      throws IOException, JsonProcessingException
  {
    User deserializedUser = (User) defaultDeserializer.deserialize(jp, ctxt);

    // Special logic

    return deserializedUser;
  }

  // for some reason you have to implement ResolvableDeserializer when modifying BeanDeserializer
  // otherwise deserializing throws JsonMappingException??
  @Override public void resolve(DeserializationContext ctxt) throws JsonMappingException
  {
    ((ResolvableDeserializer) defaultDeserializer).resolve(ctxt);
  }


  public static void main(String[] args) throws JsonParseException, JsonMappingException, IOException
  {
    SimpleModule module = new SimpleModule();
    module.setDeserializerModifier(new BeanDeserializerModifier()
    {
      @Override public JsonDeserializer&lt;?&gt; modifyDeserializer(DeserializationConfig config, BeanDescription beanDesc, JsonDeserializer&lt;?&gt; deserializer)
      {
        if (beanDesc.getBeanClass() == User.class)
          return new UserEventDeserializer(deserializer);
        return deserializer;
      }
    });


    ObjectMapper mapper = new ObjectMapper();
    mapper.registerModule(module);
    User user = mapper.readValue(new File("test.json"), User.class);
  }
}
******************************
Original:
List&lt;String&gt; myList = new ArrayList&lt;String&gt;(Arrays.asList(s.split(",")));
******************************
Normalized:
******************************
Original:
List&lt;String&gt; myList = new ArrayList&lt;String&gt;(Arrays.asList(s.split(",")));
******************************
Normalized:
List&lt;String&gt; myList = new ArrayList&lt;String&gt;(Arrays.asList(s.split(",")));
******************************
Original:
Benchmark           Mode  Cnt         Score        Error  Units
MyBenchmark.test1  thrpt   20  10463220.493 ± 288805.068  ops/s
MyBenchmark.test2  thrpt   20  14730158.709 ± 530444.444  ops/s
MyBenchmark.test3  thrpt   20  16079551.751 ±  56884.357  ops/s
MyBenchmark.test4  thrpt   20   9762578.446 ± 584316.582  ops/s
MyBenchmark.test5  thrpt   20   6093216.066 ± 180062.872  ops/s
MyBenchmark.test6  thrpt   20   2104102.578 ±  18705.805  ops/s
******************************
Normalized:
******************************
Original:
Benchmark           Mode  Cnt         Score        Error  Units
MyBenchmark.test1  thrpt   20  10463220.493 ± 288805.068  ops/s
MyBenchmark.test2  thrpt   20  14730158.709 ± 530444.444  ops/s
MyBenchmark.test3  thrpt   20  16079551.751 ±  56884.357  ops/s
MyBenchmark.test4  thrpt   20   9762578.446 ± 584316.582  ops/s
MyBenchmark.test5  thrpt   20   6093216.066 ± 180062.872  ops/s
MyBenchmark.test6  thrpt   20   2104102.578 ±  18705.805  ops/s
******************************
Normalized:
Benchmark           Mode  Cnt         Score        Error  Units
MyBenchmark.test1  thrpt   20  10463220.493 ± 288805.068  ops/s
MyBenchmark.test2  thrpt   20  14730158.709 ± 530444.444  ops/s
MyBenchmark.test3  thrpt   20  16079551.751 ±  56884.357  ops/s
MyBenchmark.test4  thrpt   20   9762578.446 ± 584316.582  ops/s
MyBenchmark.test5  thrpt   20   6093216.066 ± 180062.872  ops/s
MyBenchmark.test6  thrpt   20   2104102.578 ±  18705.805  ops/s
******************************
Original:
qsort []     = []
qsort (x:xs) = qsort lesser ++ [x] ++ qsort greater
    where lesser  = (filter (&lt; x) xs)
          greater = (filter (&gt;= x) xs)
******************************
Normalized:
******************************
Original:
qsort []     = []
qsort (x:xs) = qsort lesser ++ [x] ++ qsort greater
    where lesser  = (filter (&lt; x) xs)
          greater = (filter (&gt;= x) xs)
******************************
Normalized:
qsort []     = []
qsort (x:xs) = qsort lesser ++ [x] ++ qsort greater
    where lesser  = (filter (&lt; x) xs)
          greater = (filter (&gt;= x) xs)
******************************
Original:
test {
    systemProperty "cassandra.ip", project.getProperty("cassandra.ip")
}
******************************
Normalized:
******************************
Original:
test {
    systemProperty "cassandra.ip", project.getProperty("cassandra.ip")
}
******************************
Normalized:
test {
    systemProperty "cassandra.ip", project.getProperty("cassandra.ip")
}
******************************
Original:
super();
******************************
Normalized:
******************************
Original:
super();
******************************
Normalized:
super();
******************************
Original:
Current thread (0x0805ac88):  JavaThread "main" [_thread_in_native, id=21139]
                    |             |         |            |          +-- ID
                    |             |         |            +------------- state
                    |             |         +-------------------------- name
                    |             +------------------------------------ type
                    +-------------------------------------------------- pointer
******************************
Normalized:
******************************
Original:
Current thread (0x0805ac88):  JavaThread "main" [_thread_in_native, id=21139]
                    |             |         |            |          +-- ID
                    |             |         |            +------------- state
                    |             |         +-------------------------- name
                    |             +------------------------------------ type
                    +-------------------------------------------------- pointer
******************************
Normalized:
Current thread (0x0805ac88):  JavaThread "main" [_thread_in_native, id=21139]
                    |             |         |            |          +-- ID
                    |             |         |            +------------- state
                    |             |         +-------------------------- name
                    |             +------------------------------------ type
                    +-------------------------------------------------- pointer
******************************
Original:
// extend LinkedBlockingQueue to force offer() to return false conditionally
BlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;Runnable&gt;() {
    private static final long serialVersionUID = -6903933921423432194L;
    @Override
    public boolean offer(Runnable e) {
        // Offer it to the queue if there is 0 items already queued, else
        // return false so the TPE will add another thread. If we return false
        // and max threads have been reached then the RejectedExecutionHandler
        // will be called which will do the put into the queue.
        if (size() == 0) {
            return super.offer(e);
        } else {
            return false;
        }
    }
};
ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1 /*core*/, 50 /*max*/,
        60 /*secs*/, TimeUnit.SECONDS, queue);
threadPool.setRejectedExecutionHandler(new RejectedExecutionHandler() {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        try {
            // This does the actual put into the queue. Once the max threads
            //  have been reached, the tasks will then queue up.
            executor.getQueue().put(r);
            // we do this after the put() to stop race conditions
            if (executor.isShutdown()) {
                throw new RejectedExecutionException(
                    "Task " + r + " rejected from " + e);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return;
        }
    }
});
******************************
Normalized:
******************************
Original:
// extend LinkedBlockingQueue to force offer() to return false conditionally
BlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;Runnable&gt;() {
    private static final long serialVersionUID = -6903933921423432194L;
    @Override
    public boolean offer(Runnable e) {
        // Offer it to the queue if there is 0 items already queued, else
        // return false so the TPE will add another thread. If we return false
        // and max threads have been reached then the RejectedExecutionHandler
        // will be called which will do the put into the queue.
        if (size() == 0) {
            return super.offer(e);
        } else {
            return false;
        }
    }
};
ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1 /*core*/, 50 /*max*/,
        60 /*secs*/, TimeUnit.SECONDS, queue);
threadPool.setRejectedExecutionHandler(new RejectedExecutionHandler() {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        try {
            // This does the actual put into the queue. Once the max threads
            //  have been reached, the tasks will then queue up.
            executor.getQueue().put(r);
            // we do this after the put() to stop race conditions
            if (executor.isShutdown()) {
                throw new RejectedExecutionException(
                    "Task " + r + " rejected from " + e);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return;
        }
    }
});
******************************
Normalized:
// extend LinkedBlockingQueue to force offer() to return false conditionally
BlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;Runnable&gt;() {
    private static final long serialVersionUID = -6903933921423432194L;
    @Override
    public boolean offer(Runnable e) {
        // Offer it to the queue if there is 0 items already queued, else
        // return false so the TPE will add another thread. If we return false
        // and max threads have been reached then the RejectedExecutionHandler
        // will be called which will do the put into the queue.
        if (size() == 0) {
            return super.offer(e);
        } else {
            return false;
        }
    }
};
ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1 /*core*/, 50 /*max*/,
        60 /*secs*/, TimeUnit.SECONDS, queue);
threadPool.setRejectedExecutionHandler(new RejectedExecutionHandler() {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        try {
            // This does the actual put into the queue. Once the max threads
            //  have been reached, the tasks will then queue up.
            executor.getQueue().put(r);
            // we do this after the put() to stop race conditions
            if (executor.isShutdown()) {
                throw new RejectedExecutionException(
                    "Task " + r + " rejected from " + e);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return;
        }
    }
});
******************************
Original:
&lt;properties&gt;
    &lt;!-- ... --&gt;
    &lt;maven-jar-plugin.version&gt;3.1.1&lt;/maven-jar-plugin.version&gt;
&lt;/properties&gt;
******************************
Normalized:
******************************
Original:
&lt;properties&gt;
    &lt;!-- ... --&gt;
    &lt;maven-jar-plugin.version&gt;3.1.1&lt;/maven-jar-plugin.version&gt;
&lt;/properties&gt;
******************************
Normalized:
&lt;properties&gt;
    &lt;!-- ... --&gt;
    &lt;maven-jar-plugin.version&gt;3.1.1&lt;/maven-jar-plugin.version&gt;
&lt;/properties&gt;
******************************
Original:
&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.7&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;add-source&lt;/id&gt;
            &lt;phase&gt;generate-sources&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;add-source&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;sources&gt;
                &lt;source&gt;some directory&lt;/source&gt;
                ...
              &lt;/sources&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
******************************
Normalized:
******************************
Original:
&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.7&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;add-source&lt;/id&gt;
            &lt;phase&gt;generate-sources&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;add-source&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;sources&gt;
                &lt;source&gt;some directory&lt;/source&gt;
                ...
              &lt;/sources&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
******************************
Normalized:
&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.7&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;add-source&lt;/id&gt;
            &lt;phase&gt;generate-sources&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;add-source&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;sources&gt;
                &lt;source&gt;some directory&lt;/source&gt;
                ...
              &lt;/sources&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
******************************
Original:
Months.values()[index]
******************************
Normalized:
******************************
Original:
Months.values()[index]
******************************
Normalized:
Months.values()[index]
******************************
Original:
Object
     /      \
    /        \
String     Integer
******************************
Normalized:
******************************
Original:
Object
     /      \
    /        \
String     Integer
******************************
Normalized:
Object
     /      \
    /        \
String     Integer
******************************
Original:
public void restartApplication()
{
  final String javaBin = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
  final File currentJar = new File(MyClassInTheJar.class.getProtectionDomain().getCodeSource().getLocation().toURI());

  /* is it a jar file? */
  if(!currentJar.getName().endsWith(".jar"))
    return;

  /* Build command: java -jar application.jar */
  final ArrayList&lt;String&gt; command = new ArrayList&lt;String&gt;();
  command.add(javaBin);
  command.add("-jar");
  command.add(currentJar.getPath());

  final ProcessBuilder builder = new ProcessBuilder(command);
  builder.start();
  System.exit(0);
}
******************************
Normalized:
******************************
Original:
public void restartApplication()
{
  final String javaBin = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
  final File currentJar = new File(MyClassInTheJar.class.getProtectionDomain().getCodeSource().getLocation().toURI());

  /* is it a jar file? */
  if(!currentJar.getName().endsWith(".jar"))
    return;

  /* Build command: java -jar application.jar */
  final ArrayList&lt;String&gt; command = new ArrayList&lt;String&gt;();
  command.add(javaBin);
  command.add("-jar");
  command.add(currentJar.getPath());

  final ProcessBuilder builder = new ProcessBuilder(command);
  builder.start();
  System.exit(0);
}
******************************
Normalized:
public void restartApplication()
{
  final String javaBin = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
  final File currentJar = new File(MyClassInTheJar.class.getProtectionDomain().getCodeSource().getLocation().toURI());

  /* is it a jar file? */
  if(!currentJar.getName().endsWith(".jar"))
    return;

  /* Build command: java -jar application.jar */
  final ArrayList&lt;String&gt; command = new ArrayList&lt;String&gt;();
  command.add(javaBin);
  command.add("-jar");
  command.add(currentJar.getPath());

  final ProcessBuilder builder = new ProcessBuilder(command);
  builder.start();
  System.exit(0);
}
******************************
Original:
&lt;A&gt; List&lt;A&gt; flatten(List&lt;List&lt;A&gt;&gt; nestedLists);
******************************
Normalized:
******************************
Original:
&lt;A&gt; List&lt;A&gt; flatten(List&lt;List&lt;A&gt;&gt; nestedLists);
******************************
Normalized:
&lt;A&gt; List&lt;A&gt; flatten(List&lt;List&lt;A&gt;&gt; nestedLists);
******************************
Original:
import java.nio.FloatBuffer;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

@Platform(include = "Dot.h", compiler = "fastfpu")
public class Dot {
    static { Loader.load(); }

    static float[] a = new float[50], b = new float[50];
    static float dot() {
        float sum = 0;
        for (int i = 0; i &lt; 50; i++) {
            sum += a[i]*b[i];
        }
        return sum;
    }
    static native @MemberGetter FloatPointer ac();
    static native @MemberGetter FloatPointer bc();
    static native @NoException float dotc();

    public static void main(String[] args) {
        FloatBuffer ab = ac().capacity(50).asBuffer();
        FloatBuffer bb = bc().capacity(50).asBuffer();

        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t1 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
        }
        long t2 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t3 = System.nanoTime();
        System.out.println("dot(): " + (t2 - t1)/10000000 + " ns");
        System.out.println("dotc(): "  + (t3 - t2)/10000000 + " ns");
    }
}
******************************
Normalized:
******************************
Original:
import java.nio.FloatBuffer;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

@Platform(include = "Dot.h", compiler = "fastfpu")
public class Dot {
    static { Loader.load(); }

    static float[] a = new float[50], b = new float[50];
    static float dot() {
        float sum = 0;
        for (int i = 0; i &lt; 50; i++) {
            sum += a[i]*b[i];
        }
        return sum;
    }
    static native @MemberGetter FloatPointer ac();
    static native @MemberGetter FloatPointer bc();
    static native @NoException float dotc();

    public static void main(String[] args) {
        FloatBuffer ab = ac().capacity(50).asBuffer();
        FloatBuffer bb = bc().capacity(50).asBuffer();

        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t1 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
        }
        long t2 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t3 = System.nanoTime();
        System.out.println("dot(): " + (t2 - t1)/10000000 + " ns");
        System.out.println("dotc(): "  + (t3 - t2)/10000000 + " ns");
    }
}
******************************
Normalized:
import java.nio.FloatBuffer;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

@Platform(include = "Dot.h", compiler = "fastfpu")
public class Dot {
    static { Loader.load(); }

    static float[] a = new float[50], b = new float[50];
    static float dot() {
        float sum = 0;
        for (int i = 0; i &lt; 50; i++) {
            sum += a[i]*b[i];
        }
        return sum;
    }
    static native @MemberGetter FloatPointer ac();
    static native @MemberGetter FloatPointer bc();
    static native @NoException float dotc();

    public static void main(String[] args) {
        FloatBuffer ab = ac().capacity(50).asBuffer();
        FloatBuffer bb = bc().capacity(50).asBuffer();

        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t1 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
        }
        long t2 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t3 = System.nanoTime();
        System.out.println("dot(): " + (t2 - t1)/10000000 + " ns");
        System.out.println("dotc(): "  + (t3 - t2)/10000000 + " ns");
    }
}
******************************
Original:
&lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;!-- config the location(s) of the properties file(s) here --&gt;
    &lt;property name="nullValue" value="@null" /&gt;
&lt;/bean&gt;
******************************
Normalized:
******************************
Original:
&lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;!-- config the location(s) of the properties file(s) here --&gt;
    &lt;property name="nullValue" value="@null" /&gt;
&lt;/bean&gt;
******************************
Normalized:
&lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;!-- config the location(s) of the properties file(s) here --&gt;
    &lt;property name="nullValue" value="@null" /&gt;
&lt;/bean&gt;
******************************
Original:
File[] files = XMLDirectory.listFiles(filter_xml_files);
Arrays.sort(files);
for(File _xml_file : files) {
    ...
}
******************************
Normalized:
******************************
Original:
File[] files = XMLDirectory.listFiles(filter_xml_files);
Arrays.sort(files);
for(File _xml_file : files) {
    ...
}
******************************
Normalized:
File[] files = XMLDirectory.listFiles(filter_xml_files);
Arrays.sort(files);
for(File _xml_file : files) {
    ...
}
******************************
Original:
configurations {
  runtime.exclude group: "org.slf4j", module: "slf4j-log4j12"
}
******************************
Normalized:
******************************
Original:
configurations {
  runtime.exclude group: "org.slf4j", module: "slf4j-log4j12"
}
******************************
Normalized:
configurations {
  runtime.exclude group: "org.slf4j", module: "slf4j-log4j12"
}
******************************
Original:
ObjectMapper mapper = new ObjectMapper();
mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
// do various things, perhaps:
String someJsonString = mapper.writeValueAsString(someClassInstance);
SomeClass someClassInstance = mapper.readValue(someJsonString, SomeClass.class)
******************************
Normalized:
******************************
Original:
ObjectMapper mapper = new ObjectMapper();
mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
// do various things, perhaps:
String someJsonString = mapper.writeValueAsString(someClassInstance);
SomeClass someClassInstance = mapper.readValue(someJsonString, SomeClass.class)
******************************
Normalized:
ObjectMapper mapper = new ObjectMapper();
mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
// do various things, perhaps:
String someJsonString = mapper.writeValueAsString(someClassInstance);
SomeClass someClassInstance = mapper.readValue(someJsonString, SomeClass.class)
******************************
Original:
bootRun {
   jvmArgs = "-Dhttp.proxyHost=xxxxxx", "-Dhttp.proxyPort=xxxxxx"
}
******************************
Normalized:
******************************
Original:
bootRun {
   jvmArgs = "-Dhttp.proxyHost=xxxxxx", "-Dhttp.proxyPort=xxxxxx"
}
******************************
Normalized:
bootRun {
   jvmArgs = "-Dhttp.proxyHost=xxxxxx", "-Dhttp.proxyPort=xxxxxx"
}
******************************
Original:
apply plugin: "java"

sourceSets {
    // Note that just declaring this sourceset creates two configurations.
    intTest {
        java {
            compileClasspath += main.output
            runtimeClasspath += main.output
        }
    }
}

configurations {
    intTestCompile.extendsFrom testCompile
    intTestRuntime.extendsFrom testRuntime
}

task intTest(type:Test){
    description = "Run integration tests (located in src/intTest/...)."
    testClassesDir = project.sourceSets.intTest.output.classesDir
    classpath = project.sourceSets.intTest.runtimeClasspath
}
******************************
Normalized:
******************************
Original:
apply plugin: "java"

sourceSets {
    // Note that just declaring this sourceset creates two configurations.
    intTest {
        java {
            compileClasspath += main.output
            runtimeClasspath += main.output
        }
    }
}

configurations {
    intTestCompile.extendsFrom testCompile
    intTestRuntime.extendsFrom testRuntime
}

task intTest(type:Test){
    description = "Run integration tests (located in src/intTest/...)."
    testClassesDir = project.sourceSets.intTest.output.classesDir
    classpath = project.sourceSets.intTest.runtimeClasspath
}
******************************
Normalized:
apply plugin: "java"

sourceSets {
    // Note that just declaring this sourceset creates two configurations.
    intTest {
        java {
            compileClasspath += main.output
            runtimeClasspath += main.output
        }
    }
}

configurations {
    intTestCompile.extendsFrom testCompile
    intTestRuntime.extendsFrom testRuntime
}

task intTest(type:Test){
    description = "Run integration tests (located in src/intTest/...)."
    testClassesDir = project.sourceSets.intTest.output.classesDir
    classpath = project.sourceSets.intTest.runtimeClasspath
}
******************************
Original:
Runnable r = new Runnable() {
   public void run() { ... }
};
******************************
Normalized:
******************************
Original:
Runnable r = new Runnable() {
   public void run() { ... }
};
******************************
Normalized:
Runnable r = new Runnable() {
   public void run() { ... }
};
******************************
Original:
String getMonthForInt(int num) {
        String month = "wrong";
        DateFormatSymbols dfs = new DateFormatSymbols();
        String[] months = dfs.getMonths();
        if (num &gt;= 0 &amp;&amp; num &lt;= 11 ) {
            month = months[num];
        }
        return month;
    }
******************************
Normalized:
******************************
Original:
String getMonthForInt(int num) {
        String month = "wrong";
        DateFormatSymbols dfs = new DateFormatSymbols();
        String[] months = dfs.getMonths();
        if (num &gt;= 0 &amp;&amp; num &lt;= 11 ) {
            month = months[num];
        }
        return month;
    }
******************************
Normalized:
String getMonthForInt(int num) {
        String month = "wrong";
        DateFormatSymbols dfs = new DateFormatSymbols();
        String[] months = dfs.getMonths();
        if (num &gt;= 0 &amp;&amp; num &lt;= 11 ) {
            month = months[num];
        }
        return month;
    }
******************************
Original:
@Entity
class Employee {
     :
    @OneToOne(cascade=CascadeType.REMOVE)
    private Address address;
     :
}
******************************
Normalized:
******************************
Original:
@Entity
class Employee {
     :
    @OneToOne(cascade=CascadeType.REMOVE)
    private Address address;
     :
}
******************************
Normalized:
@Entity
class Employee {
     :
    @OneToOne(cascade=CascadeType.REMOVE)
    private Address address;
     :
}
******************************
Original:
spring.jackson.serialization-inclusion=non_null
******************************
Normalized:
******************************
Original:
spring.jackson.serialization-inclusion=non_null
******************************
Normalized:
spring.jackson.serialization-inclusion=non_null
******************************
Original:
List&lt;String&gt; strings = list.stream()
   .map(object -&gt; Objects.toString(object, null))
   .collect(Collectors.toList());
******************************
Normalized:
******************************
Original:
List&lt;String&gt; strings = list.stream()
   .map(object -&gt; Objects.toString(object, null))
   .collect(Collectors.toList());
******************************
Normalized:
List&lt;String&gt; strings = list.stream()
   .map(object -&gt; Objects.toString(object, null))
   .collect(Collectors.toList());
******************************
Original:
&lt;build&gt;
  &lt;plugins&gt; 
    &lt;plugin&gt;
      &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;id&gt;attach-sources&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar-no-fork&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;attach-javadocs&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;!-- explicitly define maven-deploy-plugin after other to force exec order --&gt;
      &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;deploy&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;deploy&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
  &lt;/plugins&gt; 
&lt;/build&gt;
******************************
Normalized:
******************************
Original:
&lt;build&gt;
  &lt;plugins&gt; 
    &lt;plugin&gt;
      &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;id&gt;attach-sources&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar-no-fork&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;attach-javadocs&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;!-- explicitly define maven-deploy-plugin after other to force exec order --&gt;
      &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;deploy&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;deploy&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
  &lt;/plugins&gt; 
&lt;/build&gt;
******************************
Normalized:
&lt;build&gt;
  &lt;plugins&gt; 
    &lt;plugin&gt;
      &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;id&gt;attach-sources&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar-no-fork&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;attach-javadocs&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;!-- explicitly define maven-deploy-plugin after other to force exec order --&gt;
      &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;deploy&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;deploy&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
  &lt;/plugins&gt; 
&lt;/build&gt;
******************************
Original:
dependencies {
    ...
    testCompile "junit:junit:4.11"  // Or whatever version
}
******************************
Normalized:
******************************
Original:
dependencies {
    ...
    testCompile "junit:junit:4.11"  // Or whatever version
}
******************************
Normalized:
dependencies {
    ...
    testCompile "junit:junit:4.11"  // Or whatever version
}
******************************
Original:
public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(
    Collection&lt;? extends T&gt; coll
)
******************************
Normalized:
******************************
Original:
public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(
    Collection&lt;? extends T&gt; coll
)
******************************
Normalized:
public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(
    Collection&lt;? extends T&gt; coll
)
******************************
Original:
public static boolean isBetween(int x, int lower, int upper) {
  return lower &lt;= x &amp;&amp; x &lt;= upper;
}

if (isBetween(num, 1, 5)) {
  System.out.println("testing case 1 to 5");
} else if (isBetween(num, 6, 10)) {
  System.out.println("testing case 6 to 10");
}
******************************
Normalized:
******************************
Original:
public static boolean isBetween(int x, int lower, int upper) {
  return lower &lt;= x &amp;&amp; x &lt;= upper;
}

if (isBetween(num, 1, 5)) {
  System.out.println("testing case 1 to 5");
} else if (isBetween(num, 6, 10)) {
  System.out.println("testing case 6 to 10");
}
******************************
Normalized:
public static boolean isBetween(int x, int lower, int upper) {
  return lower &lt;= x &amp;&amp; x &lt;= upper;
}

if (isBetween(num, 1, 5)) {
  System.out.println("testing case 1 to 5");
} else if (isBetween(num, 6, 10)) {
  System.out.println("testing case 6 to 10");
}
******************************
Original:
ObjectMapper objectMapper = new ObjectMapper();
TypeFactory typeFactory = objectMapper.getTypeFactory();
List&lt;SomeClass&gt; someClassList = objectMapper.readValue(jsonString, typeFactory.constructCollectionType(List.class, SomeClass.class));
******************************
Normalized:
******************************
Original:
ObjectMapper objectMapper = new ObjectMapper();
TypeFactory typeFactory = objectMapper.getTypeFactory();
List&lt;SomeClass&gt; someClassList = objectMapper.readValue(jsonString, typeFactory.constructCollectionType(List.class, SomeClass.class));
******************************
Normalized:
ObjectMapper objectMapper = new ObjectMapper();
TypeFactory typeFactory = objectMapper.getTypeFactory();
List&lt;SomeClass&gt; someClassList = objectMapper.readValue(jsonString, typeFactory.constructCollectionType(List.class, SomeClass.class));
******************************
Original:
packagingOptions {
   pickFirst  'META-INF/license.txt'
}
******************************
Normalized:
******************************
Original:
packagingOptions {
   pickFirst  'META-INF/license.txt'
}
******************************
Normalized:
packagingOptions {
   pickFirst  'META-INF/license.txt'
}
******************************
Original:
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
******************************
Normalized:
******************************
Original:
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
******************************
Normalized:
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
******************************
Original:
object ScannerTest {
  def main(args: Array[String]) {
    var ok = true
    while (ok) {
      val ln = readLine()
      ok = ln != null
      if (ok) println(ln)
    }
  }
}
******************************
Normalized:
******************************
Original:
object ScannerTest {
  def main(args: Array[String]) {
    var ok = true
    while (ok) {
      val ln = readLine()
      ok = ln != null
      if (ok) println(ln)
    }
  }
}
******************************
Normalized:
object ScannerTest {
  def main(args: Array[String]) {
    var ok = true
    while (ok) {
      val ln = readLine()
      ok = ln != null
      if (ok) println(ln)
    }
  }
}
******************************
Original:
&lt;global-method-security&gt;
  &lt;expression-handler ref="myMethodSecurityExpressionHandler"/&gt;
&lt;/global-method-security&gt;
******************************
Normalized:
******************************
Original:
&lt;global-method-security&gt;
  &lt;expression-handler ref="myMethodSecurityExpressionHandler"/&gt;
&lt;/global-method-security&gt;
******************************
Normalized:
&lt;global-method-security&gt;
  &lt;expression-handler ref="myMethodSecurityExpressionHandler"/&gt;
&lt;/global-method-security&gt;
******************************
Original:
int r = x % n;
if (r &gt; 0 &amp;&amp; x &lt; 0)
{
    r -= n;
}
******************************
Normalized:
******************************
Original:
int r = x % n;
if (r &gt; 0 &amp;&amp; x &lt; 0)
{
    r -= n;
}
******************************
Normalized:
int r = x % n;
if (r &gt; 0 &amp;&amp; x &lt; 0)
{
    r -= n;
}
******************************
Original:
mvn eclipse:eclipse -DdownloadSources=true
******************************
Normalized:
******************************
Original:
mvn eclipse:eclipse -DdownloadSources=true
******************************
Normalized:
mvn eclipse:eclipse -DdownloadSources=true
******************************
Original:
@POST
public Response postSomething(@QueryParam("name") String name, @Context UriInfo uriInfo, String content) {
     MultivaluedMap&lt;String, String&gt; queryParams = uriInfo.getQueryParameters(); 
     String nameParam = queryParams.getFirst("name");
}
******************************
Normalized:
******************************
Original:
@POST
public Response postSomething(@QueryParam("name") String name, @Context UriInfo uriInfo, String content) {
     MultivaluedMap&lt;String, String&gt; queryParams = uriInfo.getQueryParameters(); 
     String nameParam = queryParams.getFirst("name");
}
******************************
Normalized:
@POST
public Response postSomething(@QueryParam("name") String name, @Context UriInfo uriInfo, String content) {
     MultivaluedMap&lt;String, String&gt; queryParams = uriInfo.getQueryParameters(); 
     String nameParam = queryParams.getFirst("name");
}
******************************
Original:
interface CustomUserRepository {

  List&lt;User&gt; yourCustomMethod();
}
******************************
Normalized:
******************************
Original:
interface CustomUserRepository {

  List&lt;User&gt; yourCustomMethod();
}
******************************
Normalized:
interface CustomUserRepository {

  List&lt;User&gt; yourCustomMethod();
}
******************************
Original:
1372060916 = Mon, 24 Jun 2013 08:01:56 GMT
******************************
Normalized:
******************************
Original:
1372060916 = Mon, 24 Jun 2013 08:01:56 GMT
******************************
Normalized:
1372060916 = Mon, 24 Jun 2013 08:01:56 GMT
******************************
Original:
0x00007fdd859dbb80: test   %eax,0x5f7847a(%rip)  /* fun JVM hack */
0x00007fdd859dbb86: dec    %r11                  /* i-- */
0x00007fdd859dbb89: mov    %r11,0x258(%r10)      /* store i to memory */
0x00007fdd859dbb90: test   %r11,%r11             /* unnecessary test */
0x00007fdd859dbb93: jge    0x00007fdd859dbb80    /* go back to the loop top */
******************************
Normalized:
******************************
Original:
0x00007fdd859dbb80: test   %eax,0x5f7847a(%rip)  /* fun JVM hack */
0x00007fdd859dbb86: dec    %r11                  /* i-- */
0x00007fdd859dbb89: mov    %r11,0x258(%r10)      /* store i to memory */
0x00007fdd859dbb90: test   %r11,%r11             /* unnecessary test */
0x00007fdd859dbb93: jge    0x00007fdd859dbb80    /* go back to the loop top */
******************************
Normalized:
0x00007fdd859dbb80: test   %eax,0x5f7847a(%rip)  /* fun JVM hack */
0x00007fdd859dbb86: dec    %r11                  /* i-- */
0x00007fdd859dbb89: mov    %r11,0x258(%r10)      /* store i to memory */
0x00007fdd859dbb90: test   %r11,%r11             /* unnecessary test */
0x00007fdd859dbb93: jge    0x00007fdd859dbb80    /* go back to the loop top */
******************************
Original:
Class&lt;?&gt; driverClass = Class.forName("oracle.jdbc.driver.OracleDriver");
// and
Class&lt;?&gt; stringClass = Class.forName("java.lang.String");
******************************
Normalized:
******************************
Original:
Class&lt;?&gt; driverClass = Class.forName("oracle.jdbc.driver.OracleDriver");
// and
Class&lt;?&gt; stringClass = Class.forName("java.lang.String");
******************************
Normalized:
Class&lt;?&gt; driverClass = Class.forName("oracle.jdbc.driver.OracleDriver");
// and
Class&lt;?&gt; stringClass = Class.forName("java.lang.String");
******************************
Original:
byte b1 = (byte) 129;
String s1 = String.format("%8s", Integer.toBinaryString(b1 &amp; 0xFF)).replace(' ', '0');
System.out.println(s1); // 10000001

byte b2 = (byte) 2;
String s2 = String.format("%8s", Integer.toBinaryString(b2 &amp; 0xFF)).replace(' ', '0');
System.out.println(s2); // 00000010
******************************
Normalized:
******************************
Original:
byte b1 = (byte) 129;
String s1 = String.format("%8s", Integer.toBinaryString(b1 &amp; 0xFF)).replace(' ', '0');
System.out.println(s1); // 10000001

byte b2 = (byte) 2;
String s2 = String.format("%8s", Integer.toBinaryString(b2 &amp; 0xFF)).replace(' ', '0');
System.out.println(s2); // 00000010
******************************
Normalized:
byte b1 = (byte) 129;
String s1 = String.format("%8s", Integer.toBinaryString(b1 &amp; 0xFF)).replace(' ', '0');
System.out.println(s1); // 10000001

byte b2 = (byte) 2;
String s2 = String.format("%8s", Integer.toBinaryString(b2 &amp; 0xFF)).replace(' ', '0');
System.out.println(s2); // 00000010
******************************
Original:
keytool -genkey -noprompt \
 -alias alias1 \
 -dname "CN=mqttserver.ibm.com, OU=ID, O=IBM, L=Hursley, S=Hants, C=GB" \
 -keystore keystore \
 -storepass password \
 -keypass password
******************************
Normalized:
******************************
Original:
keytool -genkey -noprompt \
 -alias alias1 \
 -dname "CN=mqttserver.ibm.com, OU=ID, O=IBM, L=Hursley, S=Hants, C=GB" \
 -keystore keystore \
 -storepass password \
 -keypass password
******************************
Normalized:
keytool -genkey -noprompt \
 -alias alias1 \
 -dname "CN=mqttserver.ibm.com, OU=ID, O=IBM, L=Hursley, S=Hants, C=GB" \
 -keystore keystore \
 -storepass password \
 -keypass password
******************************
Original:
&lt;c:if test="${not theBooleanVariable}"&gt;It's false!&lt;/c:if&gt;
******************************
Normalized:
******************************
Original:
&lt;c:if test="${not theBooleanVariable}"&gt;It's false!&lt;/c:if&gt;
******************************
Normalized:
&lt;c:if test="${not theBooleanVariable}"&gt;It's false!&lt;/c:if&gt;
******************************
Original:
while (condition) { 
  ... 
}
******************************
Normalized:
******************************
Original:
while (condition) { 
  ... 
}
******************************
Normalized:
while (condition) { 
  ... 
}
******************************
Original:
&lt;build&gt;
  &lt;finalName&gt;bird&lt;/finalName&gt;
 . . .
&lt;/build&gt;
******************************
Normalized:
******************************
Original:
&lt;build&gt;
  &lt;finalName&gt;bird&lt;/finalName&gt;
 . . .
&lt;/build&gt;
******************************
Normalized:
&lt;build&gt;
  &lt;finalName&gt;bird&lt;/finalName&gt;
 . . .
&lt;/build&gt;
******************************
Original:
git init
******************************
Normalized:
******************************
Original:
git init
******************************
Normalized:
git init
******************************
Original:
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST"
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST\\;" + 
                  "SET SCHEMA TEST";
String url = "jdbc:h2:mem;" + 
             "INIT=RUNSCRIPT FROM '~/create.sql'\\;" + 
                  "RUNSCRIPT FROM '~/populate.sql'";
******************************
Normalized:
******************************
Original:
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST"
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST\\;" + 
                  "SET SCHEMA TEST";
String url = "jdbc:h2:mem;" + 
             "INIT=RUNSCRIPT FROM '~/create.sql'\\;" + 
                  "RUNSCRIPT FROM '~/populate.sql'";
******************************
Normalized:
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST"
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST\\;" + 
                  "SET SCHEMA TEST";
String url = "jdbc:h2:mem;" + 
             "INIT=RUNSCRIPT FROM '~/create.sql'\\;" + 
                  "RUNSCRIPT FROM '~/populate.sql'";
******************************
Original:
public void testHardCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    for(int i = 0; i &lt; out.length; i++)
    {
        out[i] = bytes[i];
    }
}

public void testArrayCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    System.arraycopy(bytes, 0, out, 0, out.length);
}
******************************
Normalized:
******************************
Original:
public void testHardCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    for(int i = 0; i &lt; out.length; i++)
    {
        out[i] = bytes[i];
    }
}

public void testArrayCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    System.arraycopy(bytes, 0, out, 0, out.length);
}
******************************
Normalized:
public void testHardCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    for(int i = 0; i &lt; out.length; i++)
    {
        out[i] = bytes[i];
    }
}

public void testArrayCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    System.arraycopy(bytes, 0, out, 0, out.length);
}
******************************
Original:
String commaSeparatedNumbers = Arrays.stream(numbers)
    .mapToObj(i -&gt; ((Integer) i).toString()) //i is an int, not an Integer
    .collect(Collectors.joining(", "));
******************************
Normalized:
******************************
Original:
String commaSeparatedNumbers = Arrays.stream(numbers)
    .mapToObj(i -&gt; ((Integer) i).toString()) //i is an int, not an Integer
    .collect(Collectors.joining(", "));
******************************
Normalized:
String commaSeparatedNumbers = Arrays.stream(numbers)
    .mapToObj(i -&gt; ((Integer) i).toString()) //i is an int, not an Integer
    .collect(Collectors.joining(", "));
******************************
Original:
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;



class FloodIsolation {
public:
  FloodIsolation() :
      numberOfCells(20000),
      data(numberOfCells)
  {
  }
  ~FloodIsolation(){
  }

  void isUpdateNeeded() {
    for (int i = 0; i &lt; numberOfCells; ++i) {
       data[i].h = data[i].h + 1;
       data[i].floodedCells = !data[i].floodedCells;
       data[i].floodedCellsTimeInterval = !data[i].floodedCellsTimeInterval;
       data[i].qInflow = data[i].qInflow + 1;
       data[i].qStartTime = data[i].qStartTime + 1;
       data[i].qEndTime = data[i].qEndTime + 1;
       data[i].lowerFloorCells = data[i].lowerFloorCells + 1;
       data[i].cellLocationX = data[i].cellLocationX + 1;
       data[i].cellLocationY = data[i].cellLocationY + 1;
       data[i].cellLocationZ = data[i].cellLocationZ + 1;
       data[i].levelOfCell = data[i].levelOfCell + 1;
       data[i].valueOfCellIds = data[i].valueOfCellIds + 1;
       data[i].h0 = data[i].h0 + 1;
       data[i].vU = data[i].vU + 1;
       data[i].vV = data[i].vV + 1;
       data[i].vUh = data[i].vUh + 1;
       data[i].vVh = data[i].vVh + 1;
       data[i].vUh0 = data[i].vUh0 + 1;
       data[i].vVh0 = data[i].vVh0 + 1;
       data[i].ghh = data[i].ghh + 1;
       data[i].sfx = data[i].sfx + 1;
       data[i].sfy = data[i].sfy + 1;
       data[i].qIn = data[i].qIn + 1;


      for(int j = 0; j &lt; nEdges; ++j) {
        data[i].flagInterface[j] = !data[i].flagInterface[j];
        data[i].typeInterface[j] = data[i].typeInterface[j] + 1;
        data[i].neighborIds[j] = data[i].neighborIds[j] + 1;
      }
    }

  }

private:

  const int numberOfCells;
  static const int nEdges = 6;
  struct data_t {
    bool floodedCells = 0;
    bool floodedCellsTimeInterval = 0;

    double valueOfCellIds = 0;
    double h = 0;

    double h0 = 0;
    double vU = 0;
    double vV = 0;
    double vUh = 0;
    double vVh = 0;
    double vUh0 = 0;
    double vVh0 = 0;
    double ghh = 0;
    double sfx = 0;
    double sfy = 0;
    double qInflow = 0;
    double qStartTime = 0;
    double qEndTime = 0;
    double qIn = 0;
    double nx = 0;
    double ny = 0;
    double floorLevels = 0;
    int lowerFloorCells = 0;
    bool floorCompleteleyFilled = 0;
    double cellLocationX = 0;
    double cellLocationY = 0;
    double cellLocationZ = 0;
    int levelOfCell = 0;
    bool flagInterface[nEdges] = {};
    int typeInterface[nEdges] = {};
    int neighborIds[nEdges] = {};
  };
  std::vector&lt;data_t&gt; data;

};

int main() {
  std::ios_base::sync_with_stdio(false);
  FloodIsolation isolation;
  clock_t start = clock();
  for (int i = 0; i &lt; 400; ++i) {
    if(i % 100 == 0) {
      std::cout &lt;&lt; i &lt;&lt; "\n";
    }
    isolation.isUpdateNeeded();
  }
  clock_t stop = clock();
  std::cout &lt;&lt; "Time: " &lt;&lt; difftime(stop, start) / 1000 &lt;&lt; "\n";
}
******************************
Normalized:
******************************
Original:
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;



class FloodIsolation {
public:
  FloodIsolation() :
      numberOfCells(20000),
      data(numberOfCells)
  {
  }
  ~FloodIsolation(){
  }

  void isUpdateNeeded() {
    for (int i = 0; i &lt; numberOfCells; ++i) {
       data[i].h = data[i].h + 1;
       data[i].floodedCells = !data[i].floodedCells;
       data[i].floodedCellsTimeInterval = !data[i].floodedCellsTimeInterval;
       data[i].qInflow = data[i].qInflow + 1;
       data[i].qStartTime = data[i].qStartTime + 1;
       data[i].qEndTime = data[i].qEndTime + 1;
       data[i].lowerFloorCells = data[i].lowerFloorCells + 1;
       data[i].cellLocationX = data[i].cellLocationX + 1;
       data[i].cellLocationY = data[i].cellLocationY + 1;
       data[i].cellLocationZ = data[i].cellLocationZ + 1;
       data[i].levelOfCell = data[i].levelOfCell + 1;
       data[i].valueOfCellIds = data[i].valueOfCellIds + 1;
       data[i].h0 = data[i].h0 + 1;
       data[i].vU = data[i].vU + 1;
       data[i].vV = data[i].vV + 1;
       data[i].vUh = data[i].vUh + 1;
       data[i].vVh = data[i].vVh + 1;
       data[i].vUh0 = data[i].vUh0 + 1;
       data[i].vVh0 = data[i].vVh0 + 1;
       data[i].ghh = data[i].ghh + 1;
       data[i].sfx = data[i].sfx + 1;
       data[i].sfy = data[i].sfy + 1;
       data[i].qIn = data[i].qIn + 1;


      for(int j = 0; j &lt; nEdges; ++j) {
        data[i].flagInterface[j] = !data[i].flagInterface[j];
        data[i].typeInterface[j] = data[i].typeInterface[j] + 1;
        data[i].neighborIds[j] = data[i].neighborIds[j] + 1;
      }
    }

  }

private:

  const int numberOfCells;
  static const int nEdges = 6;
  struct data_t {
    bool floodedCells = 0;
    bool floodedCellsTimeInterval = 0;

    double valueOfCellIds = 0;
    double h = 0;

    double h0 = 0;
    double vU = 0;
    double vV = 0;
    double vUh = 0;
    double vVh = 0;
    double vUh0 = 0;
    double vVh0 = 0;
    double ghh = 0;
    double sfx = 0;
    double sfy = 0;
    double qInflow = 0;
    double qStartTime = 0;
    double qEndTime = 0;
    double qIn = 0;
    double nx = 0;
    double ny = 0;
    double floorLevels = 0;
    int lowerFloorCells = 0;
    bool floorCompleteleyFilled = 0;
    double cellLocationX = 0;
    double cellLocationY = 0;
    double cellLocationZ = 0;
    int levelOfCell = 0;
    bool flagInterface[nEdges] = {};
    int typeInterface[nEdges] = {};
    int neighborIds[nEdges] = {};
  };
  std::vector&lt;data_t&gt; data;

};

int main() {
  std::ios_base::sync_with_stdio(false);
  FloodIsolation isolation;
  clock_t start = clock();
  for (int i = 0; i &lt; 400; ++i) {
    if(i % 100 == 0) {
      std::cout &lt;&lt; i &lt;&lt; "\n";
    }
    isolation.isUpdateNeeded();
  }
  clock_t stop = clock();
  std::cout &lt;&lt; "Time: " &lt;&lt; difftime(stop, start) / 1000 &lt;&lt; "\n";
}
******************************
Normalized:
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;



class FloodIsolation {
public:
  FloodIsolation() :
      numberOfCells(20000),
      data(numberOfCells)
  {
  }
  ~FloodIsolation(){
  }

  void isUpdateNeeded() {
    for (int i = 0; i &lt; numberOfCells; ++i) {
       data[i].h = data[i].h + 1;
       data[i].floodedCells = !data[i].floodedCells;
       data[i].floodedCellsTimeInterval = !data[i].floodedCellsTimeInterval;
       data[i].qInflow = data[i].qInflow + 1;
       data[i].qStartTime = data[i].qStartTime + 1;
       data[i].qEndTime = data[i].qEndTime + 1;
       data[i].lowerFloorCells = data[i].lowerFloorCells + 1;
       data[i].cellLocationX = data[i].cellLocationX + 1;
       data[i].cellLocationY = data[i].cellLocationY + 1;
       data[i].cellLocationZ = data[i].cellLocationZ + 1;
       data[i].levelOfCell = data[i].levelOfCell + 1;
       data[i].valueOfCellIds = data[i].valueOfCellIds + 1;
       data[i].h0 = data[i].h0 + 1;
       data[i].vU = data[i].vU + 1;
       data[i].vV = data[i].vV + 1;
       data[i].vUh = data[i].vUh + 1;
       data[i].vVh = data[i].vVh + 1;
       data[i].vUh0 = data[i].vUh0 + 1;
       data[i].vVh0 = data[i].vVh0 + 1;
       data[i].ghh = data[i].ghh + 1;
       data[i].sfx = data[i].sfx + 1;
       data[i].sfy = data[i].sfy + 1;
       data[i].qIn = data[i].qIn + 1;


      for(int j = 0; j &lt; nEdges; ++j) {
        data[i].flagInterface[j] = !data[i].flagInterface[j];
        data[i].typeInterface[j] = data[i].typeInterface[j] + 1;
        data[i].neighborIds[j] = data[i].neighborIds[j] + 1;
      }
    }

  }

private:

  const int numberOfCells;
  static const int nEdges = 6;
  struct data_t {
    bool floodedCells = 0;
    bool floodedCellsTimeInterval = 0;

    double valueOfCellIds = 0;
    double h = 0;

    double h0 = 0;
    double vU = 0;
    double vV = 0;
    double vUh = 0;
    double vVh = 0;
    double vUh0 = 0;
    double vVh0 = 0;
    double ghh = 0;
    double sfx = 0;
    double sfy = 0;
    double qInflow = 0;
    double qStartTime = 0;
    double qEndTime = 0;
    double qIn = 0;
    double nx = 0;
    double ny = 0;
    double floorLevels = 0;
    int lowerFloorCells = 0;
    bool floorCompleteleyFilled = 0;
    double cellLocationX = 0;
    double cellLocationY = 0;
    double cellLocationZ = 0;
    int levelOfCell = 0;
    bool flagInterface[nEdges] = {};
    int typeInterface[nEdges] = {};
    int neighborIds[nEdges] = {};
  };
  std::vector&lt;data_t&gt; data;

};

int main() {
  std::ios_base::sync_with_stdio(false);
  FloodIsolation isolation;
  clock_t start = clock();
  for (int i = 0; i &lt; 400; ++i) {
    if(i % 100 == 0) {
      std::cout &lt;&lt; i &lt;&lt; "\n";
    }
    isolation.isUpdateNeeded();
  }
  clock_t stop = clock();
  std::cout &lt;&lt; "Time: " &lt;&lt; difftime(stop, start) / 1000 &lt;&lt; "\n";
}
******************************
Original:
private static &lt;T&gt; Stream&lt;T&gt; nonEmptyStream(
    Stream&lt;T&gt; stream, Supplier&lt;RuntimeException&gt; e) {

    Spliterator&lt;T&gt; it=stream.spliterator();
    return StreamSupport.stream(new Spliterator&lt;T&gt;() {
        boolean seen;
        public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
            boolean r=it.tryAdvance(action);
            if(!seen &amp;&amp; !r) throw e.get();
            seen=true;
            return r;
        }
        public Spliterator&lt;T&gt; trySplit() { return null; }
        public long estimateSize() { return it.estimateSize(); }
        public int characteristics() { return it.characteristics(); }
    }, false);
}
******************************
Normalized:
******************************
Original:
private static &lt;T&gt; Stream&lt;T&gt; nonEmptyStream(
    Stream&lt;T&gt; stream, Supplier&lt;RuntimeException&gt; e) {

    Spliterator&lt;T&gt; it=stream.spliterator();
    return StreamSupport.stream(new Spliterator&lt;T&gt;() {
        boolean seen;
        public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
            boolean r=it.tryAdvance(action);
            if(!seen &amp;&amp; !r) throw e.get();
            seen=true;
            return r;
        }
        public Spliterator&lt;T&gt; trySplit() { return null; }
        public long estimateSize() { return it.estimateSize(); }
        public int characteristics() { return it.characteristics(); }
    }, false);
}
******************************
Normalized:
private static &lt;T&gt; Stream&lt;T&gt; nonEmptyStream(
    Stream&lt;T&gt; stream, Supplier&lt;RuntimeException&gt; e) {

    Spliterator&lt;T&gt; it=stream.spliterator();
    return StreamSupport.stream(new Spliterator&lt;T&gt;() {
        boolean seen;
        public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
            boolean r=it.tryAdvance(action);
            if(!seen &amp;&amp; !r) throw e.get();
            seen=true;
            return r;
        }
        public Spliterator&lt;T&gt; trySplit() { return null; }
        public long estimateSize() { return it.estimateSize(); }
        public int characteristics() { return it.characteristics(); }
    }, false);
}
******************************
Original:
^[1-9]\d*$
******************************
Normalized:
******************************
Original:
^[1-9]\d*$
******************************
Normalized:
^[1-9]\d*$
******************************
Original:
&lt;Button
        android:id="@+id/header"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="@string/test"
        android:textColor="@color/black"
        android:minHeight="40dip"/&gt;


&lt;style name="Widget.Holo.Button" parent="Widget.Button"&gt;
    &lt;item name="android:background"&gt;@android:drawable/btn_default_holo_dark&lt;/item&gt;
    &lt;item name="android:textAppearance"&gt;?android:attr/textAppearanceMedium&lt;/item&gt;
    &lt;item name="android:textColor"&gt;@android:color/primary_text_holo_dark&lt;/item&gt;
    &lt;item name="android:minHeight"&gt;48dip&lt;/item&gt;
    &lt;item name="android:minWidth"&gt;64dip&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
******************************
Original:
&lt;Button
        android:id="@+id/header"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="@string/test"
        android:textColor="@color/black"
        android:minHeight="40dip"/&gt;


&lt;style name="Widget.Holo.Button" parent="Widget.Button"&gt;
    &lt;item name="android:background"&gt;@android:drawable/btn_default_holo_dark&lt;/item&gt;
    &lt;item name="android:textAppearance"&gt;?android:attr/textAppearanceMedium&lt;/item&gt;
    &lt;item name="android:textColor"&gt;@android:color/primary_text_holo_dark&lt;/item&gt;
    &lt;item name="android:minHeight"&gt;48dip&lt;/item&gt;
    &lt;item name="android:minWidth"&gt;64dip&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
&lt;Button
        android:id="@+id/header"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="@string/test"
        android:textColor="@color/black"
        android:minHeight="40dip"/&gt;


&lt;style name="Widget.Holo.Button" parent="Widget.Button"&gt;
    &lt;item name="android:background"&gt;@android:drawable/btn_default_holo_dark&lt;/item&gt;
    &lt;item name="android:textAppearance"&gt;?android:attr/textAppearanceMedium&lt;/item&gt;
    &lt;item name="android:textColor"&gt;@android:color/primary_text_holo_dark&lt;/item&gt;
    &lt;item name="android:minHeight"&gt;48dip&lt;/item&gt;
    &lt;item name="android:minWidth"&gt;64dip&lt;/item&gt;
&lt;/style&gt;
******************************
Original:
private ArrayList&lt;String&gt; _categories; // Initialize all this stuff

private int getCategoryPos(String category) {
  return _categories.indexOf(category);
}
******************************
Normalized:
******************************
Original:
private ArrayList&lt;String&gt; _categories; // Initialize all this stuff

private int getCategoryPos(String category) {
  return _categories.indexOf(category);
}
******************************
Normalized:
private ArrayList&lt;String&gt; _categories; // Initialize all this stuff

private int getCategoryPos(String category) {
  return _categories.indexOf(category);
}
******************************
Original:
@RequestMapping(value="/orders", method=RequestMethod.GET)
@ResponseBody
public List&lt;Account&gt; accountSummary() {
    return accountManager.getAllAccounts();
}
******************************
Normalized:
******************************
Original:
@RequestMapping(value="/orders", method=RequestMethod.GET)
@ResponseBody
public List&lt;Account&gt; accountSummary() {
    return accountManager.getAllAccounts();
}
******************************
Normalized:
@RequestMapping(value="/orders", method=RequestMethod.GET)
@ResponseBody
public List&lt;Account&gt; accountSummary() {
    return accountManager.getAllAccounts();
}
******************************
Original:
JSONArray jsonarray = new JSONArray(jsonStr);
for (int i = 0; i &lt; jsonarray.length(); i++) {
    JSONObject jsonobject = jsonarray.getJSONObject(i);
    String name = jsonobject.getString("name");
    String url = jsonobject.getString("url");
}
******************************
Normalized:
******************************
Original:
JSONArray jsonarray = new JSONArray(jsonStr);
for (int i = 0; i &lt; jsonarray.length(); i++) {
    JSONObject jsonobject = jsonarray.getJSONObject(i);
    String name = jsonobject.getString("name");
    String url = jsonobject.getString("url");
}
******************************
Normalized:
JSONArray jsonarray = new JSONArray(jsonStr);
for (int i = 0; i &lt; jsonarray.length(); i++) {
    JSONObject jsonobject = jsonarray.getJSONObject(i);
    String name = jsonobject.getString("name");
    String url = jsonobject.getString("url");
}
******************************
Original:
@Entity
@NamedEntityGraph(name = "GroupInfo.detail",
  attributeNodes = @NamedAttributeNode("members"))
public class GroupInfo {

  // default fetch mode is lazy.
  @ManyToMany
  List&lt;GroupMember&gt; members = new ArrayList&lt;GroupMember&gt;();

  …
}

@Repository
public interface GroupRepository extends CrudRepository&lt;GroupInfo, String&gt; {

  @EntityGraph(value = "GroupInfo.detail", type = EntityGraphType.LOAD)
  GroupInfo getByGroupName(String name);

}
******************************
Normalized:
******************************
Original:
@Entity
@NamedEntityGraph(name = "GroupInfo.detail",
  attributeNodes = @NamedAttributeNode("members"))
public class GroupInfo {

  // default fetch mode is lazy.
  @ManyToMany
  List&lt;GroupMember&gt; members = new ArrayList&lt;GroupMember&gt;();

  …
}

@Repository
public interface GroupRepository extends CrudRepository&lt;GroupInfo, String&gt; {

  @EntityGraph(value = "GroupInfo.detail", type = EntityGraphType.LOAD)
  GroupInfo getByGroupName(String name);

}
******************************
Normalized:
@Entity
@NamedEntityGraph(name = "GroupInfo.detail",
  attributeNodes = @NamedAttributeNode("members"))
public class GroupInfo {

  // default fetch mode is lazy.
  @ManyToMany
  List&lt;GroupMember&gt; members = new ArrayList&lt;GroupMember&gt;();

  …
}

@Repository
public interface GroupRepository extends CrudRepository&lt;GroupInfo, String&gt; {

  @EntityGraph(value = "GroupInfo.detail", type = EntityGraphType.LOAD)
  GroupInfo getByGroupName(String name);

}
******************************
Original:
open -a /Applications/IntelliJ\ IDEA\ 12.app/
******************************
Normalized:
******************************
Original:
open -a /Applications/IntelliJ\ IDEA\ 12.app/
******************************
Normalized:
open -a /Applications/IntelliJ\ IDEA\ 12.app/
******************************
Original:
String brandName;

@JsonProperty("brand")
private void unpackNameFromNestedObject(Map&lt;String, String&gt; brand) {
    brandName = brand.get("name");
}
******************************
Normalized:
******************************
Original:
String brandName;

@JsonProperty("brand")
private void unpackNameFromNestedObject(Map&lt;String, String&gt; brand) {
    brandName = brand.get("name");
}
******************************
Normalized:
String brandName;

@JsonProperty("brand")
private void unpackNameFromNestedObject(Map&lt;String, String&gt; brand) {
    brandName = brand.get("name");
}
******************************
Original:
d = D()          // these four computations can happen in any order
b = B()
c = C()
a = A()
sum = a + b      // these two computations can happen in any order
product = c * d
result = sum + product // this has to happen last
******************************
Normalized:
******************************
Original:
d = D()          // these four computations can happen in any order
b = B()
c = C()
a = A()
sum = a + b      // these two computations can happen in any order
product = c * d
result = sum + product // this has to happen last
******************************
Normalized:
d = D()          // these four computations can happen in any order
b = B()
c = C()
a = A()
sum = a + b      // these two computations can happen in any order
product = c * d
result = sum + product // this has to happen last
******************************
Original:
List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
******************************
Normalized:
******************************
Original:
List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
******************************
Normalized:
List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
******************************
Original:
@JsonDeserialize(builder = Address.Builder.class)
******************************
Normalized:
******************************
Original:
@JsonDeserialize(builder = Address.Builder.class)
******************************
Normalized:
@JsonDeserialize(builder = Address.Builder.class)
******************************
Original:
OctalEscape:
    \ OctalDigit
    \ OctalDigit OctalDigit
    \ ZeroToThree OctalDigit OctalDigit

OctalDigit: one of
    0 1 2 3 4 5 6 7

ZeroToThree: one of
    0 1 2 3
******************************
Normalized:
******************************
Original:
OctalEscape:
    \ OctalDigit
    \ OctalDigit OctalDigit
    \ ZeroToThree OctalDigit OctalDigit

OctalDigit: one of
    0 1 2 3 4 5 6 7

ZeroToThree: one of
    0 1 2 3
******************************
Normalized:
OctalEscape:
    \ OctalDigit
    \ OctalDigit OctalDigit
    \ ZeroToThree OctalDigit OctalDigit

OctalDigit: one of
    0 1 2 3 4 5 6 7

ZeroToThree: one of
    0 1 2 3
******************************
Original:
Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full. Compiler has been disabled.
Java HotSpot(TM) 64-Bit Server VM warning: Try increasing the code cache size using -XX:ReservedCodeCacheSize=
Code Cache  [0x000000010958f000, 0x000000010c52f000, 0x000000010c58f000)
 total_blobs=15406 nmethods=14989 adapters=362 free_code_cache=835Kb largest_free_block=449792
******************************
Normalized:
******************************
Original:
Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full. Compiler has been disabled.
Java HotSpot(TM) 64-Bit Server VM warning: Try increasing the code cache size using -XX:ReservedCodeCacheSize=
Code Cache  [0x000000010958f000, 0x000000010c52f000, 0x000000010c58f000)
 total_blobs=15406 nmethods=14989 adapters=362 free_code_cache=835Kb largest_free_block=449792
******************************
Normalized:
Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full. Compiler has been disabled.
Java HotSpot(TM) 64-Bit Server VM warning: Try increasing the code cache size using -XX:ReservedCodeCacheSize=
Code Cache  [0x000000010958f000, 0x000000010c52f000, 0x000000010c58f000)
 total_blobs=15406 nmethods=14989 adapters=362 free_code_cache=835Kb largest_free_block=449792
******************************
Original:
import static java.lang.Math.abs;

public static long roundUp(long num, long divisor) {
    int sign = (num &gt; 0 ? 1 : -1) * (divisor &gt; 0 ? 1 : -1);
    return sign * (abs(num) + abs(divisor) - 1) / abs(divisor);
}
******************************
Normalized:
******************************
Original:
import static java.lang.Math.abs;

public static long roundUp(long num, long divisor) {
    int sign = (num &gt; 0 ? 1 : -1) * (divisor &gt; 0 ? 1 : -1);
    return sign * (abs(num) + abs(divisor) - 1) / abs(divisor);
}
******************************
Normalized:
import static java.lang.Math.abs;

public static long roundUp(long num, long divisor) {
    int sign = (num &gt; 0 ? 1 : -1) * (divisor &gt; 0 ? 1 : -1);
    return sign * (abs(num) + abs(divisor) - 1) / abs(divisor);
}
******************************
Original:
&lt;http&gt;    
    &lt;headers&gt;
        &lt;frame-options policy="SAMEORIGIN"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;
******************************
Normalized:
******************************
Original:
&lt;http&gt;    
    &lt;headers&gt;
        &lt;frame-options policy="SAMEORIGIN"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;
******************************
Normalized:
&lt;http&gt;    
    &lt;headers&gt;
        &lt;frame-options policy="SAMEORIGIN"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;
******************************
Original:
n      0000100...000
-n      1111100...000
 n &amp; -n 0000100...000
******************************
Normalized:
******************************
Original:
n      0000100...000
-n      1111100...000
 n &amp; -n 0000100...000
******************************
Normalized:
n      0000100...000
-n      1111100...000
 n &amp; -n 0000100...000
******************************
Original:
FileOutputStream(File file, boolean append)
******************************
Normalized:
******************************
Original:
FileOutputStream(File file, boolean append)
******************************
Normalized:
FileOutputStream(File file, boolean append)
******************************
Original:
List&lt;Integer&gt; x = new ArrayList&lt;Integer&gt;();
x.add(1);
x.add(2);
******************************
Normalized:
******************************
Original:
List&lt;Integer&gt; x = new ArrayList&lt;Integer&gt;();
x.add(1);
x.add(2);
******************************
Normalized:
List&lt;Integer&gt; x = new ArrayList&lt;Integer&gt;();
x.add(1);
x.add(2);
******************************
Original:
import javax.swing.JOptionPane;
import javax.swing.JFrame;

/*Some piece of code*/
frame.addWindowListener(new java.awt.event.WindowAdapter() {
    @Override
    public void windowClosing(java.awt.event.WindowEvent windowEvent) {
        if (JOptionPane.showConfirmDialog(frame, 
            "Are you sure you want to close this window?", "Close Window?", 
            JOptionPane.YES_NO_OPTION,
            JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION){
            System.exit(0);
        }
    }
});
******************************
Normalized:
******************************
Original:
import javax.swing.JOptionPane;
import javax.swing.JFrame;

/*Some piece of code*/
frame.addWindowListener(new java.awt.event.WindowAdapter() {
    @Override
    public void windowClosing(java.awt.event.WindowEvent windowEvent) {
        if (JOptionPane.showConfirmDialog(frame, 
            "Are you sure you want to close this window?", "Close Window?", 
            JOptionPane.YES_NO_OPTION,
            JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION){
            System.exit(0);
        }
    }
});
******************************
Normalized:
import javax.swing.JOptionPane;
import javax.swing.JFrame;

/*Some piece of code*/
frame.addWindowListener(new java.awt.event.WindowAdapter() {
    @Override
    public void windowClosing(java.awt.event.WindowEvent windowEvent) {
        if (JOptionPane.showConfirmDialog(frame, 
            "Are you sure you want to close this window?", "Close Window?", 
            JOptionPane.YES_NO_OPTION,
            JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION){
            System.exit(0);
        }
    }
});
******************************
Original:
public class RealPayment implements Payment {
   @Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      @Assisted Date startDate,
      @Assisted Money amount) {
     ...
   }
 }
******************************
Normalized:
******************************
Original:
public class RealPayment implements Payment {
   @Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      @Assisted Date startDate,
      @Assisted Money amount) {
     ...
   }
 }
******************************
Normalized:
public class RealPayment implements Payment {
   @Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      @Assisted Date startDate,
      @Assisted Money amount) {
     ...
   }
 }
******************************
Original:
public class Test {
    public static void main(String[] args) {
        int x;
        if (args.length &gt; 0) {
            x = 1;
        } else {
            x = 2;
        }
    }

    public static void main2(String[] args) {
        int x = (args.length &gt; 0) ? 1 : 2;
    }
}
******************************
Normalized:
******************************
Original:
public class Test {
    public static void main(String[] args) {
        int x;
        if (args.length &gt; 0) {
            x = 1;
        } else {
            x = 2;
        }
    }

    public static void main2(String[] args) {
        int x = (args.length &gt; 0) ? 1 : 2;
    }
}
******************************
Normalized:
public class Test {
    public static void main(String[] args) {
        int x;
        if (args.length &gt; 0) {
            x = 1;
        } else {
            x = 2;
        }
    }

    public static void main2(String[] args) {
        int x = (args.length &gt; 0) ? 1 : 2;
    }
}
******************************
Original:
@ComponentScan({"com.my.package.first","com.my.package.second"})
******************************
Normalized:
******************************
Original:
@ComponentScan({"com.my.package.first","com.my.package.second"})
******************************
Normalized:
@ComponentScan({"com.my.package.first","com.my.package.second"})
******************************
Original:
public class Foo&lt;T&gt; 
{
    private Class&lt;T&gt; type;

    public Foo(Class&lt;T&gt; type) { this.type = type; } 
}
******************************
Normalized:
******************************
Original:
public class Foo&lt;T&gt; 
{
    private Class&lt;T&gt; type;

    public Foo(Class&lt;T&gt; type) { this.type = type; } 
}
******************************
Normalized:
public class Foo&lt;T&gt; 
{
    private Class&lt;T&gt; type;

    public Foo(Class&lt;T&gt; type) { this.type = type; } 
}
******************************
Original:
while (true) {
    ....
    if (obj == null) {
        break;
    }
    ....
}
******************************
Normalized:
******************************
Original:
while (true) {
    ....
    if (obj == null) {
        break;
    }
    ....
}
******************************
Normalized:
while (true) {
    ....
    if (obj == null) {
        break;
    }
    ....
}
******************************
Original:
javac dir1/*.java dir2/*.java dir3/dir4/*.java dir3/dir5/*.java dir6/*src/*.java
******************************
Normalized:
******************************
Original:
javac dir1/*.java dir2/*.java dir3/dir4/*.java dir3/dir5/*.java dir6/*src/*.java
******************************
Normalized:
javac dir1/*.java dir2/*.java dir3/dir4/*.java dir3/dir5/*.java dir6/*src/*.java
******************************
Original:
public class Demo {
  private int num = 0;
  /**
  * Access field {@link Demo#num} / {@link #num}  ...
  */
  private void foo() { ... }
...
******************************
Normalized:
******************************
Original:
public class Demo {
  private int num = 0;
  /**
  * Access field {@link Demo#num} / {@link #num}  ...
  */
  private void foo() { ... }
...
******************************
Normalized:
public class Demo {
  private int num = 0;
  /**
  * Access field {@link Demo#num} / {@link #num}  ...
  */
  private void foo() { ... }
...
******************************
Original:
java -XshowSettings:properties -version
******************************
Normalized:
******************************
Original:
java -XshowSettings:properties -version
******************************
Normalized:
java -XshowSettings:properties -version
******************************
Original:
public static &lt;T&gt; T isNull(Class&lt;T&gt; clazz)
******************************
Normalized:
******************************
Original:
public static &lt;T&gt; T isNull(Class&lt;T&gt; clazz)
******************************
Normalized:
public static &lt;T&gt; T isNull(Class&lt;T&gt; clazz)
******************************
Original:
1011 = -3
0011 = +3
******************************
Normalized:
******************************
Original:
1011 = -3
0011 = +3
******************************
Normalized:
1011 = -3
0011 = +3
******************************
Original:
final List&lt;MyObject&gt; list = query.list();
******************************
Normalized:
******************************
Original:
final List&lt;MyObject&gt; list = query.list();
******************************
Normalized:
final List&lt;MyObject&gt; list = query.list();
******************************
Original:
val handler = Handler&lt;String&gt; { println("Hello: $it")}
******************************
Normalized:
******************************
Original:
val handler = Handler&lt;String&gt; { println("Hello: $it")}
******************************
Normalized:
val handler = Handler&lt;String&gt; { println("Hello: $it")}
******************************
Original:
&lt;style name="MyMaterialTheme" parent="MyMaterialTheme.Base"&gt;

&lt;/style&gt;

&lt;style name="MyMaterialTheme.Base" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;
    &lt;item name="windowActionBar"&gt;false&lt;/item&gt;
    &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name="drawerArrowStyle"&gt;@style/DrawerArrowStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="DrawerArrowStyle" parent="@style/Widget.AppCompat.DrawerArrowToggle"&gt;
    &lt;item name="spinBars"&gt;true&lt;/item&gt;
    &lt;item name="color"&gt;@android:color/black&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
******************************
Original:
&lt;style name="MyMaterialTheme" parent="MyMaterialTheme.Base"&gt;

&lt;/style&gt;

&lt;style name="MyMaterialTheme.Base" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;
    &lt;item name="windowActionBar"&gt;false&lt;/item&gt;
    &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name="drawerArrowStyle"&gt;@style/DrawerArrowStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="DrawerArrowStyle" parent="@style/Widget.AppCompat.DrawerArrowToggle"&gt;
    &lt;item name="spinBars"&gt;true&lt;/item&gt;
    &lt;item name="color"&gt;@android:color/black&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
&lt;style name="MyMaterialTheme" parent="MyMaterialTheme.Base"&gt;

&lt;/style&gt;

&lt;style name="MyMaterialTheme.Base" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;
    &lt;item name="windowActionBar"&gt;false&lt;/item&gt;
    &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name="drawerArrowStyle"&gt;@style/DrawerArrowStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="DrawerArrowStyle" parent="@style/Widget.AppCompat.DrawerArrowToggle"&gt;
    &lt;item name="spinBars"&gt;true&lt;/item&gt;
    &lt;item name="color"&gt;@android:color/black&lt;/item&gt;
&lt;/style&gt;
******************************
Original:
Gson gson = new Gson();
String jsonOutput = "Your JSON String";
Type listType = new TypeToken&lt;List&lt;Post&gt;&gt;(){}.getType();
List&lt;Post&gt; posts = gson.fromJson(jsonOutput, listType);
******************************
Normalized:
******************************
Original:
Gson gson = new Gson();
String jsonOutput = "Your JSON String";
Type listType = new TypeToken&lt;List&lt;Post&gt;&gt;(){}.getType();
List&lt;Post&gt; posts = gson.fromJson(jsonOutput, listType);
******************************
Normalized:
Gson gson = new Gson();
String jsonOutput = "Your JSON String";
Type listType = new TypeToken&lt;List&lt;Post&gt;&gt;(){}.getType();
List&lt;Post&gt; posts = gson.fromJson(jsonOutput, listType);
******************************
Original:
&lt;%@ page pageEncoding="UTF-8" %&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;
&lt;c:set var="language" value="${not empty param.language ? param.language : not empty language ? language : pageContext.request.locale}" scope="session" /&gt;
&lt;fmt:setLocale value="${language}" /&gt;
&lt;fmt:setBundle basename="com.example.i18n.text" /&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="${language}"&gt;
    &lt;head&gt;
        &lt;title&gt;JSP/JSTL i18n demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form&gt;
            &lt;select id="language" name="language" onchange="submit()"&gt;
                &lt;option value="en" ${language == 'en' ? 'selected' : ''}&gt;English&lt;/option&gt;
                &lt;option value="nl" ${language == 'nl' ? 'selected' : ''}&gt;Nederlands&lt;/option&gt;
                &lt;option value="es" ${language == 'es' ? 'selected' : ''}&gt;Español&lt;/option&gt;
            &lt;/select&gt;
        &lt;/form&gt;
        &lt;form method="post"&gt;
            &lt;label for="username"&gt;&lt;fmt:message key="login.label.username" /&gt;:&lt;/label&gt;
            &lt;input type="text" id="username" name="username"&gt;
            &lt;br&gt;
            &lt;label for="password"&gt;&lt;fmt:message key="login.label.password" /&gt;:&lt;/label&gt;
            &lt;input type="password" id="password" name="password"&gt;
            &lt;br&gt;
            &lt;fmt:message key="login.button.submit" var="buttonValue" /&gt;
            &lt;input type="submit" name="submit" value="${buttonValue}"&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
******************************
Normalized:
******************************
Original:
&lt;%@ page pageEncoding="UTF-8" %&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;
&lt;c:set var="language" value="${not empty param.language ? param.language : not empty language ? language : pageContext.request.locale}" scope="session" /&gt;
&lt;fmt:setLocale value="${language}" /&gt;
&lt;fmt:setBundle basename="com.example.i18n.text" /&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="${language}"&gt;
    &lt;head&gt;
        &lt;title&gt;JSP/JSTL i18n demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form&gt;
            &lt;select id="language" name="language" onchange="submit()"&gt;
                &lt;option value="en" ${language == 'en' ? 'selected' : ''}&gt;English&lt;/option&gt;
                &lt;option value="nl" ${language == 'nl' ? 'selected' : ''}&gt;Nederlands&lt;/option&gt;
                &lt;option value="es" ${language == 'es' ? 'selected' : ''}&gt;Español&lt;/option&gt;
            &lt;/select&gt;
        &lt;/form&gt;
        &lt;form method="post"&gt;
            &lt;label for="username"&gt;&lt;fmt:message key="login.label.username" /&gt;:&lt;/label&gt;
            &lt;input type="text" id="username" name="username"&gt;
            &lt;br&gt;
            &lt;label for="password"&gt;&lt;fmt:message key="login.label.password" /&gt;:&lt;/label&gt;
            &lt;input type="password" id="password" name="password"&gt;
            &lt;br&gt;
            &lt;fmt:message key="login.button.submit" var="buttonValue" /&gt;
            &lt;input type="submit" name="submit" value="${buttonValue}"&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
******************************
Normalized:
&lt;%@ page pageEncoding="UTF-8" %&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;
&lt;c:set var="language" value="${not empty param.language ? param.language : not empty language ? language : pageContext.request.locale}" scope="session" /&gt;
&lt;fmt:setLocale value="${language}" /&gt;
&lt;fmt:setBundle basename="com.example.i18n.text" /&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="${language}"&gt;
    &lt;head&gt;
        &lt;title&gt;JSP/JSTL i18n demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form&gt;
            &lt;select id="language" name="language" onchange="submit()"&gt;
                &lt;option value="en" ${language == 'en' ? 'selected' : ''}&gt;English&lt;/option&gt;
                &lt;option value="nl" ${language == 'nl' ? 'selected' : ''}&gt;Nederlands&lt;/option&gt;
                &lt;option value="es" ${language == 'es' ? 'selected' : ''}&gt;Español&lt;/option&gt;
            &lt;/select&gt;
        &lt;/form&gt;
        &lt;form method="post"&gt;
            &lt;label for="username"&gt;&lt;fmt:message key="login.label.username" /&gt;:&lt;/label&gt;
            &lt;input type="text" id="username" name="username"&gt;
            &lt;br&gt;
            &lt;label for="password"&gt;&lt;fmt:message key="login.label.password" /&gt;:&lt;/label&gt;
            &lt;input type="password" id="password" name="password"&gt;
            &lt;br&gt;
            &lt;fmt:message key="login.button.submit" var="buttonValue" /&gt;
            &lt;input type="submit" name="submit" value="${buttonValue}"&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
******************************
Original:
for (int i = 0; i &lt; size; i++)
   a += b;
   System.out.println("foo");
******************************
Normalized:
******************************
Original:
for (int i = 0; i &lt; size; i++)
   a += b;
   System.out.println("foo");
******************************
Normalized:
for (int i = 0; i &lt; size; i++)
   a += b;
   System.out.println("foo");
******************************
Original:
myObject = new ArrayList&lt;Object&gt;(myTempObject);
******************************
Normalized:
******************************
Original:
myObject = new ArrayList&lt;Object&gt;(myTempObject);
******************************
Normalized:
myObject = new ArrayList&lt;Object&gt;(myTempObject);
******************************
Original:
public class Utilities {

    private class SolarCalendar {

        public String strWeekDay = "";
        public String strMonth = "";

        int date;
        int month;
        int year;

        public SolarCalendar()
        {
            Date MiladiDate = new Date();
            calcSolarCalendar(MiladiDate);
        }

        public SolarCalendar(Date MiladiDate)
        {
            calcSolarCalendar(MiladiDate);
        }

        private void calcSolarCalendar(Date MiladiDate) {

            int ld;

            int miladiYear = MiladiDate.getYear() + 1900;
            int miladiMonth = MiladiDate.getMonth() + 1;
            int miladiDate = MiladiDate.getDate();
            int WeekDay = MiladiDate.getDay();

            int[] buf1 = new int[12];
            int[] buf2 = new int[12];

            buf1[0] = 0;
            buf1[1] = 31;
            buf1[2] = 59;
            buf1[3] = 90;
            buf1[4] = 120;
            buf1[5] = 151;
            buf1[6] = 181;
            buf1[7] = 212;
            buf1[8] = 243;
            buf1[9] = 273;
            buf1[10] = 304;
            buf1[11] = 334;

            buf2[0] = 0;
            buf2[1] = 31;
            buf2[2] = 60;
            buf2[3] = 91;
            buf2[4] = 121;
            buf2[5] = 152;
            buf2[6] = 182;
            buf2[7] = 213;
            buf2[8] = 244;
            buf2[9] = 274;
            buf2[10] = 305;
            buf2[11] = 335;

            if ((miladiYear % 4) != 0) {
                date = buf1[miladiMonth - 1] + miladiDate;

                if (date &gt; 79) {
                    date = date - 79;
                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = date / 31;
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                } else {
                    if ((miladiYear &gt; 1996) &amp;&amp; (miladiYear % 4) == 1) {
                        ld = 11;
                    } else {
                        ld = 10;
                    }
                    date = date + ld;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }
            } else {
                date = buf2[miladiMonth - 1] + miladiDate;

                if (miladiYear &gt;= 1996) {
                    ld = 79;
                } else {
                    ld = 80;
                }
                if (date &gt; ld) {
                    date = date - ld;

                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = (date / 31);
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                }

                else {
                    date = date + 10;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }

            }

            switch (month) {
            case 1:
                strMonth = "فروردين";
                break;
            case 2:
                strMonth = "ارديبهشت";
                break;
            case 3:
                strMonth = "خرداد";
                break;
            case 4:
                strMonth = "تير";
                break;
            case 5:
                strMonth = "مرداد";
                break;
            case 6:
                strMonth = "شهريور";
                break;
            case 7:
                strMonth = "مهر";
                break;
            case 8:
                strMonth = "آبان";
                break;
            case 9:
                strMonth = "آذر";
                break;
            case 10:
                strMonth = "دي";
                break;
            case 11:
                strMonth = "بهمن";
                break;
            case 12:
                strMonth = "اسفند";
                break;
            }

            switch (WeekDay) {

            case 0:
                strWeekDay = "يکشنبه";
                break;
            case 1:
                strWeekDay = "دوشنبه";
                break;
            case 2:
                strWeekDay = "سه شنبه";
                break;
            case 3:
                strWeekDay = "چهارشنبه";
                break;
            case 4:
                strWeekDay = "پنج شنبه";
                break;
            case 5:
                strWeekDay = "جمعه";
                break;
            case 6:
                strWeekDay = "شنبه";
                break;
            }

        }

    }

    public static String getCurrentShamsidate() {
        Locale loc = new Locale("en_US");
        Utilities util = new Utilities();
        SolarCalendar sc = util.new SolarCalendar();
        return String.valueOf(sc.year) + "/" + String.format(loc, "%02d",
                sc.month) + "/" + String.format(loc, "%02d", sc.date);
    }
}
******************************
Normalized:
******************************
Original:
public class Utilities {

    private class SolarCalendar {

        public String strWeekDay = "";
        public String strMonth = "";

        int date;
        int month;
        int year;

        public SolarCalendar()
        {
            Date MiladiDate = new Date();
            calcSolarCalendar(MiladiDate);
        }

        public SolarCalendar(Date MiladiDate)
        {
            calcSolarCalendar(MiladiDate);
        }

        private void calcSolarCalendar(Date MiladiDate) {

            int ld;

            int miladiYear = MiladiDate.getYear() + 1900;
            int miladiMonth = MiladiDate.getMonth() + 1;
            int miladiDate = MiladiDate.getDate();
            int WeekDay = MiladiDate.getDay();

            int[] buf1 = new int[12];
            int[] buf2 = new int[12];

            buf1[0] = 0;
            buf1[1] = 31;
            buf1[2] = 59;
            buf1[3] = 90;
            buf1[4] = 120;
            buf1[5] = 151;
            buf1[6] = 181;
            buf1[7] = 212;
            buf1[8] = 243;
            buf1[9] = 273;
            buf1[10] = 304;
            buf1[11] = 334;

            buf2[0] = 0;
            buf2[1] = 31;
            buf2[2] = 60;
            buf2[3] = 91;
            buf2[4] = 121;
            buf2[5] = 152;
            buf2[6] = 182;
            buf2[7] = 213;
            buf2[8] = 244;
            buf2[9] = 274;
            buf2[10] = 305;
            buf2[11] = 335;

            if ((miladiYear % 4) != 0) {
                date = buf1[miladiMonth - 1] + miladiDate;

                if (date &gt; 79) {
                    date = date - 79;
                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = date / 31;
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                } else {
                    if ((miladiYear &gt; 1996) &amp;&amp; (miladiYear % 4) == 1) {
                        ld = 11;
                    } else {
                        ld = 10;
                    }
                    date = date + ld;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }
            } else {
                date = buf2[miladiMonth - 1] + miladiDate;

                if (miladiYear &gt;= 1996) {
                    ld = 79;
                } else {
                    ld = 80;
                }
                if (date &gt; ld) {
                    date = date - ld;

                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = (date / 31);
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                }

                else {
                    date = date + 10;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }

            }

            switch (month) {
            case 1:
                strMonth = "فروردين";
                break;
            case 2:
                strMonth = "ارديبهشت";
                break;
            case 3:
                strMonth = "خرداد";
                break;
            case 4:
                strMonth = "تير";
                break;
            case 5:
                strMonth = "مرداد";
                break;
            case 6:
                strMonth = "شهريور";
                break;
            case 7:
                strMonth = "مهر";
                break;
            case 8:
                strMonth = "آبان";
                break;
            case 9:
                strMonth = "آذر";
                break;
            case 10:
                strMonth = "دي";
                break;
            case 11:
                strMonth = "بهمن";
                break;
            case 12:
                strMonth = "اسفند";
                break;
            }

            switch (WeekDay) {

            case 0:
                strWeekDay = "يکشنبه";
                break;
            case 1:
                strWeekDay = "دوشنبه";
                break;
            case 2:
                strWeekDay = "سه شنبه";
                break;
            case 3:
                strWeekDay = "چهارشنبه";
                break;
            case 4:
                strWeekDay = "پنج شنبه";
                break;
            case 5:
                strWeekDay = "جمعه";
                break;
            case 6:
                strWeekDay = "شنبه";
                break;
            }

        }

    }

    public static String getCurrentShamsidate() {
        Locale loc = new Locale("en_US");
        Utilities util = new Utilities();
        SolarCalendar sc = util.new SolarCalendar();
        return String.valueOf(sc.year) + "/" + String.format(loc, "%02d",
                sc.month) + "/" + String.format(loc, "%02d", sc.date);
    }
}
******************************
Normalized:
public class Utilities {

    private class SolarCalendar {

        public String strWeekDay = "";
        public String strMonth = "";

        int date;
        int month;
        int year;

        public SolarCalendar()
        {
            Date MiladiDate = new Date();
            calcSolarCalendar(MiladiDate);
        }

        public SolarCalendar(Date MiladiDate)
        {
            calcSolarCalendar(MiladiDate);
        }

        private void calcSolarCalendar(Date MiladiDate) {

            int ld;

            int miladiYear = MiladiDate.getYear() + 1900;
            int miladiMonth = MiladiDate.getMonth() + 1;
            int miladiDate = MiladiDate.getDate();
            int WeekDay = MiladiDate.getDay();

            int[] buf1 = new int[12];
            int[] buf2 = new int[12];

            buf1[0] = 0;
            buf1[1] = 31;
            buf1[2] = 59;
            buf1[3] = 90;
            buf1[4] = 120;
            buf1[5] = 151;
            buf1[6] = 181;
            buf1[7] = 212;
            buf1[8] = 243;
            buf1[9] = 273;
            buf1[10] = 304;
            buf1[11] = 334;

            buf2[0] = 0;
            buf2[1] = 31;
            buf2[2] = 60;
            buf2[3] = 91;
            buf2[4] = 121;
            buf2[5] = 152;
            buf2[6] = 182;
            buf2[7] = 213;
            buf2[8] = 244;
            buf2[9] = 274;
            buf2[10] = 305;
            buf2[11] = 335;

            if ((miladiYear % 4) != 0) {
                date = buf1[miladiMonth - 1] + miladiDate;

                if (date &gt; 79) {
                    date = date - 79;
                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = date / 31;
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                } else {
                    if ((miladiYear &gt; 1996) &amp;&amp; (miladiYear % 4) == 1) {
                        ld = 11;
                    } else {
                        ld = 10;
                    }
                    date = date + ld;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }
            } else {
                date = buf2[miladiMonth - 1] + miladiDate;

                if (miladiYear &gt;= 1996) {
                    ld = 79;
                } else {
                    ld = 80;
                }
                if (date &gt; ld) {
                    date = date - ld;

                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = (date / 31);
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                }

                else {
                    date = date + 10;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }

            }

            switch (month) {
            case 1:
                strMonth = "فروردين";
                break;
            case 2:
                strMonth = "ارديبهشت";
                break;
            case 3:
                strMonth = "خرداد";
                break;
            case 4:
                strMonth = "تير";
                break;
            case 5:
                strMonth = "مرداد";
                break;
            case 6:
                strMonth = "شهريور";
                break;
            case 7:
                strMonth = "مهر";
                break;
            case 8:
                strMonth = "آبان";
                break;
            case 9:
                strMonth = "آذر";
                break;
            case 10:
                strMonth = "دي";
                break;
            case 11:
                strMonth = "بهمن";
                break;
            case 12:
                strMonth = "اسفند";
                break;
            }

            switch (WeekDay) {

            case 0:
                strWeekDay = "يکشنبه";
                break;
            case 1:
                strWeekDay = "دوشنبه";
                break;
            case 2:
                strWeekDay = "سه شنبه";
                break;
            case 3:
                strWeekDay = "چهارشنبه";
                break;
            case 4:
                strWeekDay = "پنج شنبه";
                break;
            case 5:
                strWeekDay = "جمعه";
                break;
            case 6:
                strWeekDay = "شنبه";
                break;
            }

        }

    }

    public static String getCurrentShamsidate() {
        Locale loc = new Locale("en_US");
        Utilities util = new Utilities();
        SolarCalendar sc = util.new SolarCalendar();
        return String.valueOf(sc.year) + "/" + String.format(loc, "%02d",
                sc.month) + "/" + String.format(loc, "%02d", sc.date);
    }
}
******************************
Original:
public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription
******************************
Normalized:
******************************
Original:
public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription
******************************
Normalized:
public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription
******************************
Original:
void method1() {
    synchronized (this) {
        method2()
    }
}

void method2() {
    synchronized (this) {
    }
}
******************************
Normalized:
******************************
Original:
void method1() {
    synchronized (this) {
        method2()
    }
}

void method2() {
    synchronized (this) {
    }
}
******************************
Normalized:
void method1() {
    synchronized (this) {
        method2()
    }
}

void method2() {
    synchronized (this) {
    }
}
******************************
Original:
AnotherClass anotherObjSpy = Mockito.spy(new AnotherClass());
// do stuff -- e.g. anotherObjSpy.foo(...);
verify(anotherObjSpy).codePath1(...);
******************************
Normalized:
******************************
Original:
AnotherClass anotherObjSpy = Mockito.spy(new AnotherClass());
// do stuff -- e.g. anotherObjSpy.foo(...);
verify(anotherObjSpy).codePath1(...);
******************************
Normalized:
AnotherClass anotherObjSpy = Mockito.spy(new AnotherClass());
// do stuff -- e.g. anotherObjSpy.foo(...);
verify(anotherObjSpy).codePath1(...);
******************************
Original:
public class GenericList &lt;T&gt; extends ArrayList&lt;T&gt;
{
     private Class&lt;T&gt; genericType;

     public GenericList(Class&lt;T&gt; c)
     {
          this.genericType = c;
     }

     public Class&lt;T&gt; getGenericType()
     {
          return genericType;
     }
}
******************************
Normalized:
******************************
Original:
public class GenericList &lt;T&gt; extends ArrayList&lt;T&gt;
{
     private Class&lt;T&gt; genericType;

     public GenericList(Class&lt;T&gt; c)
     {
          this.genericType = c;
     }

     public Class&lt;T&gt; getGenericType()
     {
          return genericType;
     }
}
******************************
Normalized:
public class GenericList &lt;T&gt; extends ArrayList&lt;T&gt;
{
     private Class&lt;T&gt; genericType;

     public GenericList(Class&lt;T&gt; c)
     {
          this.genericType = c;
     }

     public Class&lt;T&gt; getGenericType()
     {
          return genericType;
     }
}
******************************
Original:
package hashmaptest;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

public class HashMapTest {

    private static final List&lt;Result&gt; results = new ArrayList&lt;Result&gt;();

    public static void main(String[] args) throws IOException {

        //First entry of each array is the sample collection size, subsequent entries
        //are the hash limits
        final int[][] sampleSizesAndHashLimits = new int[][] {
            {100, 50, 90, 100},
            {1000, 500, 900, 990, 1000},
            {100000, 10000, 90000, 99000, 100000}
        };
        final double[] initialCapacityFactors = new double[] {0.5, 0.75, 1.0, 1.25, 1.5, 2.0};
        final float[] loadFactors = new float[] {0.5f, 0.75f, 1.0f, 1.25f};

        //Doing a warmup run to eliminate JIT influence
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        results.clear();

        //Now for the real thing...
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        Collections.sort(results);

        for(final Result result : results) {
            result.printSummary();
        }

//      ResultVisualizer.visualizeResults(results);

    }

    private static void runTest(final int hashLimit, final int sampleSize,
            final double initCapacityFactor, final float loadFactor) {

        final int initialCapacity = (int)(sampleSize * initCapacityFactor);

        System.out.println("Running test for a sample collection of size " + sampleSize 
            + ", an initial capacity of " + initialCapacity + ", a load factor of "
            + loadFactor + " and keys with a hash code limited to " + hashLimit);
        System.out.println("====================");

        double hashOverload = (((double)sampleSize/hashLimit) - 1.0) * 100.0;

        System.out.println("Hash code overload: " + hashOverload + "%");

        //Generating our sample key collection.
        final List&lt;Key&gt; keys = generateSamples(hashLimit, sampleSize);

        //Generating our value collection
        final List&lt;Object&gt; values = generateValues(sampleSize);

        final HashMap&lt;Key, Object&gt; map = new HashMap&lt;Key, Object&gt;(initialCapacity, loadFactor);

        final long startPut = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.put(keys.get(i), values.get(i));
        }

        final long endPut = System.nanoTime();

        final long putTime = endPut - startPut;
        final long averagePutTime = putTime/(sampleSize/10);

        System.out.println("Time to map all keys to their values: " + putTime + " ns");
        System.out.println("Average put time per 10 entries: " + averagePutTime + " ns");

        final long startGet = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.get(keys.get(i));
        }

        final long endGet = System.nanoTime();

        final long getTime = endGet - startGet;
        final long averageGetTime = getTime/(sampleSize/10);

        System.out.println("Time to get the value for every key: " + getTime + " ns");
        System.out.println("Average get time per 10 entries: " + averageGetTime + " ns");

        System.out.println("");

        final Result result = 
            new Result(sampleSize, initialCapacity, loadFactor, hashOverload, averagePutTime, averageGetTime, hashLimit);

        results.add(result);

        //Haha, what kind of noob explicitly calls for garbage collection?
        System.gc();

        try {
            Thread.sleep(200);
        } catch(final InterruptedException e) {}

    }

    private static List&lt;Key&gt; generateSamples(final int hashLimit, final int sampleSize) {

        final ArrayList&lt;Key&gt; result = new ArrayList&lt;Key&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Key(i, hashLimit));
        }

        return result;

    }

    private static List&lt;Object&gt; generateValues(final int sampleSize) {

        final ArrayList&lt;Object&gt; result = new ArrayList&lt;Object&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Object());
        }

        return result;

    }

    private static class Key {

        private final int hashCode;
        private final int id;

        Key(final int id, final int hashLimit) {

            //Equals implies same hashCode if limit is the same
            //Same hashCode doesn't necessarily implies equals

            this.id = id;
            this.hashCode = id % hashLimit;

        }

        @Override
        public int hashCode() {
            return hashCode;
        }

        @Override
        public boolean equals(final Object o) {
            return ((Key)o).id == this.id;
        }

    }

    static class Result implements Comparable&lt;Result&gt; {

        final int sampleSize;
        final int initialCapacity;
        final float loadFactor;
        final double hashOverloadPercentage;
        final long averagePutTime;
        final long averageGetTime;
        final int hashLimit;

        Result(final int sampleSize, final int initialCapacity, final float loadFactor, 
                final double hashOverloadPercentage, final long averagePutTime, 
                final long averageGetTime, final int hashLimit) {

            this.sampleSize = sampleSize;
            this.initialCapacity = initialCapacity;
            this.loadFactor = loadFactor;
            this.hashOverloadPercentage = hashOverloadPercentage;
            this.averagePutTime = averagePutTime;
            this.averageGetTime = averageGetTime;
            this.hashLimit = hashLimit;

        }

        @Override
        public int compareTo(final Result o) {

            final long putDiff = o.averagePutTime - this.averagePutTime;
            final long getDiff = o.averageGetTime - this.averageGetTime;

            return (int)(putDiff + getDiff);
        }

        void printSummary() {

            System.out.println("" + averagePutTime + " ns per 10 puts, "
                + averageGetTime + " ns per 10 gets, for a load factor of "
                + loadFactor + ", initial capacity of " + initialCapacity
                + " for " + sampleSize + " mappings and " + hashOverloadPercentage 
                + "% hash code overload.");

        }

    }

}
******************************
Normalized:
******************************
Original:
package hashmaptest;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

public class HashMapTest {

    private static final List&lt;Result&gt; results = new ArrayList&lt;Result&gt;();

    public static void main(String[] args) throws IOException {

        //First entry of each array is the sample collection size, subsequent entries
        //are the hash limits
        final int[][] sampleSizesAndHashLimits = new int[][] {
            {100, 50, 90, 100},
            {1000, 500, 900, 990, 1000},
            {100000, 10000, 90000, 99000, 100000}
        };
        final double[] initialCapacityFactors = new double[] {0.5, 0.75, 1.0, 1.25, 1.5, 2.0};
        final float[] loadFactors = new float[] {0.5f, 0.75f, 1.0f, 1.25f};

        //Doing a warmup run to eliminate JIT influence
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        results.clear();

        //Now for the real thing...
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        Collections.sort(results);

        for(final Result result : results) {
            result.printSummary();
        }

//      ResultVisualizer.visualizeResults(results);

    }

    private static void runTest(final int hashLimit, final int sampleSize,
            final double initCapacityFactor, final float loadFactor) {

        final int initialCapacity = (int)(sampleSize * initCapacityFactor);

        System.out.println("Running test for a sample collection of size " + sampleSize 
            + ", an initial capacity of " + initialCapacity + ", a load factor of "
            + loadFactor + " and keys with a hash code limited to " + hashLimit);
        System.out.println("====================");

        double hashOverload = (((double)sampleSize/hashLimit) - 1.0) * 100.0;

        System.out.println("Hash code overload: " + hashOverload + "%");

        //Generating our sample key collection.
        final List&lt;Key&gt; keys = generateSamples(hashLimit, sampleSize);

        //Generating our value collection
        final List&lt;Object&gt; values = generateValues(sampleSize);

        final HashMap&lt;Key, Object&gt; map = new HashMap&lt;Key, Object&gt;(initialCapacity, loadFactor);

        final long startPut = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.put(keys.get(i), values.get(i));
        }

        final long endPut = System.nanoTime();

        final long putTime = endPut - startPut;
        final long averagePutTime = putTime/(sampleSize/10);

        System.out.println("Time to map all keys to their values: " + putTime + " ns");
        System.out.println("Average put time per 10 entries: " + averagePutTime + " ns");

        final long startGet = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.get(keys.get(i));
        }

        final long endGet = System.nanoTime();

        final long getTime = endGet - startGet;
        final long averageGetTime = getTime/(sampleSize/10);

        System.out.println("Time to get the value for every key: " + getTime + " ns");
        System.out.println("Average get time per 10 entries: " + averageGetTime + " ns");

        System.out.println("");

        final Result result = 
            new Result(sampleSize, initialCapacity, loadFactor, hashOverload, averagePutTime, averageGetTime, hashLimit);

        results.add(result);

        //Haha, what kind of noob explicitly calls for garbage collection?
        System.gc();

        try {
            Thread.sleep(200);
        } catch(final InterruptedException e) {}

    }

    private static List&lt;Key&gt; generateSamples(final int hashLimit, final int sampleSize) {

        final ArrayList&lt;Key&gt; result = new ArrayList&lt;Key&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Key(i, hashLimit));
        }

        return result;

    }

    private static List&lt;Object&gt; generateValues(final int sampleSize) {

        final ArrayList&lt;Object&gt; result = new ArrayList&lt;Object&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Object());
        }

        return result;

    }

    private static class Key {

        private final int hashCode;
        private final int id;

        Key(final int id, final int hashLimit) {

            //Equals implies same hashCode if limit is the same
            //Same hashCode doesn't necessarily implies equals

            this.id = id;
            this.hashCode = id % hashLimit;

        }

        @Override
        public int hashCode() {
            return hashCode;
        }

        @Override
        public boolean equals(final Object o) {
            return ((Key)o).id == this.id;
        }

    }

    static class Result implements Comparable&lt;Result&gt; {

        final int sampleSize;
        final int initialCapacity;
        final float loadFactor;
        final double hashOverloadPercentage;
        final long averagePutTime;
        final long averageGetTime;
        final int hashLimit;

        Result(final int sampleSize, final int initialCapacity, final float loadFactor, 
                final double hashOverloadPercentage, final long averagePutTime, 
                final long averageGetTime, final int hashLimit) {

            this.sampleSize = sampleSize;
            this.initialCapacity = initialCapacity;
            this.loadFactor = loadFactor;
            this.hashOverloadPercentage = hashOverloadPercentage;
            this.averagePutTime = averagePutTime;
            this.averageGetTime = averageGetTime;
            this.hashLimit = hashLimit;

        }

        @Override
        public int compareTo(final Result o) {

            final long putDiff = o.averagePutTime - this.averagePutTime;
            final long getDiff = o.averageGetTime - this.averageGetTime;

            return (int)(putDiff + getDiff);
        }

        void printSummary() {

            System.out.println("" + averagePutTime + " ns per 10 puts, "
                + averageGetTime + " ns per 10 gets, for a load factor of "
                + loadFactor + ", initial capacity of " + initialCapacity
                + " for " + sampleSize + " mappings and " + hashOverloadPercentage 
                + "% hash code overload.");

        }

    }

}
******************************
Normalized:
package hashmaptest;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

public class HashMapTest {

    private static final List&lt;Result&gt; results = new ArrayList&lt;Result&gt;();

    public static void main(String[] args) throws IOException {

        //First entry of each array is the sample collection size, subsequent entries
        //are the hash limits
        final int[][] sampleSizesAndHashLimits = new int[][] {
            {100, 50, 90, 100},
            {1000, 500, 900, 990, 1000},
            {100000, 10000, 90000, 99000, 100000}
        };
        final double[] initialCapacityFactors = new double[] {0.5, 0.75, 1.0, 1.25, 1.5, 2.0};
        final float[] loadFactors = new float[] {0.5f, 0.75f, 1.0f, 1.25f};

        //Doing a warmup run to eliminate JIT influence
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        results.clear();

        //Now for the real thing...
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        Collections.sort(results);

        for(final Result result : results) {
            result.printSummary();
        }

//      ResultVisualizer.visualizeResults(results);

    }

    private static void runTest(final int hashLimit, final int sampleSize,
            final double initCapacityFactor, final float loadFactor) {

        final int initialCapacity = (int)(sampleSize * initCapacityFactor);

        System.out.println("Running test for a sample collection of size " + sampleSize 
            + ", an initial capacity of " + initialCapacity + ", a load factor of "
            + loadFactor + " and keys with a hash code limited to " + hashLimit);
        System.out.println("====================");

        double hashOverload = (((double)sampleSize/hashLimit) - 1.0) * 100.0;

        System.out.println("Hash code overload: " + hashOverload + "%");

        //Generating our sample key collection.
        final List&lt;Key&gt; keys = generateSamples(hashLimit, sampleSize);

        //Generating our value collection
        final List&lt;Object&gt; values = generateValues(sampleSize);

        final HashMap&lt;Key, Object&gt; map = new HashMap&lt;Key, Object&gt;(initialCapacity, loadFactor);

        final long startPut = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.put(keys.get(i), values.get(i));
        }

        final long endPut = System.nanoTime();

        final long putTime = endPut - startPut;
        final long averagePutTime = putTime/(sampleSize/10);

        System.out.println("Time to map all keys to their values: " + putTime + " ns");
        System.out.println("Average put time per 10 entries: " + averagePutTime + " ns");

        final long startGet = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.get(keys.get(i));
        }

        final long endGet = System.nanoTime();

        final long getTime = endGet - startGet;
        final long averageGetTime = getTime/(sampleSize/10);

        System.out.println("Time to get the value for every key: " + getTime + " ns");
        System.out.println("Average get time per 10 entries: " + averageGetTime + " ns");

        System.out.println("");

        final Result result = 
            new Result(sampleSize, initialCapacity, loadFactor, hashOverload, averagePutTime, averageGetTime, hashLimit);

        results.add(result);

        //Haha, what kind of noob explicitly calls for garbage collection?
        System.gc();

        try {
            Thread.sleep(200);
        } catch(final InterruptedException e) {}

    }

    private static List&lt;Key&gt; generateSamples(final int hashLimit, final int sampleSize) {

        final ArrayList&lt;Key&gt; result = new ArrayList&lt;Key&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Key(i, hashLimit));
        }

        return result;

    }

    private static List&lt;Object&gt; generateValues(final int sampleSize) {

        final ArrayList&lt;Object&gt; result = new ArrayList&lt;Object&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Object());
        }

        return result;

    }

    private static class Key {

        private final int hashCode;
        private final int id;

        Key(final int id, final int hashLimit) {

            //Equals implies same hashCode if limit is the same
            //Same hashCode doesn't necessarily implies equals

            this.id = id;
            this.hashCode = id % hashLimit;

        }

        @Override
        public int hashCode() {
            return hashCode;
        }

        @Override
        public boolean equals(final Object o) {
            return ((Key)o).id == this.id;
        }

    }

    static class Result implements Comparable&lt;Result&gt; {

        final int sampleSize;
        final int initialCapacity;
        final float loadFactor;
        final double hashOverloadPercentage;
        final long averagePutTime;
        final long averageGetTime;
        final int hashLimit;

        Result(final int sampleSize, final int initialCapacity, final float loadFactor, 
                final double hashOverloadPercentage, final long averagePutTime, 
                final long averageGetTime, final int hashLimit) {

            this.sampleSize = sampleSize;
            this.initialCapacity = initialCapacity;
            this.loadFactor = loadFactor;
            this.hashOverloadPercentage = hashOverloadPercentage;
            this.averagePutTime = averagePutTime;
            this.averageGetTime = averageGetTime;
            this.hashLimit = hashLimit;

        }

        @Override
        public int compareTo(final Result o) {

            final long putDiff = o.averagePutTime - this.averagePutTime;
            final long getDiff = o.averageGetTime - this.averageGetTime;

            return (int)(putDiff + getDiff);
        }

        void printSummary() {

            System.out.println("" + averagePutTime + " ns per 10 puts, "
                + averageGetTime + " ns per 10 gets, for a load factor of "
                + loadFactor + ", initial capacity of " + initialCapacity
                + " for " + sampleSize + " mappings and " + hashOverloadPercentage 
                + "% hash code overload.");

        }

    }

}
******************************
Original:
StringBuilder sb = new StringBuilder();
for (int i = 0; i &lt; 500; i ++) {
    sb.append(i);
}
******************************
Normalized:
******************************
Original:
StringBuilder sb = new StringBuilder();
for (int i = 0; i &lt; 500; i ++) {
    sb.append(i);
}
******************************
Normalized:
StringBuilder sb = new StringBuilder();
for (int i = 0; i &lt; 500; i ++) {
    sb.append(i);
}
******************************
Original:
arrayList.set(index i,String replaceElement);
******************************
Normalized:
******************************
Original:
arrayList.set(index i,String replaceElement);
******************************
Normalized:
arrayList.set(index i,String replaceElement);
******************************
Original:
&lt;properties&gt;
  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
******************************
Normalized:
******************************
Original:
&lt;properties&gt;
  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
******************************
Normalized:
&lt;properties&gt;
  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
******************************
Original:
public class RetryTest {
    public class Retry implements TestRule {
        private int retryCount;

        public Retry(int retryCount) {
            this.retryCount = retryCount;
        }

        public Statement apply(Statement base, Description description) {
            return statement(base, description);
        }

        private Statement statement(final Statement base, final Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    Throwable caughtThrowable = null;

                    // implement retry logic here
                    for (int i = 0; i &lt; retryCount; i++) {
                        try {
                            base.evaluate();
                            return;
                        } catch (Throwable t) {
                            caughtThrowable = t;
                            System.err.println(description.getDisplayName() + ": run " + (i+1) + " failed");
                        }
                    }
                    System.err.println(description.getDisplayName() + ": giving up after " + retryCount + " failures");
                    throw caughtThrowable;
                }
            };
        }
    }

    @Rule
    public Retry retry = new Retry(3);

    @Test
    public void test1() {
    }

    @Test
    public void test2() {
        Object o = null;
        o.equals("foo");
    }
}
******************************
Normalized:
******************************
Original:
public class RetryTest {
    public class Retry implements TestRule {
        private int retryCount;

        public Retry(int retryCount) {
            this.retryCount = retryCount;
        }

        public Statement apply(Statement base, Description description) {
            return statement(base, description);
        }

        private Statement statement(final Statement base, final Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    Throwable caughtThrowable = null;

                    // implement retry logic here
                    for (int i = 0; i &lt; retryCount; i++) {
                        try {
                            base.evaluate();
                            return;
                        } catch (Throwable t) {
                            caughtThrowable = t;
                            System.err.println(description.getDisplayName() + ": run " + (i+1) + " failed");
                        }
                    }
                    System.err.println(description.getDisplayName() + ": giving up after " + retryCount + " failures");
                    throw caughtThrowable;
                }
            };
        }
    }

    @Rule
    public Retry retry = new Retry(3);

    @Test
    public void test1() {
    }

    @Test
    public void test2() {
        Object o = null;
        o.equals("foo");
    }
}
******************************
Normalized:
public class RetryTest {
    public class Retry implements TestRule {
        private int retryCount;

        public Retry(int retryCount) {
            this.retryCount = retryCount;
        }

        public Statement apply(Statement base, Description description) {
            return statement(base, description);
        }

        private Statement statement(final Statement base, final Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    Throwable caughtThrowable = null;

                    // implement retry logic here
                    for (int i = 0; i &lt; retryCount; i++) {
                        try {
                            base.evaluate();
                            return;
                        } catch (Throwable t) {
                            caughtThrowable = t;
                            System.err.println(description.getDisplayName() + ": run " + (i+1) + " failed");
                        }
                    }
                    System.err.println(description.getDisplayName() + ": giving up after " + retryCount + " failures");
                    throw caughtThrowable;
                }
            };
        }
    }

    @Rule
    public Retry retry = new Retry(3);

    @Test
    public void test1() {
    }

    @Test
    public void test2() {
        Object o = null;
        o.equals("foo");
    }
}
******************************
Original:
Set&lt;Integer&gt; s; //contains your Integers
...
Set&lt;Integer&gt; temp = new Set&lt;Integer&gt;();
for(Integer i : s)
    temp.add(i+1);
s.clear();
s.addAll(temp);
******************************
Normalized:
******************************
Original:
Set&lt;Integer&gt; s; //contains your Integers
...
Set&lt;Integer&gt; temp = new Set&lt;Integer&gt;();
for(Integer i : s)
    temp.add(i+1);
s.clear();
s.addAll(temp);
******************************
Normalized:
Set&lt;Integer&gt; s; //contains your Integers
...
Set&lt;Integer&gt; temp = new Set&lt;Integer&gt;();
for(Integer i : s)
    temp.add(i+1);
s.clear();
s.addAll(temp);
******************************
Original:
Future&lt;T&gt; future = ConcurrentUtils.constantFuture(T myValue);
******************************
Normalized:
******************************
Original:
Future&lt;T&gt; future = ConcurrentUtils.constantFuture(T myValue);
******************************
Normalized:
Future&lt;T&gt; future = ConcurrentUtils.constantFuture(T myValue);
******************************
Original:
final EditText edittext = (EditText) findViewById(R.id.edittext);
edittext.setOnKeyListener(new View.OnKeyListener() {
    public boolean onKey(View v, int keyCode, KeyEvent event) {
        if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; keyCode == KeyEvent.KEYCODE_ENTER) {
            Toast.makeText(HelloFormStuff.this, edittext.getText(), Toast.LENGTH_SHORT).show();
            return true;
        }
        return false;
    }
});
******************************
Normalized:
******************************
Original:
final EditText edittext = (EditText) findViewById(R.id.edittext);
edittext.setOnKeyListener(new View.OnKeyListener() {
    public boolean onKey(View v, int keyCode, KeyEvent event) {
        if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; keyCode == KeyEvent.KEYCODE_ENTER) {
            Toast.makeText(HelloFormStuff.this, edittext.getText(), Toast.LENGTH_SHORT).show();
            return true;
        }
        return false;
    }
});
******************************
Normalized:
final EditText edittext = (EditText) findViewById(R.id.edittext);
edittext.setOnKeyListener(new View.OnKeyListener() {
    public boolean onKey(View v, int keyCode, KeyEvent event) {
        if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; keyCode == KeyEvent.KEYCODE_ENTER) {
            Toast.makeText(HelloFormStuff.this, edittext.getText(), Toast.LENGTH_SHORT).show();
            return true;
        }
        return false;
    }
});
******************************
Original:
&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;otherOutputDir&lt;/id&gt;
        &lt;build&gt;
            &lt;directory&gt;yourDirectory&lt;/directory&gt;
        &lt;/build&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
******************************
Normalized:
******************************
Original:
&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;otherOutputDir&lt;/id&gt;
        &lt;build&gt;
            &lt;directory&gt;yourDirectory&lt;/directory&gt;
        &lt;/build&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
******************************
Normalized:
&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;otherOutputDir&lt;/id&gt;
        &lt;build&gt;
            &lt;directory&gt;yourDirectory&lt;/directory&gt;
        &lt;/build&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
******************************
Original:
...10110110
******************************
Normalized:
******************************
Original:
...10110110
******************************
Normalized:
...10110110
******************************
Original:
@ManyToMany(fetch = FetchType.EAGER)
******************************
Normalized:
******************************
Original:
@ManyToMany(fetch = FetchType.EAGER)
******************************
Normalized:
@ManyToMany(fetch = FetchType.EAGER)
******************************
Original:
(IDLjava/lang/Thread;)Ljava/lang/Object;
******************************
Normalized:
******************************
Original:
(IDLjava/lang/Thread;)Ljava/lang/Object;
******************************
Normalized:
(IDLjava/lang/Thread;)Ljava/lang/Object;
******************************
Original:
$ mvn dependency:copy-dependencies -DoutputDirectory=OUTPUT_DIR
******************************
Normalized:
******************************
Original:
$ mvn dependency:copy-dependencies -DoutputDirectory=OUTPUT_DIR
******************************
Normalized:
$ mvn dependency:copy-dependencies -DoutputDirectory=OUTPUT_DIR
******************************
Original:
(?:\u{D A}|(?!\u{D A})[\u{A}-\u{D}\u{85}\u{2028}\u{2029}]
******************************
Normalized:
******************************
Original:
(?:\u{D A}|(?!\u{D A})[\u{A}-\u{D}\u{85}\u{2028}\u{2029}]
******************************
Normalized:
(?:\u{D A}|(?!\u{D A})[\u{A}-\u{D}\u{85}\u{2028}\u{2029}]
******************************
Original:
module org.example.foo {
    requires java.xml.bind;
}
******************************
Normalized:
******************************
Original:
module org.example.foo {
    requires java.xml.bind;
}
******************************
Normalized:
module org.example.foo {
    requires java.xml.bind;
}
******************************
Original:
public class CompletionServiceTest {

        class CalcResult {
             long result ;

             CalcResult(long l) {
                 result = l;
             }
        }

        class CallableTask implements Callable&lt;CalcResult&gt; {
            String taskName ;
            long  input1 ;
            int input2 ;

            CallableTask(String name , long v1 , int v2 ) {
                taskName = name;
                input1 = v1;
                input2 = v2 ;
            }

            public CalcResult call() throws Exception {
                System.out.println(" Task " + taskName + " Started -----");
                for(int i=0;i&lt;input2 ;i++) {
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        System.out.println(" Task " + taskName + " Interrupted !! ");
                        e.printStackTrace();
                    }
                    input1 += i;
                }
                System.out.println(" Task " + taskName + " Completed @@@@@@");
                return new CalcResult(input1) ;
            }

        }

        public void test(){
            ExecutorService taskExecutor = Executors.newFixedThreadPool(3);
            CompletionService&lt;CalcResult&gt; taskCompletionService = new ExecutorCompletionService&lt;CalcResult&gt;(taskExecutor);

            int submittedTasks = 5;
            for (int i=0;i&lt; submittedTasks;i++) {
                taskCompletionService.submit(new CallableTask (
                        String.valueOf(i), 
                            (i * 10), 
                            ((i * 10) + 10  )
                        ));
               System.out.println("Task " + String.valueOf(i) + "subitted");
            }
            for (int tasksHandled=0;tasksHandled&lt;submittedTasks;tasksHandled++) {
                try {
                    System.out.println("trying to take from Completion service");
                    Future&lt;CalcResult&gt; result = taskCompletionService.take();
                    System.out.println("result for a task availble in queue.Trying to get()");
                    // above call blocks till atleast one task is completed and results availble for it
                    // but we dont have to worry which one

                    // process the result here by doing result.get()
                    CalcResult l = result.get();
                    System.out.println("Task " + String.valueOf(tasksHandled) + "Completed - results obtained : " + String.valueOf(l.result));

                } catch (InterruptedException e) {
                    // Something went wrong with a task submitted
                    System.out.println("Error Interrupted exception");
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    // Something went wrong with the result
                    e.printStackTrace();
                    System.out.println("Error get() threw exception");
                }
            }
        }
    }
******************************
Normalized:
******************************
Original:
public class CompletionServiceTest {

        class CalcResult {
             long result ;

             CalcResult(long l) {
                 result = l;
             }
        }

        class CallableTask implements Callable&lt;CalcResult&gt; {
            String taskName ;
            long  input1 ;
            int input2 ;

            CallableTask(String name , long v1 , int v2 ) {
                taskName = name;
                input1 = v1;
                input2 = v2 ;
            }

            public CalcResult call() throws Exception {
                System.out.println(" Task " + taskName + " Started -----");
                for(int i=0;i&lt;input2 ;i++) {
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        System.out.println(" Task " + taskName + " Interrupted !! ");
                        e.printStackTrace();
                    }
                    input1 += i;
                }
                System.out.println(" Task " + taskName + " Completed @@@@@@");
                return new CalcResult(input1) ;
            }

        }

        public void test(){
            ExecutorService taskExecutor = Executors.newFixedThreadPool(3);
            CompletionService&lt;CalcResult&gt; taskCompletionService = new ExecutorCompletionService&lt;CalcResult&gt;(taskExecutor);

            int submittedTasks = 5;
            for (int i=0;i&lt; submittedTasks;i++) {
                taskCompletionService.submit(new CallableTask (
                        String.valueOf(i), 
                            (i * 10), 
                            ((i * 10) + 10  )
                        ));
               System.out.println("Task " + String.valueOf(i) + "subitted");
            }
            for (int tasksHandled=0;tasksHandled&lt;submittedTasks;tasksHandled++) {
                try {
                    System.out.println("trying to take from Completion service");
                    Future&lt;CalcResult&gt; result = taskCompletionService.take();
                    System.out.println("result for a task availble in queue.Trying to get()");
                    // above call blocks till atleast one task is completed and results availble for it
                    // but we dont have to worry which one

                    // process the result here by doing result.get()
                    CalcResult l = result.get();
                    System.out.println("Task " + String.valueOf(tasksHandled) + "Completed - results obtained : " + String.valueOf(l.result));

                } catch (InterruptedException e) {
                    // Something went wrong with a task submitted
                    System.out.println("Error Interrupted exception");
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    // Something went wrong with the result
                    e.printStackTrace();
                    System.out.println("Error get() threw exception");
                }
            }
        }
    }
******************************
Normalized:
public class CompletionServiceTest {

        class CalcResult {
             long result ;

             CalcResult(long l) {
                 result = l;
             }
        }

        class CallableTask implements Callable&lt;CalcResult&gt; {
            String taskName ;
            long  input1 ;
            int input2 ;

            CallableTask(String name , long v1 , int v2 ) {
                taskName = name;
                input1 = v1;
                input2 = v2 ;
            }

            public CalcResult call() throws Exception {
                System.out.println(" Task " + taskName + " Started -----");
                for(int i=0;i&lt;input2 ;i++) {
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        System.out.println(" Task " + taskName + " Interrupted !! ");
                        e.printStackTrace();
                    }
                    input1 += i;
                }
                System.out.println(" Task " + taskName + " Completed @@@@@@");
                return new CalcResult(input1) ;
            }

        }

        public void test(){
            ExecutorService taskExecutor = Executors.newFixedThreadPool(3);
            CompletionService&lt;CalcResult&gt; taskCompletionService = new ExecutorCompletionService&lt;CalcResult&gt;(taskExecutor);

            int submittedTasks = 5;
            for (int i=0;i&lt; submittedTasks;i++) {
                taskCompletionService.submit(new CallableTask (
                        String.valueOf(i), 
                            (i * 10), 
                            ((i * 10) + 10  )
                        ));
               System.out.println("Task " + String.valueOf(i) + "subitted");
            }
            for (int tasksHandled=0;tasksHandled&lt;submittedTasks;tasksHandled++) {
                try {
                    System.out.println("trying to take from Completion service");
                    Future&lt;CalcResult&gt; result = taskCompletionService.take();
                    System.out.println("result for a task availble in queue.Trying to get()");
                    // above call blocks till atleast one task is completed and results availble for it
                    // but we dont have to worry which one

                    // process the result here by doing result.get()
                    CalcResult l = result.get();
                    System.out.println("Task " + String.valueOf(tasksHandled) + "Completed - results obtained : " + String.valueOf(l.result));

                } catch (InterruptedException e) {
                    // Something went wrong with a task submitted
                    System.out.println("Error Interrupted exception");
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    // Something went wrong with the result
                    e.printStackTrace();
                    System.out.println("Error get() threw exception");
                }
            }
        }
    }
******************************
Original:
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/*")
public class MyApplication extends Application {
    ...
}
******************************
Normalized:
******************************
Original:
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/*")
public class MyApplication extends Application {
    ...
}
******************************
Normalized:
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/*")
public class MyApplication extends Application {
    ...
}
******************************
Original:
List&lt;Integer&gt; idList = students.stream().map(Student::getId).collect(Collectors.toList());
******************************
Normalized:
******************************
Original:
List&lt;Integer&gt; idList = students.stream().map(Student::getId).collect(Collectors.toList());
******************************
Normalized:
List&lt;Integer&gt; idList = students.stream().map(Student::getId).collect(Collectors.toList());
******************************
Original:
Collectors.toMap(p -&gt; p.getLast(), Function.identity())
******************************
Normalized:
******************************
Original:
Collectors.toMap(p -&gt; p.getLast(), Function.identity())
******************************
Normalized:
Collectors.toMap(p -&gt; p.getLast(), Function.identity())
******************************
Original:
for(int k = 0; k &lt; strings.length; k++){
   // something
}
******************************
Normalized:
******************************
Original:
for(int k = 0; k &lt; strings.length; k++){
   // something
}
******************************
Normalized:
for(int k = 0; k &lt; strings.length; k++){
   // something
}
******************************
Original:
public void writeToParcel(Parcel out, int flags) {
    out.writeString(_mac);
    out.writeString(_pan);
    out.writeInt(_band);
    out.writeSerializable(_lqis);
    out.writeTypedList(_devices);
}

private ZigBeeNetwork(Parcel in) {
    _mac = in.readString();
    _pan = in.readString();
    _band = in.readInt();
    _lqis = (ArrayList&lt;Integer&gt;) in.readSerializable();
    in.readTypedList(_devices, ZigBeeDev.CREATOR);
}
******************************
Normalized:
******************************
Original:
public void writeToParcel(Parcel out, int flags) {
    out.writeString(_mac);
    out.writeString(_pan);
    out.writeInt(_band);
    out.writeSerializable(_lqis);
    out.writeTypedList(_devices);
}

private ZigBeeNetwork(Parcel in) {
    _mac = in.readString();
    _pan = in.readString();
    _band = in.readInt();
    _lqis = (ArrayList&lt;Integer&gt;) in.readSerializable();
    in.readTypedList(_devices, ZigBeeDev.CREATOR);
}
******************************
Normalized:
public void writeToParcel(Parcel out, int flags) {
    out.writeString(_mac);
    out.writeString(_pan);
    out.writeInt(_band);
    out.writeSerializable(_lqis);
    out.writeTypedList(_devices);
}

private ZigBeeNetwork(Parcel in) {
    _mac = in.readString();
    _pan = in.readString();
    _band = in.readInt();
    _lqis = (ArrayList&lt;Integer&gt;) in.readSerializable();
    in.readTypedList(_devices, ZigBeeDev.CREATOR);
}
******************************
Original:
@Test(expected=IncorrectArgumentForSetter.class)
public void testSetterForeignWord("") throws Exception {
  card.setForeignWord("");
}
******************************
Normalized:
******************************
Original:
@Test(expected=IncorrectArgumentForSetter.class)
public void testSetterForeignWord("") throws Exception {
  card.setForeignWord("");
}
******************************
Normalized:
@Test(expected=IncorrectArgumentForSetter.class)
public void testSetterForeignWord("") throws Exception {
  card.setForeignWord("");
}
******************************
Original:
jboss-as-7
 |
 |---&gt; standalone
 |      |----&gt; lib
 |      |----&gt; configuration
 |      |----&gt; deployments
 |      
 |---&gt; domain
 |....
******************************
Normalized:
******************************
Original:
jboss-as-7
 |
 |---&gt; standalone
 |      |----&gt; lib
 |      |----&gt; configuration
 |      |----&gt; deployments
 |      
 |---&gt; domain
 |....
******************************
Normalized:
jboss-as-7
 |
 |---&gt; standalone
 |      |----&gt; lib
 |      |----&gt; configuration
 |      |----&gt; deployments
 |      
 |---&gt; domain
 |....
******************************
Original:
@ 16   org.sample.IntStr::inlineSideEffect (25 bytes)   force inline by CompilerOracle
   @ 4   java.lang.StringBuilder::&lt;init&gt; (7 bytes)   inline (hot)
   @ 18   java.lang.StringBuilder::append (8 bytes)   already compiled into a big method
   @ 21   java.lang.StringBuilder::toString (17 bytes)   inline (hot)
******************************
Normalized:
******************************
Original:
@ 16   org.sample.IntStr::inlineSideEffect (25 bytes)   force inline by CompilerOracle
   @ 4   java.lang.StringBuilder::&lt;init&gt; (7 bytes)   inline (hot)
   @ 18   java.lang.StringBuilder::append (8 bytes)   already compiled into a big method
   @ 21   java.lang.StringBuilder::toString (17 bytes)   inline (hot)
******************************
Normalized:
@ 16   org.sample.IntStr::inlineSideEffect (25 bytes)   force inline by CompilerOracle
   @ 4   java.lang.StringBuilder::&lt;init&gt; (7 bytes)   inline (hot)
   @ 18   java.lang.StringBuilder::append (8 bytes)   already compiled into a big method
   @ 21   java.lang.StringBuilder::toString (17 bytes)   inline (hot)
******************************
Original:
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
}
******************************
Normalized:
******************************
Original:
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
}
******************************
Normalized:
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
}
******************************
Original:
@Controller
@RequestMapping(value = "/adminservice")
@Secured("ROLE_ADMIN")
public class AdminServiceController {
******************************
Normalized:
******************************
Original:
@Controller
@RequestMapping(value = "/adminservice")
@Secured("ROLE_ADMIN")
public class AdminServiceController {
******************************
Normalized:
@Controller
@RequestMapping(value = "/adminservice")
@Secured("ROLE_ADMIN")
public class AdminServiceController {
******************************
Original:
public void add(int index, E element)
******************************
Normalized:
******************************
Original:
public void add(int index, E element)
******************************
Normalized:
public void add(int index, E element)
******************************
Original:
dataList = dataList.subList(30, 38 &gt; dataList.size() ? dataList.size() : 38);
******************************
Normalized:
******************************
Original:
dataList = dataList.subList(30, 38 &gt; dataList.size() ? dataList.size() : 38);
******************************
Normalized:
dataList = dataList.subList(30, 38 &gt; dataList.size() ? dataList.size() : 38);
******************************
Original:
String item;

for(int x = 0; x &lt; 10; x++)
{
    // Linear search.
    if(array[x].equals("Item I am looking for"))
    {
       //you've found the item. Let's stop.
       item = array[x];
       break; 
    }
}
******************************
Normalized:
******************************
Original:
String item;

for(int x = 0; x &lt; 10; x++)
{
    // Linear search.
    if(array[x].equals("Item I am looking for"))
    {
       //you've found the item. Let's stop.
       item = array[x];
       break; 
    }
}
******************************
Normalized:
String item;

for(int x = 0; x &lt; 10; x++)
{
    // Linear search.
    if(array[x].equals("Item I am looking for"))
    {
       //you've found the item. Let's stop.
       item = array[x];
       break; 
    }
}
******************************
Original:
public void scheduleAtFixedRate(TimerTask task,
                                long delay,
                                long period)
******************************
Normalized:
******************************
Original:
public void scheduleAtFixedRate(TimerTask task,
                                long delay,
                                long period)
******************************
Normalized:
public void scheduleAtFixedRate(TimerTask task,
                                long delay,
                                long period)
******************************
Original:
@GeneratedValue(strategy = GenerationType.IDENTITY)
******************************
Normalized:
******************************
Original:
@GeneratedValue(strategy = GenerationType.IDENTITY)
******************************
Normalized:
@GeneratedValue(strategy = GenerationType.IDENTITY)
******************************
Original:
ZonedDateTime now = ZonedDateTime.now(ZoneId.of("America/Los_Angeles"));
ZonedDateTime nextRun = now.withHour(5).withMinute(0).withSecond(0);
if(now.compareTo(nextRun) &gt; 0)
    nextRun = nextRun.plusDays(1);

Duration duration = Duration.between(now, nextRun);
long initalDelay = duration.getSeconds();

ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);            
scheduler.scheduleAtFixedRate(new MyRunnableTask(),
    initalDelay,
    TimeUnit.DAYS.toSeconds(1),
    TimeUnit.SECONDS);
******************************
Normalized:
******************************
Original:
ZonedDateTime now = ZonedDateTime.now(ZoneId.of("America/Los_Angeles"));
ZonedDateTime nextRun = now.withHour(5).withMinute(0).withSecond(0);
if(now.compareTo(nextRun) &gt; 0)
    nextRun = nextRun.plusDays(1);

Duration duration = Duration.between(now, nextRun);
long initalDelay = duration.getSeconds();

ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);            
scheduler.scheduleAtFixedRate(new MyRunnableTask(),
    initalDelay,
    TimeUnit.DAYS.toSeconds(1),
    TimeUnit.SECONDS);
******************************
Normalized:
ZonedDateTime now = ZonedDateTime.now(ZoneId.of("America/Los_Angeles"));
ZonedDateTime nextRun = now.withHour(5).withMinute(0).withSecond(0);
if(now.compareTo(nextRun) &gt; 0)
    nextRun = nextRun.plusDays(1);

Duration duration = Duration.between(now, nextRun);
long initalDelay = duration.getSeconds();

ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);            
scheduler.scheduleAtFixedRate(new MyRunnableTask(),
    initalDelay,
    TimeUnit.DAYS.toSeconds(1),
    TimeUnit.SECONDS);
******************************
Original:
\p{L}+
******************************
Normalized:
******************************
Original:
\p{L}+
******************************
Normalized:
\p{L}+
******************************
Original:
Class&lt;?&gt; beanClass = beanDefinition.getClass();
Object bean = beanClass.newInstance();
if (bean instanceof ApplicationContextAware) {
    ((ApplicationContextAware) bean).setApplicationContext(ctx);
}
******************************
Normalized:
******************************
Original:
Class&lt;?&gt; beanClass = beanDefinition.getClass();
Object bean = beanClass.newInstance();
if (bean instanceof ApplicationContextAware) {
    ((ApplicationContextAware) bean).setApplicationContext(ctx);
}
******************************
Normalized:
Class&lt;?&gt; beanClass = beanDefinition.getClass();
Object bean = beanClass.newInstance();
if (bean instanceof ApplicationContextAware) {
    ((ApplicationContextAware) bean).setApplicationContext(ctx);
}
******************************
Original:
Observable
   .from(modifications)
   .flatmap( (data1) -&gt; { 
       return op1(data1)
           ...
           .flatmap( (data2) -&gt; { 
               // I can access data1 here
               return op2(data2);
           })
   });
******************************
Normalized:
******************************
Original:
Observable
   .from(modifications)
   .flatmap( (data1) -&gt; { 
       return op1(data1)
           ...
           .flatmap( (data2) -&gt; { 
               // I can access data1 here
               return op2(data2);
           })
   });
******************************
Normalized:
Observable
   .from(modifications)
   .flatmap( (data1) -&gt; { 
       return op1(data1)
           ...
           .flatmap( (data2) -&gt; { 
               // I can access data1 here
               return op2(data2);
           })
   });
******************************
Original:
class A implements ICallback {
     MyObject o;
     B b = new B(this, someParameter);

     @Override
     public void callback(MyObject o){
           this.o = o;
     }
}

class B {
     ICallback ic;
     B(ICallback ic, someParameter){
         this.ic = ic;
     }

    new Thread(new Runnable(){
         public void run(){
             // some calculation
             ic.callback(myObject)
         }
    }).start(); 
}

interface ICallback{
    public void callback(MyObject o);
}
******************************
Normalized:
******************************
Original:
class A implements ICallback {
     MyObject o;
     B b = new B(this, someParameter);

     @Override
     public void callback(MyObject o){
           this.o = o;
     }
}

class B {
     ICallback ic;
     B(ICallback ic, someParameter){
         this.ic = ic;
     }

    new Thread(new Runnable(){
         public void run(){
             // some calculation
             ic.callback(myObject)
         }
    }).start(); 
}

interface ICallback{
    public void callback(MyObject o);
}
******************************
Normalized:
class A implements ICallback {
     MyObject o;
     B b = new B(this, someParameter);

     @Override
     public void callback(MyObject o){
           this.o = o;
     }
}

class B {
     ICallback ic;
     B(ICallback ic, someParameter){
         this.ic = ic;
     }

    new Thread(new Runnable(){
         public void run(){
             // some calculation
             ic.callback(myObject)
         }
    }).start(); 
}

interface ICallback{
    public void callback(MyObject o);
}
******************************
Original:
&lt;import resource="classpath:spring-config.xml" /&gt;
******************************
Normalized:
******************************
Original:
&lt;import resource="classpath:spring-config.xml" /&gt;
******************************
Normalized:
&lt;import resource="classpath:spring-config.xml" /&gt;
******************************
Original:
Optional&lt;&gt; opt = dao.find();

opt.ifPresentOrElse(obj -&gt; obj.setAvailable(true),
                    () -&gt; logger.error("…"));
******************************
Normalized:
******************************
Original:
Optional&lt;&gt; opt = dao.find();

opt.ifPresentOrElse(obj -&gt; obj.setAvailable(true),
                    () -&gt; logger.error("…"));
******************************
Normalized:
Optional&lt;&gt; opt = dao.find();

opt.ifPresentOrElse(obj -&gt; obj.setAvailable(true),
                    () -&gt; logger.error("…"));
******************************
Original:
PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:*.java");

Path filename = ...;
if (matcher.matches(filename)) {
    System.out.println(filename);
}
******************************
Normalized:
******************************
Original:
PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:*.java");

Path filename = ...;
if (matcher.matches(filename)) {
    System.out.println(filename);
}
******************************
Normalized:
PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:*.java");

Path filename = ...;
if (matcher.matches(filename)) {
    System.out.println(filename);
}
******************************
Original:
final class Either&lt;L,R&gt;
{
    public static &lt;L,R&gt; Either&lt;L,R&gt; left(L value) {
        return new Either&lt;&gt;(Optional.of(value), Optional.empty());
    }
    public static &lt;L,R&gt; Either&lt;L,R&gt; right(R value) {
        return new Either&lt;&gt;(Optional.empty(), Optional.of(value));
    }
    private final Optional&lt;L&gt; left;
    private final Optional&lt;R&gt; right;
    private Either(Optional&lt;L&gt; l, Optional&lt;R&gt; r) {
      left=l;
      right=r;
    }
    public &lt;T&gt; T map(
        Function&lt;? super L, ? extends T&gt; lFunc,
        Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return left.&lt;T&gt;map(lFunc).orElseGet(()-&gt;right.map(rFunc).get());
    }
    public &lt;T&gt; Either&lt;T,R&gt; mapLeft(Function&lt;? super L, ? extends T&gt; lFunc)
    {
        return new Either&lt;&gt;(left.map(lFunc),right);
    }
    public &lt;T&gt; Either&lt;L,T&gt; mapRight(Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return new Either&lt;&gt;(left, right.map(rFunc));
    }
    public void apply(Consumer&lt;? super L&gt; lFunc, Consumer&lt;? super R&gt; rFunc)
    {
        left.ifPresent(lFunc);
        right.ifPresent(rFunc);
    }
}
******************************
Normalized:
******************************
Original:
final class Either&lt;L,R&gt;
{
    public static &lt;L,R&gt; Either&lt;L,R&gt; left(L value) {
        return new Either&lt;&gt;(Optional.of(value), Optional.empty());
    }
    public static &lt;L,R&gt; Either&lt;L,R&gt; right(R value) {
        return new Either&lt;&gt;(Optional.empty(), Optional.of(value));
    }
    private final Optional&lt;L&gt; left;
    private final Optional&lt;R&gt; right;
    private Either(Optional&lt;L&gt; l, Optional&lt;R&gt; r) {
      left=l;
      right=r;
    }
    public &lt;T&gt; T map(
        Function&lt;? super L, ? extends T&gt; lFunc,
        Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return left.&lt;T&gt;map(lFunc).orElseGet(()-&gt;right.map(rFunc).get());
    }
    public &lt;T&gt; Either&lt;T,R&gt; mapLeft(Function&lt;? super L, ? extends T&gt; lFunc)
    {
        return new Either&lt;&gt;(left.map(lFunc),right);
    }
    public &lt;T&gt; Either&lt;L,T&gt; mapRight(Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return new Either&lt;&gt;(left, right.map(rFunc));
    }
    public void apply(Consumer&lt;? super L&gt; lFunc, Consumer&lt;? super R&gt; rFunc)
    {
        left.ifPresent(lFunc);
        right.ifPresent(rFunc);
    }
}
******************************
Normalized:
final class Either&lt;L,R&gt;
{
    public static &lt;L,R&gt; Either&lt;L,R&gt; left(L value) {
        return new Either&lt;&gt;(Optional.of(value), Optional.empty());
    }
    public static &lt;L,R&gt; Either&lt;L,R&gt; right(R value) {
        return new Either&lt;&gt;(Optional.empty(), Optional.of(value));
    }
    private final Optional&lt;L&gt; left;
    private final Optional&lt;R&gt; right;
    private Either(Optional&lt;L&gt; l, Optional&lt;R&gt; r) {
      left=l;
      right=r;
    }
    public &lt;T&gt; T map(
        Function&lt;? super L, ? extends T&gt; lFunc,
        Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return left.&lt;T&gt;map(lFunc).orElseGet(()-&gt;right.map(rFunc).get());
    }
    public &lt;T&gt; Either&lt;T,R&gt; mapLeft(Function&lt;? super L, ? extends T&gt; lFunc)
    {
        return new Either&lt;&gt;(left.map(lFunc),right);
    }
    public &lt;T&gt; Either&lt;L,T&gt; mapRight(Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return new Either&lt;&gt;(left, right.map(rFunc));
    }
    public void apply(Consumer&lt;? super L&gt; lFunc, Consumer&lt;? super R&gt; rFunc)
    {
        left.ifPresent(lFunc);
        right.ifPresent(rFunc);
    }
}
******************************
Original:
Foo[] array = ...;
List&lt;Foo&gt; list = new ArrayList&lt;Foo&gt;(Arrays.asList(array));
******************************
Normalized:
******************************
Original:
Foo[] array = ...;
List&lt;Foo&gt; list = new ArrayList&lt;Foo&gt;(Arrays.asList(array));
******************************
Normalized:
Foo[] array = ...;
List&lt;Foo&gt; list = new ArrayList&lt;Foo&gt;(Arrays.asList(array));
******************************
Original:
first:
for( int i = 0; i &lt; 10; i++) {
  second:
  for(int j = 0; j &lt; 5; j ++ )
  {
    break xxx;
  }
}

third:
for( int a = 0; a &lt; 10; a++) {

}
******************************
Normalized:
******************************
Original:
first:
for( int i = 0; i &lt; 10; i++) {
  second:
  for(int j = 0; j &lt; 5; j ++ )
  {
    break xxx;
  }
}

third:
for( int a = 0; a &lt; 10; a++) {

}
******************************
Normalized:
first:
for( int i = 0; i &lt; 10; i++) {
  second:
  for(int j = 0; j &lt; 5; j ++ )
  {
    break xxx;
  }
}

third:
for( int a = 0; a &lt; 10; a++) {

}
******************************
Original:
private final CompositeDisposable disposables = new CompositeDisposable();


// adding an Observable to the disposable
disposables.add(sampleObservable()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeWith(new DisposableObserver&lt;String&gt;() {
                    @Override
                    public void onComplete() {
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(String value) {
                    }
                }));

    static Observable&lt;String&gt; sampleObservable() {
        return Observable.defer(new Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() {
            @Override
            public ObservableSource&lt;? extends String&gt; call() throws Exception {
                // Do some long running operation
                SystemClock.sleep(2000);
                return Observable.just("one", "two", "three", "four", "five");
            }
        });
    }                


// Using clear will clear all, but can accept new disposable
disposables.clear(); 
// Using dispose will clear all and set isDisposed = true, so it will not accept any new disposable
disposables.dispose();
******************************
Normalized:
******************************
Original:
private final CompositeDisposable disposables = new CompositeDisposable();


// adding an Observable to the disposable
disposables.add(sampleObservable()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeWith(new DisposableObserver&lt;String&gt;() {
                    @Override
                    public void onComplete() {
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(String value) {
                    }
                }));

    static Observable&lt;String&gt; sampleObservable() {
        return Observable.defer(new Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() {
            @Override
            public ObservableSource&lt;? extends String&gt; call() throws Exception {
                // Do some long running operation
                SystemClock.sleep(2000);
                return Observable.just("one", "two", "three", "four", "five");
            }
        });
    }                


// Using clear will clear all, but can accept new disposable
disposables.clear(); 
// Using dispose will clear all and set isDisposed = true, so it will not accept any new disposable
disposables.dispose();
******************************
Normalized:
private final CompositeDisposable disposables = new CompositeDisposable();


// adding an Observable to the disposable
disposables.add(sampleObservable()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeWith(new DisposableObserver&lt;String&gt;() {
                    @Override
                    public void onComplete() {
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(String value) {
                    }
                }));

    static Observable&lt;String&gt; sampleObservable() {
        return Observable.defer(new Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() {
            @Override
            public ObservableSource&lt;? extends String&gt; call() throws Exception {
                // Do some long running operation
                SystemClock.sleep(2000);
                return Observable.just("one", "two", "three", "four", "five");
            }
        });
    }                


// Using clear will clear all, but can accept new disposable
disposables.clear(); 
// Using dispose will clear all and set isDisposed = true, so it will not accept any new disposable
disposables.dispose();
******************************
Original:
public void setShapeValue(int shapeValue){
  if(shapeValue &lt; 100){
    //do something here like throw exception.
  }
}
******************************
Normalized:
******************************
Original:
public void setShapeValue(int shapeValue){
  if(shapeValue &lt; 100){
    //do something here like throw exception.
  }
}
******************************
Normalized:
public void setShapeValue(int shapeValue){
  if(shapeValue &lt; 100){
    //do something here like throw exception.
  }
}
******************************
Original:
[req]
req_extensions = v3_req

[ v3_req ]
subjectAltName=IP:10.0.0.1
# or subjectAltName=DNS:www.example.com
******************************
Normalized:
******************************
Original:
[req]
req_extensions = v3_req

[ v3_req ]
subjectAltName=IP:10.0.0.1
# or subjectAltName=DNS:www.example.com
******************************
Normalized:
[req]
req_extensions = v3_req

[ v3_req ]
subjectAltName=IP:10.0.0.1
# or subjectAltName=DNS:www.example.com
******************************
Original:
List&lt;T&gt; list = Collections.list(enumeration);
******************************
Normalized:
******************************
Original:
List&lt;T&gt; list = Collections.list(enumeration);
******************************
Normalized:
List&lt;T&gt; list = Collections.list(enumeration);
******************************
Original:
public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {
    list.sort(null);
}
******************************
Normalized:
******************************
Original:
public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {
    list.sort(null);
}
******************************
Normalized:
public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {
    list.sort(null);
}
******************************
Original:
public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(
    Function&lt;? super T, ? extends K&gt; keyMapper, 
    Function&lt;? super T, ? extends U&gt; valueMapper) 
{
    return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new);
}
******************************
Normalized:
******************************
Original:
public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(
    Function&lt;? super T, ? extends K&gt; keyMapper, 
    Function&lt;? super T, ? extends U&gt; valueMapper) 
{
    return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new);
}
******************************
Normalized:
public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(
    Function&lt;? super T, ? extends K&gt; keyMapper, 
    Function&lt;? super T, ? extends U&gt; valueMapper) 
{
    return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new);
}
******************************
Original:
&lt;javac ...&gt;
    &lt;compilerarg value="-Xlint"/&gt;
  &lt;/javac&gt;
******************************
Normalized:
******************************
Original:
&lt;javac ...&gt;
    &lt;compilerarg value="-Xlint"/&gt;
  &lt;/javac&gt;
******************************
Normalized:
&lt;javac ...&gt;
    &lt;compilerarg value="-Xlint"/&gt;
  &lt;/javac&gt;
******************************
Original:
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE roles SYSTEM "roles.dtd"&gt;
&lt;roles&gt;
    &lt;role1&gt;User&lt;/role1&gt;
    &lt;role2&gt;Author&lt;/role2&gt;
    &lt;role3&gt;Admin&lt;/role3&gt;
    &lt;role4/&gt;
&lt;/roles&gt;
******************************
Normalized:
******************************
Original:
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE roles SYSTEM "roles.dtd"&gt;
&lt;roles&gt;
    &lt;role1&gt;User&lt;/role1&gt;
    &lt;role2&gt;Author&lt;/role2&gt;
    &lt;role3&gt;Admin&lt;/role3&gt;
    &lt;role4/&gt;
&lt;/roles&gt;
******************************
Normalized:
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE roles SYSTEM "roles.dtd"&gt;
&lt;roles&gt;
    &lt;role1&gt;User&lt;/role1&gt;
    &lt;role2&gt;Author&lt;/role2&gt;
    &lt;role3&gt;Admin&lt;/role3&gt;
    &lt;role4/&gt;
&lt;/roles&gt;
******************************
Original:
if (1 / x &gt; 0)
    // +0 here
else
    // -0 here
******************************
Normalized:
******************************
Original:
if (1 / x &gt; 0)
    // +0 here
else
    // -0 here
******************************
Normalized:
if (1 / x &gt; 0)
    // +0 here
else
    // -0 here
******************************
Original:
log4j.rootLogger=TRACE, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.debugLog=org.apache.log4j.FileAppender
log4j.appender.debugLog.File=logs/debug.log
log4j.appender.debugLog.layout=org.apache.log4j.PatternLayout
log4j.appender.debugLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.reportsLog=org.apache.log4j.FileAppender
log4j.appender.reportsLog.File=logs/reports.log
log4j.appender.reportsLog.layout=org.apache.log4j.PatternLayout
log4j.appender.reportsLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.category.debugLogger=TRACE, debugLog
log4j.additivity.debugLogger=false

log4j.category.reportsLogger=DEBUG, reportsLog
log4j.additivity.reportsLogger=false
******************************
Normalized:
******************************
Original:
log4j.rootLogger=TRACE, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.debugLog=org.apache.log4j.FileAppender
log4j.appender.debugLog.File=logs/debug.log
log4j.appender.debugLog.layout=org.apache.log4j.PatternLayout
log4j.appender.debugLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.reportsLog=org.apache.log4j.FileAppender
log4j.appender.reportsLog.File=logs/reports.log
log4j.appender.reportsLog.layout=org.apache.log4j.PatternLayout
log4j.appender.reportsLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.category.debugLogger=TRACE, debugLog
log4j.additivity.debugLogger=false

log4j.category.reportsLogger=DEBUG, reportsLog
log4j.additivity.reportsLogger=false
******************************
Normalized:
log4j.rootLogger=TRACE, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.debugLog=org.apache.log4j.FileAppender
log4j.appender.debugLog.File=logs/debug.log
log4j.appender.debugLog.layout=org.apache.log4j.PatternLayout
log4j.appender.debugLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.reportsLog=org.apache.log4j.FileAppender
log4j.appender.reportsLog.File=logs/reports.log
log4j.appender.reportsLog.layout=org.apache.log4j.PatternLayout
log4j.appender.reportsLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.category.debugLogger=TRACE, debugLog
log4j.additivity.debugLogger=false

log4j.category.reportsLogger=DEBUG, reportsLog
log4j.additivity.reportsLogger=false
******************************
Original:
@Override
final void forEachWithCancel(Spliterator&lt;P_OUT&gt; spliterator, Sink&lt;P_OUT&gt; sink) {
    do { } while (!sink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(sink));
}
******************************
Normalized:
******************************
Original:
@Override
final void forEachWithCancel(Spliterator&lt;P_OUT&gt; spliterator, Sink&lt;P_OUT&gt; sink) {
    do { } while (!sink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(sink));
}
******************************
Normalized:
@Override
final void forEachWithCancel(Spliterator&lt;P_OUT&gt; spliterator, Sink&lt;P_OUT&gt; sink) {
    do { } while (!sink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(sink));
}
******************************
Original:
IntPredicate neg = x -&gt; x &lt;- x;
System.out.println(neg.test(4));   // false
System.out.println(neg.test(0));   // false
System.out.println(neg.test(-4));  // true
******************************
Normalized:
******************************
Original:
IntPredicate neg = x -&gt; x &lt;- x;
System.out.println(neg.test(4));   // false
System.out.println(neg.test(0));   // false
System.out.println(neg.test(-4));  // true
******************************
Normalized:
IntPredicate neg = x -&gt; x &lt;- x;
System.out.println(neg.test(4));   // false
System.out.println(neg.test(0));   // false
System.out.println(neg.test(-4));  // true
******************************
Original:
Runnable r1=null;
    for(int i=0; i&lt;2; i++) {
        Runnable r2=System::gc;
        if(r1==null) r1=r2;
        else System.out.println(r1==r2? "shared": "unshared");
    }
******************************
Normalized:
******************************
Original:
Runnable r1=null;
    for(int i=0; i&lt;2; i++) {
        Runnable r2=System::gc;
        if(r1==null) r1=r2;
        else System.out.println(r1==r2? "shared": "unshared");
    }
******************************
Normalized:
Runnable r1=null;
    for(int i=0; i&lt;2; i++) {
        Runnable r2=System::gc;
        if(r1==null) r1=r2;
        else System.out.println(r1==r2? "shared": "unshared");
    }
******************************
Original:
char c = /* whatever */;

switch(c) {
    case 'a':
    case 'A':
        //get the 'A' image;
        break;
    case 'b':
    case 'B':
        //get the 'B' image;
        break;
    // (...)
    case 'z':
    case 'Z':
        //get the 'Z' image;
        break;
}
******************************
Normalized:
******************************
Original:
char c = /* whatever */;

switch(c) {
    case 'a':
    case 'A':
        //get the 'A' image;
        break;
    case 'b':
    case 'B':
        //get the 'B' image;
        break;
    // (...)
    case 'z':
    case 'Z':
        //get the 'Z' image;
        break;
}
******************************
Normalized:
char c = /* whatever */;

switch(c) {
    case 'a':
    case 'A':
        //get the 'A' image;
        break;
    case 'b':
    case 'B':
        //get the 'B' image;
        break;
    // (...)
    case 'z':
    case 'Z':
        //get the 'Z' image;
        break;
}
******************************
Original:
mvn -o install
******************************
Normalized:
******************************
Original:
mvn -o install
******************************
Normalized:
mvn -o install
******************************
Original:
InputStream is = entity.getContent();

.... process the input stream ....

is.close();       // releases all resources
******************************
Normalized:
******************************
Original:
InputStream is = entity.getContent();

.... process the input stream ....

is.close();       // releases all resources
******************************
Normalized:
InputStream is = entity.getContent();

.... process the input stream ....

is.close();       // releases all resources
******************************
Original:
public boolean retryingFindClick(By by) {
    boolean result = false;
    int attempts = 0;
    while(attempts &lt; 2) {
        try {
            driver.findElement(by).click();
            result = true;
            break;
        } catch(StaleElementException e) {
        }
        attempts++;
    }
    return result;
}
******************************
Normalized:
******************************
Original:
public boolean retryingFindClick(By by) {
    boolean result = false;
    int attempts = 0;
    while(attempts &lt; 2) {
        try {
            driver.findElement(by).click();
            result = true;
            break;
        } catch(StaleElementException e) {
        }
        attempts++;
    }
    return result;
}
******************************
Normalized:
public boolean retryingFindClick(By by) {
    boolean result = false;
    int attempts = 0;
    while(attempts &lt; 2) {
        try {
            driver.findElement(by).click();
            result = true;
            break;
        } catch(StaleElementException e) {
        }
        attempts++;
    }
    return result;
}
******************************
Original:
public static void main(String[] args) throws SAXException, IOException,
        ParserConfigurationException, TransformerException {

    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory
        .newInstance();
    DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
    Document document = docBuilder.parse(new File("document.xml"));
    doSomething(document.getDocumentElement());
}

public static void doSomething(Node node) {
    // do something with the current node instead of System.out
    System.out.println(node.getNodeName());

    NodeList nodeList = node.getChildNodes();
    for (int i = 0; i &lt; nodeList.getLength(); i++) {
        Node currentNode = nodeList.item(i);
        if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
            //calls this method for all the children which is Element
            doSomething(currentNode);
        }
    }
}
******************************
Normalized:
******************************
Original:
public static void main(String[] args) throws SAXException, IOException,
        ParserConfigurationException, TransformerException {

    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory
        .newInstance();
    DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
    Document document = docBuilder.parse(new File("document.xml"));
    doSomething(document.getDocumentElement());
}

public static void doSomething(Node node) {
    // do something with the current node instead of System.out
    System.out.println(node.getNodeName());

    NodeList nodeList = node.getChildNodes();
    for (int i = 0; i &lt; nodeList.getLength(); i++) {
        Node currentNode = nodeList.item(i);
        if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
            //calls this method for all the children which is Element
            doSomething(currentNode);
        }
    }
}
******************************
Normalized:
public static void main(String[] args) throws SAXException, IOException,
        ParserConfigurationException, TransformerException {

    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory
        .newInstance();
    DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
    Document document = docBuilder.parse(new File("document.xml"));
    doSomething(document.getDocumentElement());
}

public static void doSomething(Node node) {
    // do something with the current node instead of System.out
    System.out.println(node.getNodeName());

    NodeList nodeList = node.getChildNodes();
    for (int i = 0; i &lt; nodeList.getLength(); i++) {
        Node currentNode = nodeList.item(i);
        if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
            //calls this method for all the children which is Element
            doSomething(currentNode);
        }
    }
}
******************************
Original:
List&lt;V&gt; al = new ArrayList&lt;V&gt;(hashMapVar.values());
******************************
Normalized:
******************************
Original:
List&lt;V&gt; al = new ArrayList&lt;V&gt;(hashMapVar.values());
******************************
Normalized:
List&lt;V&gt; al = new ArrayList&lt;V&gt;(hashMapVar.values());
******************************
Original:
List&lt;Foo&gt; list = createItSomehow();
Random random = new Random();
Foo foo = list.get(random.nextInt(list.size()));
******************************
Normalized:
******************************
Original:
List&lt;Foo&gt; list = createItSomehow();
Random random = new Random();
Foo foo = list.get(random.nextInt(list.size()));
******************************
Normalized:
List&lt;Foo&gt; list = createItSomehow();
Random random = new Random();
Foo foo = list.get(random.nextInt(list.size()));
******************************
Original:
void callback(int val) {
    JNIEnv * g_env;
    // double check it's all ok
    int getEnvStat = g_vm-&gt;GetEnv((void **)&amp;g_env, JNI_VERSION_1_6);
    if (getEnvStat == JNI_EDETACHED) {
        std::cout &lt;&lt; "GetEnv: not attached" &lt;&lt; std::endl;
        if (g_vm-&gt;AttachCurrentThread((void **) &amp;g_env, NULL) != 0) {
            std::cout &lt;&lt; "Failed to attach" &lt;&lt; std::endl;
        }
    } else if (getEnvStat == JNI_OK) {
        //
    } else if (getEnvStat == JNI_EVERSION) {
        std::cout &lt;&lt; "GetEnv: version not supported" &lt;&lt; std::endl;
    }

    g_env-&gt;CallVoidMethod(g_obj, g_mid, val);

    if (g_env-&gt;ExceptionCheck()) {
        g_env-&gt;ExceptionDescribe();
    }

    g_vm-&gt;DetachCurrentThread();
}
******************************
Normalized:
******************************
Original:
void callback(int val) {
    JNIEnv * g_env;
    // double check it's all ok
    int getEnvStat = g_vm-&gt;GetEnv((void **)&amp;g_env, JNI_VERSION_1_6);
    if (getEnvStat == JNI_EDETACHED) {
        std::cout &lt;&lt; "GetEnv: not attached" &lt;&lt; std::endl;
        if (g_vm-&gt;AttachCurrentThread((void **) &amp;g_env, NULL) != 0) {
            std::cout &lt;&lt; "Failed to attach" &lt;&lt; std::endl;
        }
    } else if (getEnvStat == JNI_OK) {
        //
    } else if (getEnvStat == JNI_EVERSION) {
        std::cout &lt;&lt; "GetEnv: version not supported" &lt;&lt; std::endl;
    }

    g_env-&gt;CallVoidMethod(g_obj, g_mid, val);

    if (g_env-&gt;ExceptionCheck()) {
        g_env-&gt;ExceptionDescribe();
    }

    g_vm-&gt;DetachCurrentThread();
}
******************************
Normalized:
void callback(int val) {
    JNIEnv * g_env;
    // double check it's all ok
    int getEnvStat = g_vm-&gt;GetEnv((void **)&amp;g_env, JNI_VERSION_1_6);
    if (getEnvStat == JNI_EDETACHED) {
        std::cout &lt;&lt; "GetEnv: not attached" &lt;&lt; std::endl;
        if (g_vm-&gt;AttachCurrentThread((void **) &amp;g_env, NULL) != 0) {
            std::cout &lt;&lt; "Failed to attach" &lt;&lt; std::endl;
        }
    } else if (getEnvStat == JNI_OK) {
        //
    } else if (getEnvStat == JNI_EVERSION) {
        std::cout &lt;&lt; "GetEnv: version not supported" &lt;&lt; std::endl;
    }

    g_env-&gt;CallVoidMethod(g_obj, g_mid, val);

    if (g_env-&gt;ExceptionCheck()) {
        g_env-&gt;ExceptionDescribe();
    }

    g_vm-&gt;DetachCurrentThread();
}
******************************
Original:
&lt;dependency&gt;
    &lt;groupId&gt;postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;version&gt;VERSION&lt;/version&gt;
&lt;/dependency&gt;
******************************
Normalized:
******************************
Original:
&lt;dependency&gt;
    &lt;groupId&gt;postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;version&gt;VERSION&lt;/version&gt;
&lt;/dependency&gt;
******************************
Normalized:
&lt;dependency&gt;
    &lt;groupId&gt;postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;version&gt;VERSION&lt;/version&gt;
&lt;/dependency&gt;
******************************
Original:
byte[] bytes = new byte[10];
Byte[] byteObjects = new Byte[bytes.length];

int i=0;    
// Associating Byte array values with bytes. (byte[] to Byte[])
for(byte b: bytes)
   byteObjects[i++] = b;  // Autoboxing.

....

int j=0;
// Unboxing Byte values. (Byte[] to byte[])
for(Byte b: byteObjects)
    bytes[j++] = b.byteValue();
******************************
Normalized:
******************************
Original:
byte[] bytes = new byte[10];
Byte[] byteObjects = new Byte[bytes.length];

int i=0;    
// Associating Byte array values with bytes. (byte[] to Byte[])
for(byte b: bytes)
   byteObjects[i++] = b;  // Autoboxing.

....

int j=0;
// Unboxing Byte values. (Byte[] to byte[])
for(Byte b: byteObjects)
    bytes[j++] = b.byteValue();
******************************
Normalized:
byte[] bytes = new byte[10];
Byte[] byteObjects = new Byte[bytes.length];

int i=0;    
// Associating Byte array values with bytes. (byte[] to Byte[])
for(byte b: bytes)
   byteObjects[i++] = b;  // Autoboxing.

....

int j=0;
// Unboxing Byte values. (Byte[] to byte[])
for(Byte b: byteObjects)
    bytes[j++] = b.byteValue();
******************************
Original:
val arrayOfZeros = IntArray(size) //equivalent in Java: new int[size]
val numbersFromOne = IntArray(size) { it + 1 }
val myInts = intArrayOf(1, 1, 2, 3, 5, 8, 13, 21)
******************************
Normalized:
******************************
Original:
val arrayOfZeros = IntArray(size) //equivalent in Java: new int[size]
val numbersFromOne = IntArray(size) { it + 1 }
val myInts = intArrayOf(1, 1, 2, 3, 5, 8, 13, 21)
******************************
Normalized:
val arrayOfZeros = IntArray(size) //equivalent in Java: new int[size]
val numbersFromOne = IntArray(size) { it + 1 }
val myInts = intArrayOf(1, 1, 2, 3, 5, 8, 13, 21)
******************************
Original:
&lt;FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:id="@+id/root_view"&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText1"
        android:layout_height="fill_parent"&gt;
    &lt;/EditText&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText2"
        android:layout_height="fill_parent"&gt;
        &lt;requestFocus&gt;&lt;/requestFocus&gt;
    &lt;/EditText&gt;

&lt;/FrameLayout&gt;
******************************
Normalized:
******************************
Original:
&lt;FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:id="@+id/root_view"&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText1"
        android:layout_height="fill_parent"&gt;
    &lt;/EditText&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText2"
        android:layout_height="fill_parent"&gt;
        &lt;requestFocus&gt;&lt;/requestFocus&gt;
    &lt;/EditText&gt;

&lt;/FrameLayout&gt;
******************************
Normalized:
&lt;FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:id="@+id/root_view"&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText1"
        android:layout_height="fill_parent"&gt;
    &lt;/EditText&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText2"
        android:layout_height="fill_parent"&gt;
        &lt;requestFocus&gt;&lt;/requestFocus&gt;
    &lt;/EditText&gt;

&lt;/FrameLayout&gt;
******************************
Original:
public boolean AndSC(int x, int value, int y) {
    return value &gt;= x &amp;&amp; value &lt;= y;
}

public boolean AndNonSC(int x, int value, int y) {
    return value &gt;= x &amp; value &lt;= y;
}
******************************
Normalized:
******************************
Original:
public boolean AndSC(int x, int value, int y) {
    return value &gt;= x &amp;&amp; value &lt;= y;
}

public boolean AndNonSC(int x, int value, int y) {
    return value &gt;= x &amp; value &lt;= y;
}
******************************
Normalized:
public boolean AndSC(int x, int value, int y) {
    return value &gt;= x &amp;&amp; value &lt;= y;
}

public boolean AndNonSC(int x, int value, int y) {
    return value &gt;= x &amp; value &lt;= y;
}
******************************
Original:
&lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt;
******************************
Normalized:
******************************
Original:
&lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt;
******************************
Normalized:
&lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt;
******************************
Original:
sudo apt-get install openjdk-11-jdk
******************************
Normalized:
******************************
Original:
sudo apt-get install openjdk-11-jdk
******************************
Normalized:
sudo apt-get install openjdk-11-jdk
******************************
Original:
@Configuration
@EnableScheduling
public class SpringConfiguration {

    @Bean(destroyMethod = "shutdown")
    public Executor taskScheduler() {
        return Executors.newScheduledThreadPool(5);
    }
    ...
******************************
Normalized:
******************************
Original:
@Configuration
@EnableScheduling
public class SpringConfiguration {

    @Bean(destroyMethod = "shutdown")
    public Executor taskScheduler() {
        return Executors.newScheduledThreadPool(5);
    }
    ...
******************************
Normalized:
@Configuration
@EnableScheduling
public class SpringConfiguration {

    @Bean(destroyMethod = "shutdown")
    public Executor taskScheduler() {
        return Executors.newScheduledThreadPool(5);
    }
    ...
******************************
Original:
@Autowired
private Item&lt;String&gt; strItem; // Injects the stringItem bean

@Autowired
private Item&lt;Integer&gt; intItem; // Injects the integerItem bean
******************************
Normalized:
******************************
Original:
@Autowired
private Item&lt;String&gt; strItem; // Injects the stringItem bean

@Autowired
private Item&lt;Integer&gt; intItem; // Injects the integerItem bean
******************************
Normalized:
@Autowired
private Item&lt;String&gt; strItem; // Injects the stringItem bean

@Autowired
private Item&lt;Integer&gt; intItem; // Injects the integerItem bean
******************************
Original:
Project
| src
| | main
|   | java
|     | [your source code]
|   | resources
|     | META-INF
|       | services
|         | [your service files]
******************************
Normalized:
******************************
Original:
Project
| src
| | main
|   | java
|     | [your source code]
|   | resources
|     | META-INF
|       | services
|         | [your service files]
******************************
Normalized:
Project
| src
| | main
|   | java
|     | [your source code]
|   | resources
|     | META-INF
|       | services
|         | [your service files]
******************************
Original:
import org.springframework.batch.item.ItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("foo-reader")
@Scope("step")
public final class MyReader implements ItemReader&lt;MyData&gt; {
  @Override
  public MyData read() throws Exception {
    //...
  }

  @Value("#{jobParameters['fileName']}")
  public void setFileName(final String name) {
    //...
  }
}
******************************
Normalized:
******************************
Original:
import org.springframework.batch.item.ItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("foo-reader")
@Scope("step")
public final class MyReader implements ItemReader&lt;MyData&gt; {
  @Override
  public MyData read() throws Exception {
    //...
  }

  @Value("#{jobParameters['fileName']}")
  public void setFileName(final String name) {
    //...
  }
}
******************************
Normalized:
import org.springframework.batch.item.ItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("foo-reader")
@Scope("step")
public final class MyReader implements ItemReader&lt;MyData&gt; {
  @Override
  public MyData read() throws Exception {
    //...
  }

  @Value("#{jobParameters['fileName']}")
  public void setFileName(final String name) {
    //...
  }
}
******************************
Original:
Object[] array;
for(Object o : array) { }
Iterable&lt;Object&gt; list;
for(Object o : list) { }
Iterator&lt;Object&gt; iter;
while(iter.hasNext()) { Object o = iter.next(); }
******************************
Normalized:
******************************
Original:
Object[] array;
for(Object o : array) { }
Iterable&lt;Object&gt; list;
for(Object o : list) { }
Iterator&lt;Object&gt; iter;
while(iter.hasNext()) { Object o = iter.next(); }
******************************
Normalized:
Object[] array;
for(Object o : array) { }
Iterable&lt;Object&gt; list;
for(Object o : list) { }
Iterator&lt;Object&gt; iter;
while(iter.hasNext()) { Object o = iter.next(); }
******************************
Original:
import java.text.Normalizer;

public static String stripAccents(String s) 
{
    s = Normalizer.normalize(s, Normalizer.Form.NFD);
    s = s.replaceAll("[\\p{InCombiningDiacriticalMarks}]", "");
    return s;
}
******************************
Normalized:
******************************
Original:
import java.text.Normalizer;

public static String stripAccents(String s) 
{
    s = Normalizer.normalize(s, Normalizer.Form.NFD);
    s = s.replaceAll("[\\p{InCombiningDiacriticalMarks}]", "");
    return s;
}
******************************
Normalized:
import java.text.Normalizer;

public static String stripAccents(String s) 
{
    s = Normalizer.normalize(s, Normalizer.Form.NFD);
    s = s.replaceAll("[\\p{InCombiningDiacriticalMarks}]", "");
    return s;
}
******************************
Original:
public class CustomJsonDateDeserializer extends JsonDeserializer&lt;Date&gt;
{
    @Override
    public Date deserialize(JsonParser jsonParser,
            DeserializationContext deserializationContext) throws IOException, JsonProcessingException {

        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
        String date = jsonParser.getText();
        try {
            return format.parse(date);
        } catch (ParseException e) {
            throw new RuntimeException(e);
        }

    }

}
******************************
Normalized:
******************************
Original:
public class CustomJsonDateDeserializer extends JsonDeserializer&lt;Date&gt;
{
    @Override
    public Date deserialize(JsonParser jsonParser,
            DeserializationContext deserializationContext) throws IOException, JsonProcessingException {

        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
        String date = jsonParser.getText();
        try {
            return format.parse(date);
        } catch (ParseException e) {
            throw new RuntimeException(e);
        }

    }

}
******************************
Normalized:
public class CustomJsonDateDeserializer extends JsonDeserializer&lt;Date&gt;
{
    @Override
    public Date deserialize(JsonParser jsonParser,
            DeserializationContext deserializationContext) throws IOException, JsonProcessingException {

        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
        String date = jsonParser.getText();
        try {
            return format.parse(date);
        } catch (ParseException e) {
            throw new RuntimeException(e);
        }

    }

}
******************************
Original:
00 00 00 00 =&gt; (byte) 0
00 00 00 01 =&gt; (byte) 1
00 00 00 10 =&gt; (byte) 2
...
01 11 11 11 =&gt; (byte) Byte.MAX_VALUE
******************************
Normalized:
******************************
Original:
00 00 00 00 =&gt; (byte) 0
00 00 00 01 =&gt; (byte) 1
00 00 00 10 =&gt; (byte) 2
...
01 11 11 11 =&gt; (byte) Byte.MAX_VALUE
******************************
Normalized:
00 00 00 00 =&gt; (byte) 0
00 00 00 01 =&gt; (byte) 1
00 00 00 10 =&gt; (byte) 2
...
01 11 11 11 =&gt; (byte) Byte.MAX_VALUE
******************************
Original:
!StringUtils.isAlphanumeric(String)
******************************
Normalized:
******************************
Original:
!StringUtils.isAlphanumeric(String)
******************************
Normalized:
!StringUtils.isAlphanumeric(String)
******************************
Original:
#
# Build stage
#
FROM maven:3.6.0-jdk-11-slim AS build
COPY src /home/app/src
COPY pom.xml /home/app
RUN mvn -f /home/app/pom.xml clean package

#
# Package stage
#
FROM openjdk:11-jre-slim
COPY --from=build /home/app/target/demo-0.0.1-SNAPSHOT.jar /usr/local/lib/demo.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","/usr/local/lib/demo.jar"]
******************************
Normalized:
******************************
Original:
#
# Build stage
#
FROM maven:3.6.0-jdk-11-slim AS build
COPY src /home/app/src
COPY pom.xml /home/app
RUN mvn -f /home/app/pom.xml clean package

#
# Package stage
#
FROM openjdk:11-jre-slim
COPY --from=build /home/app/target/demo-0.0.1-SNAPSHOT.jar /usr/local/lib/demo.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","/usr/local/lib/demo.jar"]
******************************
Normalized:
#
# Build stage
#
FROM maven:3.6.0-jdk-11-slim AS build
COPY src /home/app/src
COPY pom.xml /home/app
RUN mvn -f /home/app/pom.xml clean package

#
# Package stage
#
FROM openjdk:11-jre-slim
COPY --from=build /home/app/target/demo-0.0.1-SNAPSHOT.jar /usr/local/lib/demo.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","/usr/local/lib/demo.jar"]
******************************
Original:
set.removeIf(item -&gt; {
    if (!item.qualify())
        return false;
    item.operate();
    return true;
});
******************************
Normalized:
******************************
Original:
set.removeIf(item -&gt; {
    if (!item.qualify())
        return false;
    item.operate();
    return true;
});
******************************
Normalized:
set.removeIf(item -&gt; {
    if (!item.qualify())
        return false;
    item.operate();
    return true;
});
******************************
Original:
List&lt;String&gt; numbers = Arrays.asList("zero", "one", "two");
ListIterator&lt;String&gt; it = numbers.listIterator();
while (it.hasNext()) {
    System.out.println(it.nextIndex() + " " + it.next());
}
******************************
Normalized:
******************************
Original:
List&lt;String&gt; numbers = Arrays.asList("zero", "one", "two");
ListIterator&lt;String&gt; it = numbers.listIterator();
while (it.hasNext()) {
    System.out.println(it.nextIndex() + " " + it.next());
}
******************************
Normalized:
List&lt;String&gt; numbers = Arrays.asList("zero", "one", "two");
ListIterator&lt;String&gt; it = numbers.listIterator();
while (it.hasNext()) {
    System.out.println(it.nextIndex() + " " + it.next());
}
******************************
Original:
public class MyAdapter extends Adapter {
     private Context context;

     public MyAdapter(Context context) {
          this.context = context;     
     }

     public View getView(...){
         View v;
         v.setOnClickListener(new OnClickListener() {
             void onClick() {
                 context.startActivity(...);
             }
         });
     }
}
******************************
Normalized:
******************************
Original:
public class MyAdapter extends Adapter {
     private Context context;

     public MyAdapter(Context context) {
          this.context = context;     
     }

     public View getView(...){
         View v;
         v.setOnClickListener(new OnClickListener() {
             void onClick() {
                 context.startActivity(...);
             }
         });
     }
}
******************************
Normalized:
public class MyAdapter extends Adapter {
     private Context context;

     public MyAdapter(Context context) {
          this.context = context;     
     }

     public View getView(...){
         View v;
         v.setOnClickListener(new OnClickListener() {
             void onClick() {
                 context.startActivity(...);
             }
         });
     }
}
******************************
Original:
sudo apt-get install openjdk-11-jdk
******************************
Normalized:
******************************
Original:
sudo apt-get install openjdk-11-jdk
******************************
Normalized:
sudo apt-get install openjdk-11-jdk
******************************
Original:
double[] target = new double[doubles.size()];
 for (int i = 0; i &lt; target.length; i++) {
    target[i] = doubles.get(i).doubleValue();  // java 1.4 style
    // or:
    target[i] = doubles.get(i);                // java 1.5+ style (outboxing)
 }
******************************
Normalized:
******************************
Original:
double[] target = new double[doubles.size()];
 for (int i = 0; i &lt; target.length; i++) {
    target[i] = doubles.get(i).doubleValue();  // java 1.4 style
    // or:
    target[i] = doubles.get(i);                // java 1.5+ style (outboxing)
 }
******************************
Normalized:
double[] target = new double[doubles.size()];
 for (int i = 0; i &lt; target.length; i++) {
    target[i] = doubles.get(i).doubleValue();  // java 1.4 style
    // or:
    target[i] = doubles.get(i);                // java 1.5+ style (outboxing)
 }
******************************
Original:
List&lt;Email&gt; findByEmailIdInAndPincodeIn(List&lt;String&gt; emails, List&lt;String&gt; pinCodes);
******************************
Normalized:
******************************
Original:
List&lt;Email&gt; findByEmailIdInAndPincodeIn(List&lt;String&gt; emails, List&lt;String&gt; pinCodes);
******************************
Normalized:
List&lt;Email&gt; findByEmailIdInAndPincodeIn(List&lt;String&gt; emails, List&lt;String&gt; pinCodes);
******************************
Original:
.andExpect(jsonPath("$.password").doesNotExist())
******************************
Normalized:
******************************
Original:
.andExpect(jsonPath("$.password").doesNotExist())
******************************
Normalized:
.andExpect(jsonPath("$.password").doesNotExist())
******************************
Original:
class SomethingSyncd {
    @Synchronized fun syncFoo() {

    }

    val myLock = Any()

    fun foo() {
        synchronized(myLock) {
            // ... code
        }
    }

    @Volatile var thing = mapOf(...)
}
******************************
Normalized:
******************************
Original:
class SomethingSyncd {
    @Synchronized fun syncFoo() {

    }

    val myLock = Any()

    fun foo() {
        synchronized(myLock) {
            // ... code
        }
    }

    @Volatile var thing = mapOf(...)
}
******************************
Normalized:
class SomethingSyncd {
    @Synchronized fun syncFoo() {

    }

    val myLock = Any()

    fun foo() {
        synchronized(myLock) {
            // ... code
        }
    }

    @Volatile var thing = mapOf(...)
}
******************************
Original:
private fun &lt;T&gt; anyObject(): T {
    Mockito.anyObject&lt;T&gt;()
    return uninitialized()
}

private fun &lt;T&gt; uninitialized(): T = null as T

@Test
fun myTest() {
    `when`(mockedBackend).login(anyObject())).thenAnswer { ... }
}
******************************
Normalized:
******************************
Original:
private fun &lt;T&gt; anyObject(): T {
    Mockito.anyObject&lt;T&gt;()
    return uninitialized()
}

private fun &lt;T&gt; uninitialized(): T = null as T

@Test
fun myTest() {
    `when`(mockedBackend).login(anyObject())).thenAnswer { ... }
}
******************************
Normalized:
private fun &lt;T&gt; anyObject(): T {
    Mockito.anyObject&lt;T&gt;()
    return uninitialized()
}

private fun &lt;T&gt; uninitialized(): T = null as T

@Test
fun myTest() {
    `when`(mockedBackend).login(anyObject())).thenAnswer { ... }
}
******************************
Original:
public final class SupplierUtils {
    private SupplierUtils() {
    }

    public static &lt;T&gt; Supplier&lt;T&gt; wrap(Callable&lt;T&gt; callable) {
        return () -&gt; {
            try {
                return callable.call();
            }
            catch (RuntimeException e) {
                throw e;
            }
            catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
}

public class JdbcConnectionPool extends ObjectPool&lt;Connection&gt; {

    public JdbcConnectionPool(int maxConnections, String url) {
        super(SupplierUtils.wrap(() -&gt; DriverManager.getConnection(url)), maxConnections);
    }
}
******************************
Normalized:
******************************
Original:
public final class SupplierUtils {
    private SupplierUtils() {
    }

    public static &lt;T&gt; Supplier&lt;T&gt; wrap(Callable&lt;T&gt; callable) {
        return () -&gt; {
            try {
                return callable.call();
            }
            catch (RuntimeException e) {
                throw e;
            }
            catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
}

public class JdbcConnectionPool extends ObjectPool&lt;Connection&gt; {

    public JdbcConnectionPool(int maxConnections, String url) {
        super(SupplierUtils.wrap(() -&gt; DriverManager.getConnection(url)), maxConnections);
    }
}
******************************
Normalized:
public final class SupplierUtils {
    private SupplierUtils() {
    }

    public static &lt;T&gt; Supplier&lt;T&gt; wrap(Callable&lt;T&gt; callable) {
        return () -&gt; {
            try {
                return callable.call();
            }
            catch (RuntimeException e) {
                throw e;
            }
            catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
}

public class JdbcConnectionPool extends ObjectPool&lt;Connection&gt; {

    public JdbcConnectionPool(int maxConnections, String url) {
        super(SupplierUtils.wrap(() -&gt; DriverManager.getConnection(url)), maxConnections);
    }
}
******************************
Original:
/**
 * This resolver handles command objects annotated with @SupportsAnnotationParameterResolution
 * that are passed as parameters to controller methods.
 * 
 * It parses @CommandPerameter annotations on command objects to
 * populate the Binder with the appropriate values (that is, the filed names
 * corresponding to the GET parameters)
 * 
 * In order to achieve this, small pieces of code are copied from spring-mvc
 * classes (indicated in-place). The alternative to the copied lines would be to
 * have a decorator around the Binder, but that would be more tedious, and still
 * some methods would need to be copied.
 * 
 * @author bozho
 * 
 */
public class AnnotationServletModelAttributeResolver extends ServletModelAttributeMethodProcessor {

    /**
     * A map caching annotation definitions of command objects (@CommandParameter-to-fieldname mappings)
     */
    private ConcurrentMap&lt;Class&lt;?&gt;, Map&lt;String, String&gt;&gt; definitionsCache = Maps.newConcurrentMap();

    public AnnotationServletModelAttributeResolver(boolean annotationNotRequired) {
        super(annotationNotRequired);
    }

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        if (parameter.getParameterType().isAnnotationPresent(SupportsAnnotationParameterResolution.class)) {
            return true;
        }
        return false;
    }

    @Override
    protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
        ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);
        ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
        bind(servletRequest, servletBinder);
    }

    @SuppressWarnings("unchecked")
    public void bind(ServletRequest request, ServletRequestDataBinder binder) {
        Map&lt;String, ?&gt; propertyValues = parsePropertyValues(request, binder);
        MutablePropertyValues mpvs = new MutablePropertyValues(propertyValues);
        MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);
        if (multipartRequest != null) {
            bindMultipart(multipartRequest.getMultiFileMap(), mpvs);
        }

        // two lines copied from ExtendedServletRequestDataBinder
        String attr = HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;
        mpvs.addPropertyValues((Map&lt;String, String&gt;) request.getAttribute(attr));
        binder.bind(mpvs);
    }

    private Map&lt;String, ?&gt; parsePropertyValues(ServletRequest request, ServletRequestDataBinder binder) {

        // similar to WebUtils.getParametersStartingWith(..) (prefixes not supported)
        Map&lt;String, Object&gt; params = Maps.newTreeMap();
        Assert.notNull(request, "Request must not be null");
        Enumeration&lt;?&gt; paramNames = request.getParameterNames();
        Map&lt;String, String&gt; parameterMappings = getParameterMappings(binder);
        while (paramNames != null &amp;&amp; paramNames.hasMoreElements()) {
            String paramName = (String) paramNames.nextElement();
            String[] values = request.getParameterValues(paramName);

            String fieldName = parameterMappings.get(paramName);
            // no annotation exists, use the default - the param name=field name
            if (fieldName == null) {
                fieldName = paramName;
            }

            if (values == null || values.length == 0) {
                // Do nothing, no values found at all.
            } else if (values.length &gt; 1) {
                params.put(fieldName, values);
            } else {
                params.put(fieldName, values[0]);
            }
        }

        return params;
    }

    /**
     * Gets a mapping between request parameter names and field names.
     * If no annotation is specified, no entry is added
     * @return
     */
    private Map&lt;String, String&gt; getParameterMappings(ServletRequestDataBinder binder) {
        Class&lt;?&gt; targetClass = binder.getTarget().getClass();
        Map&lt;String, String&gt; map = definitionsCache.get(targetClass);
        if (map == null) {
            Field[] fields = targetClass.getDeclaredFields();
            map = Maps.newHashMapWithExpectedSize(fields.length);
            for (Field field : fields) {
                CommandParameter annotation = field.getAnnotation(CommandParameter.class);
                if (annotation != null &amp;&amp; !annotation.value().isEmpty()) {
                    map.put(annotation.value(), field.getName());
                }
            }
            definitionsCache.putIfAbsent(targetClass, map);
            return map;
        } else {
            return map;
        }
    }

    /**
     * Copied from WebDataBinder.
     * 
     * @param multipartFiles
     * @param mpvs
     */
    protected void bindMultipart(Map&lt;String, List&lt;MultipartFile&gt;&gt; multipartFiles, MutablePropertyValues mpvs) {
        for (Map.Entry&lt;String, List&lt;MultipartFile&gt;&gt; entry : multipartFiles.entrySet()) {
            String key = entry.getKey();
            List&lt;MultipartFile&gt; values = entry.getValue();
            if (values.size() == 1) {
                MultipartFile value = values.get(0);
                if (!value.isEmpty()) {
                    mpvs.add(key, value);
                }
            } else {
                mpvs.add(key, values);
            }
        }
    }
}
******************************
Normalized:
******************************
Original:
/**
 * This resolver handles command objects annotated with @SupportsAnnotationParameterResolution
 * that are passed as parameters to controller methods.
 * 
 * It parses @CommandPerameter annotations on command objects to
 * populate the Binder with the appropriate values (that is, the filed names
 * corresponding to the GET parameters)
 * 
 * In order to achieve this, small pieces of code are copied from spring-mvc
 * classes (indicated in-place). The alternative to the copied lines would be to
 * have a decorator around the Binder, but that would be more tedious, and still
 * some methods would need to be copied.
 * 
 * @author bozho
 * 
 */
public class AnnotationServletModelAttributeResolver extends ServletModelAttributeMethodProcessor {

    /**
     * A map caching annotation definitions of command objects (@CommandParameter-to-fieldname mappings)
     */
    private ConcurrentMap&lt;Class&lt;?&gt;, Map&lt;String, String&gt;&gt; definitionsCache = Maps.newConcurrentMap();

    public AnnotationServletModelAttributeResolver(boolean annotationNotRequired) {
        super(annotationNotRequired);
    }

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        if (parameter.getParameterType().isAnnotationPresent(SupportsAnnotationParameterResolution.class)) {
            return true;
        }
        return false;
    }

    @Override
    protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
        ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);
        ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
        bind(servletRequest, servletBinder);
    }

    @SuppressWarnings("unchecked")
    public void bind(ServletRequest request, ServletRequestDataBinder binder) {
        Map&lt;String, ?&gt; propertyValues = parsePropertyValues(request, binder);
        MutablePropertyValues mpvs = new MutablePropertyValues(propertyValues);
        MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);
        if (multipartRequest != null) {
            bindMultipart(multipartRequest.getMultiFileMap(), mpvs);
        }

        // two lines copied from ExtendedServletRequestDataBinder
        String attr = HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;
        mpvs.addPropertyValues((Map&lt;String, String&gt;) request.getAttribute(attr));
        binder.bind(mpvs);
    }

    private Map&lt;String, ?&gt; parsePropertyValues(ServletRequest request, ServletRequestDataBinder binder) {

        // similar to WebUtils.getParametersStartingWith(..) (prefixes not supported)
        Map&lt;String, Object&gt; params = Maps.newTreeMap();
        Assert.notNull(request, "Request must not be null");
        Enumeration&lt;?&gt; paramNames = request.getParameterNames();
        Map&lt;String, String&gt; parameterMappings = getParameterMappings(binder);
        while (paramNames != null &amp;&amp; paramNames.hasMoreElements()) {
            String paramName = (String) paramNames.nextElement();
            String[] values = request.getParameterValues(paramName);

            String fieldName = parameterMappings.get(paramName);
            // no annotation exists, use the default - the param name=field name
            if (fieldName == null) {
                fieldName = paramName;
            }

            if (values == null || values.length == 0) {
                // Do nothing, no values found at all.
            } else if (values.length &gt; 1) {
                params.put(fieldName, values);
            } else {
                params.put(fieldName, values[0]);
            }
        }

        return params;
    }

    /**
     * Gets a mapping between request parameter names and field names.
     * If no annotation is specified, no entry is added
     * @return
     */
    private Map&lt;String, String&gt; getParameterMappings(ServletRequestDataBinder binder) {
        Class&lt;?&gt; targetClass = binder.getTarget().getClass();
        Map&lt;String, String&gt; map = definitionsCache.get(targetClass);
        if (map == null) {
            Field[] fields = targetClass.getDeclaredFields();
            map = Maps.newHashMapWithExpectedSize(fields.length);
            for (Field field : fields) {
                CommandParameter annotation = field.getAnnotation(CommandParameter.class);
                if (annotation != null &amp;&amp; !annotation.value().isEmpty()) {
                    map.put(annotation.value(), field.getName());
                }
            }
            definitionsCache.putIfAbsent(targetClass, map);
            return map;
        } else {
            return map;
        }
    }

    /**
     * Copied from WebDataBinder.
     * 
     * @param multipartFiles
     * @param mpvs
     */
    protected void bindMultipart(Map&lt;String, List&lt;MultipartFile&gt;&gt; multipartFiles, MutablePropertyValues mpvs) {
        for (Map.Entry&lt;String, List&lt;MultipartFile&gt;&gt; entry : multipartFiles.entrySet()) {
            String key = entry.getKey();
            List&lt;MultipartFile&gt; values = entry.getValue();
            if (values.size() == 1) {
                MultipartFile value = values.get(0);
                if (!value.isEmpty()) {
                    mpvs.add(key, value);
                }
            } else {
                mpvs.add(key, values);
            }
        }
    }
}
******************************
Normalized:
/**
 * This resolver handles command objects annotated with @SupportsAnnotationParameterResolution
 * that are passed as parameters to controller methods.
 * 
 * It parses @CommandPerameter annotations on command objects to
 * populate the Binder with the appropriate values (that is, the filed names
 * corresponding to the GET parameters)
 * 
 * In order to achieve this, small pieces of code are copied from spring-mvc
 * classes (indicated in-place). The alternative to the copied lines would be to
 * have a decorator around the Binder, but that would be more tedious, and still
 * some methods would need to be copied.
 * 
 * @author bozho
 * 
 */
public class AnnotationServletModelAttributeResolver extends ServletModelAttributeMethodProcessor {

    /**
     * A map caching annotation definitions of command objects (@CommandParameter-to-fieldname mappings)
     */
    private ConcurrentMap&lt;Class&lt;?&gt;, Map&lt;String, String&gt;&gt; definitionsCache = Maps.newConcurrentMap();

    public AnnotationServletModelAttributeResolver(boolean annotationNotRequired) {
        super(annotationNotRequired);
    }

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        if (parameter.getParameterType().isAnnotationPresent(SupportsAnnotationParameterResolution.class)) {
            return true;
        }
        return false;
    }

    @Override
    protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
        ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);
        ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
        bind(servletRequest, servletBinder);
    }

    @SuppressWarnings("unchecked")
    public void bind(ServletRequest request, ServletRequestDataBinder binder) {
        Map&lt;String, ?&gt; propertyValues = parsePropertyValues(request, binder);
        MutablePropertyValues mpvs = new MutablePropertyValues(propertyValues);
        MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);
        if (multipartRequest != null) {
            bindMultipart(multipartRequest.getMultiFileMap(), mpvs);
        }

        // two lines copied from ExtendedServletRequestDataBinder
        String attr = HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;
        mpvs.addPropertyValues((Map&lt;String, String&gt;) request.getAttribute(attr));
        binder.bind(mpvs);
    }

    private Map&lt;String, ?&gt; parsePropertyValues(ServletRequest request, ServletRequestDataBinder binder) {

        // similar to WebUtils.getParametersStartingWith(..) (prefixes not supported)
        Map&lt;String, Object&gt; params = Maps.newTreeMap();
        Assert.notNull(request, "Request must not be null");
        Enumeration&lt;?&gt; paramNames = request.getParameterNames();
        Map&lt;String, String&gt; parameterMappings = getParameterMappings(binder);
        while (paramNames != null &amp;&amp; paramNames.hasMoreElements()) {
            String paramName = (String) paramNames.nextElement();
            String[] values = request.getParameterValues(paramName);

            String fieldName = parameterMappings.get(paramName);
            // no annotation exists, use the default - the param name=field name
            if (fieldName == null) {
                fieldName = paramName;
            }

            if (values == null || values.length == 0) {
                // Do nothing, no values found at all.
            } else if (values.length &gt; 1) {
                params.put(fieldName, values);
            } else {
                params.put(fieldName, values[0]);
            }
        }

        return params;
    }

    /**
     * Gets a mapping between request parameter names and field names.
     * If no annotation is specified, no entry is added
     * @return
     */
    private Map&lt;String, String&gt; getParameterMappings(ServletRequestDataBinder binder) {
        Class&lt;?&gt; targetClass = binder.getTarget().getClass();
        Map&lt;String, String&gt; map = definitionsCache.get(targetClass);
        if (map == null) {
            Field[] fields = targetClass.getDeclaredFields();
            map = Maps.newHashMapWithExpectedSize(fields.length);
            for (Field field : fields) {
                CommandParameter annotation = field.getAnnotation(CommandParameter.class);
                if (annotation != null &amp;&amp; !annotation.value().isEmpty()) {
                    map.put(annotation.value(), field.getName());
                }
            }
            definitionsCache.putIfAbsent(targetClass, map);
            return map;
        } else {
            return map;
        }
    }

    /**
     * Copied from WebDataBinder.
     * 
     * @param multipartFiles
     * @param mpvs
     */
    protected void bindMultipart(Map&lt;String, List&lt;MultipartFile&gt;&gt; multipartFiles, MutablePropertyValues mpvs) {
        for (Map.Entry&lt;String, List&lt;MultipartFile&gt;&gt; entry : multipartFiles.entrySet()) {
            String key = entry.getKey();
            List&lt;MultipartFile&gt; values = entry.getValue();
            if (values.size() == 1) {
                MultipartFile value = values.get(0);
                if (!value.isEmpty()) {
                    mpvs.add(key, value);
                }
            } else {
                mpvs.add(key, values);
            }
        }
    }
}
******************************
Original:
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:id="@+id/mainLayout"
  android:descendantFocusability="beforeDescendants"
  android:focusableInTouchMode="true" &gt;

    &lt;EditText
        android:id="@+id/password"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@+id/changePass"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="167dp"
        android:ems="10"
        android:imeOptions="flagNoExtractUi"
        android:inputType="textPassword"
        android:maxLength="30" &gt;
    &lt;/EditText&gt;

&lt;/RelativeLayout&gt;
******************************
Normalized:
******************************
Original:
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:id="@+id/mainLayout"
  android:descendantFocusability="beforeDescendants"
  android:focusableInTouchMode="true" &gt;

    &lt;EditText
        android:id="@+id/password"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@+id/changePass"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="167dp"
        android:ems="10"
        android:imeOptions="flagNoExtractUi"
        android:inputType="textPassword"
        android:maxLength="30" &gt;
    &lt;/EditText&gt;

&lt;/RelativeLayout&gt;
******************************
Normalized:
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:id="@+id/mainLayout"
  android:descendantFocusability="beforeDescendants"
  android:focusableInTouchMode="true" &gt;

    &lt;EditText
        android:id="@+id/password"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@+id/changePass"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="167dp"
        android:ems="10"
        android:imeOptions="flagNoExtractUi"
        android:inputType="textPassword"
        android:maxLength="30" &gt;
    &lt;/EditText&gt;

&lt;/RelativeLayout&gt;
******************************
Original:
[Desktop Entry]                                                                 
Encoding=UTF-8
Name=IntelliJ IDEA
Comment=IntelliJ IDEA
Exec=/opt/ideaIC-14.1.2/bin/idea.sh
Icon=/opt/ideaIC-14.1.2/bin/idea.png
Terminal=false
StartupNotify=true
Type=Application
******************************
Normalized:
******************************
Original:
[Desktop Entry]                                                                 
Encoding=UTF-8
Name=IntelliJ IDEA
Comment=IntelliJ IDEA
Exec=/opt/ideaIC-14.1.2/bin/idea.sh
Icon=/opt/ideaIC-14.1.2/bin/idea.png
Terminal=false
StartupNotify=true
Type=Application
******************************
Normalized:
[Desktop Entry]                                                                 
Encoding=UTF-8
Name=IntelliJ IDEA
Comment=IntelliJ IDEA
Exec=/opt/ideaIC-14.1.2/bin/idea.sh
Icon=/opt/ideaIC-14.1.2/bin/idea.png
Terminal=false
StartupNotify=true
Type=Application
******************************
Original:
Throwable getRootCause(Throwable throwable)
******************************
Normalized:
******************************
Original:
Throwable getRootCause(Throwable throwable)
******************************
Normalized:
Throwable getRootCause(Throwable throwable)
******************************
Original:
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.1&lt;/version&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;download-sources&lt;/id&gt;
        &lt;goals&gt;
          &lt;goal&gt;sources&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
  &lt;/plugin&gt;
******************************
Normalized:
******************************
Original:
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.1&lt;/version&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;download-sources&lt;/id&gt;
        &lt;goals&gt;
          &lt;goal&gt;sources&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
  &lt;/plugin&gt;
******************************
Normalized:
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.1&lt;/version&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;download-sources&lt;/id&gt;
        &lt;goals&gt;
          &lt;goal&gt;sources&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
  &lt;/plugin&gt;
******************************
Original:
&lt;li&gt;&lt;a href="#{request.contextPath}/index.xhtml"&gt;Home&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#{request.contextPath}/about_us.xhtml"&gt;About us&lt;/a&gt;&lt;/li&gt;
******************************
Normalized:
******************************
Original:
&lt;li&gt;&lt;a href="#{request.contextPath}/index.xhtml"&gt;Home&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#{request.contextPath}/about_us.xhtml"&gt;About us&lt;/a&gt;&lt;/li&gt;
******************************
Normalized:
&lt;li&gt;&lt;a href="#{request.contextPath}/index.xhtml"&gt;Home&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#{request.contextPath}/about_us.xhtml"&gt;About us&lt;/a&gt;&lt;/li&gt;
******************************
Original:
&lt;servlet&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        &lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;
            org.package.YouConfigurationAnnotatedClass
        &lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
******************************
Normalized:
******************************
Original:
&lt;servlet&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        &lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;
            org.package.YouConfigurationAnnotatedClass
        &lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
******************************
Normalized:
&lt;servlet&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        &lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;
            org.package.YouConfigurationAnnotatedClass
        &lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
******************************
Original:
&lt;target name="compile1"&gt; 
  &lt;mkdir dir="./build/reports"/&gt; 
  &lt;jrc 
    srcdir="./reports"
    destdir="./build/reports"
    tempdir="./build/reports"
    keepjava="true"
    xmlvalidation="true"&gt;
   &lt;classpath refid="runClasspath"/&gt;
   &lt;include name="**/*.jrxml"/&gt;
  &lt;/jrc&gt;
&lt;/target&gt;
******************************
Normalized:
******************************
Original:
&lt;target name="compile1"&gt; 
  &lt;mkdir dir="./build/reports"/&gt; 
  &lt;jrc 
    srcdir="./reports"
    destdir="./build/reports"
    tempdir="./build/reports"
    keepjava="true"
    xmlvalidation="true"&gt;
   &lt;classpath refid="runClasspath"/&gt;
   &lt;include name="**/*.jrxml"/&gt;
  &lt;/jrc&gt;
&lt;/target&gt;
******************************
Normalized:
&lt;target name="compile1"&gt; 
  &lt;mkdir dir="./build/reports"/&gt; 
  &lt;jrc 
    srcdir="./reports"
    destdir="./build/reports"
    tempdir="./build/reports"
    keepjava="true"
    xmlvalidation="true"&gt;
   &lt;classpath refid="runClasspath"/&gt;
   &lt;include name="**/*.jrxml"/&gt;
  &lt;/jrc&gt;
&lt;/target&gt;
******************************
Original:
List&lt;List&lt;String&gt;&gt; first = list1.stream().map(Arrays::asList).collect(toList());
List&lt;List&lt;String&gt;&gt; second = list2.stream().map(Arrays::asList).collect(toList());
return first.equals(second);
******************************
Normalized:
******************************
Original:
List&lt;List&lt;String&gt;&gt; first = list1.stream().map(Arrays::asList).collect(toList());
List&lt;List&lt;String&gt;&gt; second = list2.stream().map(Arrays::asList).collect(toList());
return first.equals(second);
******************************
Normalized:
List&lt;List&lt;String&gt;&gt; first = list1.stream().map(Arrays::asList).collect(toList());
List&lt;List&lt;String&gt;&gt; second = list2.stream().map(Arrays::asList).collect(toList());
return first.equals(second);
******************************
Original:
&lt;c:if test="${content.contentType.name ne 'MCE'}"&gt;
    &lt;%-- snip --%&gt;
&lt;/c:if&gt;
******************************
Normalized:
******************************
Original:
&lt;c:if test="${content.contentType.name ne 'MCE'}"&gt;
    &lt;%-- snip --%&gt;
&lt;/c:if&gt;
******************************
Normalized:
&lt;c:if test="${content.contentType.name ne 'MCE'}"&gt;
    &lt;%-- snip --%&gt;
&lt;/c:if&gt;
******************************
Original:
Your keystore contains 1 entry

myalias, Feb 15, 2012, PrivateKeyEntry, 
Certificate fingerprint (MD5): xxxxxxxx
******************************
Normalized:
******************************
Original:
Your keystore contains 1 entry

myalias, Feb 15, 2012, PrivateKeyEntry, 
Certificate fingerprint (MD5): xxxxxxxx
******************************
Normalized:
Your keystore contains 1 entry

myalias, Feb 15, 2012, PrivateKeyEntry, 
Certificate fingerprint (MD5): xxxxxxxx
******************************
Original:
GOTO --&gt;JAVA--Compiler---&gt; and change compiler level to `1.5` instead of `1.6`
******************************
Normalized:
******************************
Original:
GOTO --&gt;JAVA--Compiler---&gt; and change compiler level to `1.5` instead of `1.6`
******************************
Normalized:
GOTO --&gt;JAVA--Compiler---&gt; and change compiler level to `1.5` instead of `1.6`
******************************
Original:
try{
    int i = Integer.parseInt(input);
} catch(NumberFormatException ex){ // handle your exception
    ...
}
******************************
Normalized:
******************************
Original:
try{
    int i = Integer.parseInt(input);
} catch(NumberFormatException ex){ // handle your exception
    ...
}
******************************
Normalized:
try{
    int i = Integer.parseInt(input);
} catch(NumberFormatException ex){ // handle your exception
    ...
}
******************************
Original:
0x021dd753: test   %eax,0x180100      ;   {poll}
  0x021dd759: cmp    $0x0,%ecx
  0x021dd75c: je     0x021dd748         ;*ifeq
                                        ; - Test$1::run@7 (line 13)
  0x021dd75e: cmp    $0x0,%edx
  0x021dd761: jne    0x021dd788         ;*ifne
                                        ; - Test$1::run@13 (line 17)
  0x021dd767: nop    
  0x021dd768: jmp    0x021dd7b8         ;   {no_reloc}
  0x021dd76d: xchg   %ax,%ax
  0x021dd770: jmp    0x021dd7d2         ; implicit exception: dispatches to 0x021dd7c2
  0x021dd775: nop                       ;*getstatic out
                                        ; - Test$1::run@16 (line 18)
  0x021dd776: cmp    (%ecx),%eax        ; implicit exception: dispatches to 0x021dd7dc
  0x021dd778: mov    $0x39239500,%edx   ;*invokevirtual println
******************************
Normalized:
******************************
Original:
0x021dd753: test   %eax,0x180100      ;   {poll}
  0x021dd759: cmp    $0x0,%ecx
  0x021dd75c: je     0x021dd748         ;*ifeq
                                        ; - Test$1::run@7 (line 13)
  0x021dd75e: cmp    $0x0,%edx
  0x021dd761: jne    0x021dd788         ;*ifne
                                        ; - Test$1::run@13 (line 17)
  0x021dd767: nop    
  0x021dd768: jmp    0x021dd7b8         ;   {no_reloc}
  0x021dd76d: xchg   %ax,%ax
  0x021dd770: jmp    0x021dd7d2         ; implicit exception: dispatches to 0x021dd7c2
  0x021dd775: nop                       ;*getstatic out
                                        ; - Test$1::run@16 (line 18)
  0x021dd776: cmp    (%ecx),%eax        ; implicit exception: dispatches to 0x021dd7dc
  0x021dd778: mov    $0x39239500,%edx   ;*invokevirtual println
******************************
Normalized:
0x021dd753: test   %eax,0x180100      ;   {poll}
  0x021dd759: cmp    $0x0,%ecx
  0x021dd75c: je     0x021dd748         ;*ifeq
                                        ; - Test$1::run@7 (line 13)
  0x021dd75e: cmp    $0x0,%edx
  0x021dd761: jne    0x021dd788         ;*ifne
                                        ; - Test$1::run@13 (line 17)
  0x021dd767: nop    
  0x021dd768: jmp    0x021dd7b8         ;   {no_reloc}
  0x021dd76d: xchg   %ax,%ax
  0x021dd770: jmp    0x021dd7d2         ; implicit exception: dispatches to 0x021dd7c2
  0x021dd775: nop                       ;*getstatic out
                                        ; - Test$1::run@16 (line 18)
  0x021dd776: cmp    (%ecx),%eax        ; implicit exception: dispatches to 0x021dd7dc
  0x021dd778: mov    $0x39239500,%edx   ;*invokevirtual println
******************************
Original:
final Path path = FileSystems.getDefault().getPath(System.getProperty("user.home"), "Desktop");
System.out.println(path);
try (final WatchService watchService = FileSystems.getDefault().newWatchService()) {
    final WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);
    while (true) {
        final WatchKey wk = watchService.take();
        for (WatchEvent&lt;?&gt; event : wk.pollEvents()) {
            //we only register "ENTRY_MODIFY" so the context is always a Path.
            final Path changed = (Path) event.context();
            System.out.println(changed);
            if (changed.endsWith("myFile.txt")) {
                System.out.println("My file has changed");
            }
        }
        // reset the key
        boolean valid = wk.reset();
        if (!valid) {
            System.out.println("Key has been unregisterede");
        }
    }
}
******************************
Normalized:
******************************
Original:
final Path path = FileSystems.getDefault().getPath(System.getProperty("user.home"), "Desktop");
System.out.println(path);
try (final WatchService watchService = FileSystems.getDefault().newWatchService()) {
    final WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);
    while (true) {
        final WatchKey wk = watchService.take();
        for (WatchEvent&lt;?&gt; event : wk.pollEvents()) {
            //we only register "ENTRY_MODIFY" so the context is always a Path.
            final Path changed = (Path) event.context();
            System.out.println(changed);
            if (changed.endsWith("myFile.txt")) {
                System.out.println("My file has changed");
            }
        }
        // reset the key
        boolean valid = wk.reset();
        if (!valid) {
            System.out.println("Key has been unregisterede");
        }
    }
}
******************************
Normalized:
final Path path = FileSystems.getDefault().getPath(System.getProperty("user.home"), "Desktop");
System.out.println(path);
try (final WatchService watchService = FileSystems.getDefault().newWatchService()) {
    final WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);
    while (true) {
        final WatchKey wk = watchService.take();
        for (WatchEvent&lt;?&gt; event : wk.pollEvents()) {
            //we only register "ENTRY_MODIFY" so the context is always a Path.
            final Path changed = (Path) event.context();
            System.out.println(changed);
            if (changed.endsWith("myFile.txt")) {
                System.out.println("My file has changed");
            }
        }
        // reset the key
        boolean valid = wk.reset();
        if (!valid) {
            System.out.println("Key has been unregisterede");
        }
    }
}
******************************
Original:
Map&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();

// Add Items to the TreeMap
map.put(1, "One");
map.put(2, "Two");
map.put(3, "Three");

// Iterate over them
for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {
    System.out.println(entry.getKey() + " =&gt; " + entry.getValue());
}
******************************
Normalized:
******************************
Original:
Map&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();

// Add Items to the TreeMap
map.put(1, "One");
map.put(2, "Two");
map.put(3, "Three");

// Iterate over them
for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {
    System.out.println(entry.getKey() + " =&gt; " + entry.getValue());
}
******************************
Normalized:
Map&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();

// Add Items to the TreeMap
map.put(1, "One");
map.put(2, "Two");
map.put(3, "Three");

// Iterate over them
for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {
    System.out.println(entry.getKey() + " =&gt; " + entry.getValue());
}
******************************
Original:
EnumSet largeSize
******************************
Normalized:
******************************
Original:
EnumSet largeSize
******************************
Normalized:
EnumSet largeSize
******************************
Original:
@OneToMany
@JoinColumn(name="TXTHEAD_CODE")
private Set&lt;Text&gt; text;
******************************
Normalized:
******************************
Original:
@OneToMany
@JoinColumn(name="TXTHEAD_CODE")
private Set&lt;Text&gt; text;
******************************
Normalized:
@OneToMany
@JoinColumn(name="TXTHEAD_CODE")
private Set&lt;Text&gt; text;
******************************
Original:
&lt;mvc:resources mapping="/static/**" location="/static/" /&gt;
******************************
Normalized:
******************************
Original:
&lt;mvc:resources mapping="/static/**" location="/static/" /&gt;
******************************
Normalized:
&lt;mvc:resources mapping="/static/**" location="/static/" /&gt;
******************************
Original:
IntStream.iterate(0, i -&gt; i + 2);
******************************
Normalized:
******************************
Original:
IntStream.iterate(0, i -&gt; i + 2);
******************************
Normalized:
IntStream.iterate(0, i -&gt; i + 2);
******************************
Original:
gcc -I/usr/lib/jvm/jdk1.7.0_07/include
******************************
Normalized:
******************************
Original:
gcc -I/usr/lib/jvm/jdk1.7.0_07/include
******************************
Normalized:
gcc -I/usr/lib/jvm/jdk1.7.0_07/include
******************************
Original:
// parent entity has simple primary key

@Entity
public class Employee {
   @Id long empId;
   String name;
   ...
} 

// dependent entity uses EmbeddedId for composite key

@Embeddable
public class DependentId {
   String name;
   long empid;   // corresponds to primary key type of Employee
}

@Entity
public class Dependent {
   @EmbeddedId DependentId id;
    ...
   @MapsId("empid")  //  maps the empid attribute of embedded id
   @ManyToOne Employee emp;
}
******************************
Normalized:
******************************
Original:
// parent entity has simple primary key

@Entity
public class Employee {
   @Id long empId;
   String name;
   ...
} 

// dependent entity uses EmbeddedId for composite key

@Embeddable
public class DependentId {
   String name;
   long empid;   // corresponds to primary key type of Employee
}

@Entity
public class Dependent {
   @EmbeddedId DependentId id;
    ...
   @MapsId("empid")  //  maps the empid attribute of embedded id
   @ManyToOne Employee emp;
}
******************************
Normalized:
// parent entity has simple primary key

@Entity
public class Employee {
   @Id long empId;
   String name;
   ...
} 

// dependent entity uses EmbeddedId for composite key

@Embeddable
public class DependentId {
   String name;
   long empid;   // corresponds to primary key type of Employee
}

@Entity
public class Dependent {
   @EmbeddedId DependentId id;
    ...
   @MapsId("empid")  //  maps the empid attribute of embedded id
   @ManyToOne Employee emp;
}
******************************
Original:
//Import all needed packages
package general;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipUtils {

    private List &lt;String&gt; fileList;
    private static final String OUTPUT_ZIP_FILE = "Folder.zip";
    private static final String SOURCE_FOLDER = "D:\\Reports"; // SourceFolder path

    public ZipUtils() {
        fileList = new ArrayList &lt; String &gt; ();
    }

    public static void main(String[] args) {
        ZipUtils appZip = new ZipUtils();
        appZip.generateFileList(new File(SOURCE_FOLDER));
        appZip.zipIt(OUTPUT_ZIP_FILE);
    }

    public void zipIt(String zipFile) {
        byte[] buffer = new byte[1024];
        String source = new File(SOURCE_FOLDER).getName();
        FileOutputStream fos = null;
        ZipOutputStream zos = null;
        try {
            fos = new FileOutputStream(zipFile);
            zos = new ZipOutputStream(fos);

            System.out.println("Output to Zip : " + zipFile);
            FileInputStream in = null;

            for (String file: this.fileList) {
                System.out.println("File Added : " + file);
                ZipEntry ze = new ZipEntry(source + File.separator + file);
                zos.putNextEntry(ze);
                try {
                    in = new FileInputStream(SOURCE_FOLDER + File.separator + file);
                    int len;
                    while ((len = in .read(buffer)) &gt; 0) {
                        zos.write(buffer, 0, len);
                    }
                } finally {
                    in.close();
                }
            }

            zos.closeEntry();
            System.out.println("Folder successfully compressed");

        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            try {
                zos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public void generateFileList(File node) {
        // add file only
        if (node.isFile()) {
            fileList.add(generateZipEntry(node.toString()));
        }

        if (node.isDirectory()) {
            String[] subNote = node.list();
            for (String filename: subNote) {
                generateFileList(new File(node, filename));
            }
        }
    }

    private String generateZipEntry(String file) {
        return file.substring(SOURCE_FOLDER.length() + 1, file.length());
    }
}
******************************
Normalized:
******************************
Original:
//Import all needed packages
package general;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipUtils {

    private List &lt;String&gt; fileList;
    private static final String OUTPUT_ZIP_FILE = "Folder.zip";
    private static final String SOURCE_FOLDER = "D:\\Reports"; // SourceFolder path

    public ZipUtils() {
        fileList = new ArrayList &lt; String &gt; ();
    }

    public static void main(String[] args) {
        ZipUtils appZip = new ZipUtils();
        appZip.generateFileList(new File(SOURCE_FOLDER));
        appZip.zipIt(OUTPUT_ZIP_FILE);
    }

    public void zipIt(String zipFile) {
        byte[] buffer = new byte[1024];
        String source = new File(SOURCE_FOLDER).getName();
        FileOutputStream fos = null;
        ZipOutputStream zos = null;
        try {
            fos = new FileOutputStream(zipFile);
            zos = new ZipOutputStream(fos);

            System.out.println("Output to Zip : " + zipFile);
            FileInputStream in = null;

            for (String file: this.fileList) {
                System.out.println("File Added : " + file);
                ZipEntry ze = new ZipEntry(source + File.separator + file);
                zos.putNextEntry(ze);
                try {
                    in = new FileInputStream(SOURCE_FOLDER + File.separator + file);
                    int len;
                    while ((len = in .read(buffer)) &gt; 0) {
                        zos.write(buffer, 0, len);
                    }
                } finally {
                    in.close();
                }
            }

            zos.closeEntry();
            System.out.println("Folder successfully compressed");

        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            try {
                zos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public void generateFileList(File node) {
        // add file only
        if (node.isFile()) {
            fileList.add(generateZipEntry(node.toString()));
        }

        if (node.isDirectory()) {
            String[] subNote = node.list();
            for (String filename: subNote) {
                generateFileList(new File(node, filename));
            }
        }
    }

    private String generateZipEntry(String file) {
        return file.substring(SOURCE_FOLDER.length() + 1, file.length());
    }
}
******************************
Normalized:
//Import all needed packages
package general;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipUtils {

    private List &lt;String&gt; fileList;
    private static final String OUTPUT_ZIP_FILE = "Folder.zip";
    private static final String SOURCE_FOLDER = "D:\\Reports"; // SourceFolder path

    public ZipUtils() {
        fileList = new ArrayList &lt; String &gt; ();
    }

    public static void main(String[] args) {
        ZipUtils appZip = new ZipUtils();
        appZip.generateFileList(new File(SOURCE_FOLDER));
        appZip.zipIt(OUTPUT_ZIP_FILE);
    }

    public void zipIt(String zipFile) {
        byte[] buffer = new byte[1024];
        String source = new File(SOURCE_FOLDER).getName();
        FileOutputStream fos = null;
        ZipOutputStream zos = null;
        try {
            fos = new FileOutputStream(zipFile);
            zos = new ZipOutputStream(fos);

            System.out.println("Output to Zip : " + zipFile);
            FileInputStream in = null;

            for (String file: this.fileList) {
                System.out.println("File Added : " + file);
                ZipEntry ze = new ZipEntry(source + File.separator + file);
                zos.putNextEntry(ze);
                try {
                    in = new FileInputStream(SOURCE_FOLDER + File.separator + file);
                    int len;
                    while ((len = in .read(buffer)) &gt; 0) {
                        zos.write(buffer, 0, len);
                    }
                } finally {
                    in.close();
                }
            }

            zos.closeEntry();
            System.out.println("Folder successfully compressed");

        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            try {
                zos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public void generateFileList(File node) {
        // add file only
        if (node.isFile()) {
            fileList.add(generateZipEntry(node.toString()));
        }

        if (node.isDirectory()) {
            String[] subNote = node.list();
            for (String filename: subNote) {
                generateFileList(new File(node, filename));
            }
        }
    }

    private String generateZipEntry(String file) {
        return file.substring(SOURCE_FOLDER.length() + 1, file.length());
    }
}
******************************
Original:
public enum Month {
    JANUARY, FEBRUARY, ...
}
******************************
Normalized:
******************************
Original:
public enum Month {
    JANUARY, FEBRUARY, ...
}
******************************
Normalized:
public enum Month {
    JANUARY, FEBRUARY, ...
}
******************************
Original:
ext {
    ver = [
        guava: '14.0.1'
    ]
}
******************************
Normalized:
******************************
Original:
ext {
    ver = [
        guava: '14.0.1'
    ]
}
******************************
Normalized:
ext {
    ver = [
        guava: '14.0.1'
    ]
}
******************************
Original:
private static long gcd(long a, long b)
{
    while (b &gt; 0)
    {
        long temp = b;
        b = a % b; // % is remainder
        a = temp;
    }
    return a;
}

private static long gcd(long[] input)
{
    long result = input[0];
    for(int i = 1; i &lt; input.length; i++) result = gcd(result, input[i]);
    return result;
}
******************************
Normalized:
******************************
Original:
private static long gcd(long a, long b)
{
    while (b &gt; 0)
    {
        long temp = b;
        b = a % b; // % is remainder
        a = temp;
    }
    return a;
}

private static long gcd(long[] input)
{
    long result = input[0];
    for(int i = 1; i &lt; input.length; i++) result = gcd(result, input[i]);
    return result;
}
******************************
Normalized:
private static long gcd(long a, long b)
{
    while (b &gt; 0)
    {
        long temp = b;
        b = a % b; // % is remainder
        a = temp;
    }
    return a;
}

private static long gcd(long[] input)
{
    long result = input[0];
    for(int i = 1; i &lt; input.length; i++) result = gcd(result, input[i]);
    return result;
}
******************************
Original:
$ sudo apt-get install libxtst6:i386
******************************
Normalized:
******************************
Original:
$ sudo apt-get install libxtst6:i386
******************************
Normalized:
$ sudo apt-get install libxtst6:i386
******************************
Original:
public class Helper {

        public static boolean isAppRunning(final Context context, final String packageName) {
            final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            final List&lt;ActivityManager.RunningAppProcessInfo&gt; procInfos = activityManager.getRunningAppProcesses();
            if (procInfos != null)
            {
                for (final ActivityManager.RunningAppProcessInfo processInfo : procInfos) {
                    if (processInfo.processName.equals(packageName)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
******************************
Normalized:
******************************
Original:
public class Helper {

        public static boolean isAppRunning(final Context context, final String packageName) {
            final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            final List&lt;ActivityManager.RunningAppProcessInfo&gt; procInfos = activityManager.getRunningAppProcesses();
            if (procInfos != null)
            {
                for (final ActivityManager.RunningAppProcessInfo processInfo : procInfos) {
                    if (processInfo.processName.equals(packageName)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
******************************
Normalized:
public class Helper {

        public static boolean isAppRunning(final Context context, final String packageName) {
            final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            final List&lt;ActivityManager.RunningAppProcessInfo&gt; procInfos = activityManager.getRunningAppProcesses();
            if (procInfos != null)
            {
                for (final ActivityManager.RunningAppProcessInfo processInfo : procInfos) {
                    if (processInfo.processName.equals(packageName)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
******************************
Original:
# Set root logger level to DEBUG and its only appender to A1.
log4j.rootLogger=DEBUG, A1

# A1 is set to be a ConsoleAppender.
log4j.appender.A1=org.apache.log4j.ConsoleAppender

# A1 uses PatternLayout.
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n

# An alternative logging format:
# log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1} - %m%n
******************************
Normalized:
******************************
Original:
# Set root logger level to DEBUG and its only appender to A1.
log4j.rootLogger=DEBUG, A1

# A1 is set to be a ConsoleAppender.
log4j.appender.A1=org.apache.log4j.ConsoleAppender

# A1 uses PatternLayout.
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n

# An alternative logging format:
# log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1} - %m%n
******************************
Normalized:
# Set root logger level to DEBUG and its only appender to A1.
log4j.rootLogger=DEBUG, A1

# A1 is set to be a ConsoleAppender.
log4j.appender.A1=org.apache.log4j.ConsoleAppender

# A1 uses PatternLayout.
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n

# An alternative logging format:
# log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1} - %m%n
******************************
Original:
public class MyComparator implements Comparator&lt;Integer&gt; {
   public int compare(Integer a, Integer b) {
      //
   }
}
******************************
Normalized:
******************************
Original:
public class MyComparator implements Comparator&lt;Integer&gt; {
   public int compare(Integer a, Integer b) {
      //
   }
}
******************************
Normalized:
public class MyComparator implements Comparator&lt;Integer&gt; {
   public int compare(Integer a, Integer b) {
      //
   }
}
******************************
Original:
public InputField(String labelText, Class&lt;W&gt; clazz)
{
    super(new String[] {labelText}, clazz);
}
******************************
Normalized:
******************************
Original:
public InputField(String labelText, Class&lt;W&gt; clazz)
{
    super(new String[] {labelText}, clazz);
}
******************************
Normalized:
public InputField(String labelText, Class&lt;W&gt; clazz)
{
    super(new String[] {labelText}, clazz);
}
******************************
Original:
private Object actuallyT;

public &lt;T&gt; List&lt;T&gt; magicalListGetter(Class&lt;T&gt; klazz) {
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    list.add(klazz.cast(actuallyT));
    try {
        list.add(klazz.getConstructor().newInstance()); // If default constructor
    } ...
    return list;
}
******************************
Normalized:
******************************
Original:
private Object actuallyT;

public &lt;T&gt; List&lt;T&gt; magicalListGetter(Class&lt;T&gt; klazz) {
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    list.add(klazz.cast(actuallyT));
    try {
        list.add(klazz.getConstructor().newInstance()); // If default constructor
    } ...
    return list;
}
******************************
Normalized:
private Object actuallyT;

public &lt;T&gt; List&lt;T&gt; magicalListGetter(Class&lt;T&gt; klazz) {
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    list.add(klazz.cast(actuallyT));
    try {
        list.add(klazz.getConstructor().newInstance()); // If default constructor
    } ...
    return list;
}
******************************
Original:
@Component
public class ImagesPurgeJob implements Job {

    private Logger logger = Logger.getLogger(this.getClass());

    @Value("${jobs.mediafiles.imagesPurgeJob.enable}")
    private boolean imagesPurgeJobEnable;

    @Override
    @Transactional(readOnly=true)
    @Scheduled(cron = "${jobs.mediafiles.imagesPurgeJob.schedule}")
    public void execute() {

         //Do something
        //can use DAO or other autowired beans here
        if(imagesPurgeJobEnable){

            Do your conditional job here...

        }
    }
}
******************************
Normalized:
******************************
Original:
@Component
public class ImagesPurgeJob implements Job {

    private Logger logger = Logger.getLogger(this.getClass());

    @Value("${jobs.mediafiles.imagesPurgeJob.enable}")
    private boolean imagesPurgeJobEnable;

    @Override
    @Transactional(readOnly=true)
    @Scheduled(cron = "${jobs.mediafiles.imagesPurgeJob.schedule}")
    public void execute() {

         //Do something
        //can use DAO or other autowired beans here
        if(imagesPurgeJobEnable){

            Do your conditional job here...

        }
    }
}
******************************
Normalized:
@Component
public class ImagesPurgeJob implements Job {

    private Logger logger = Logger.getLogger(this.getClass());

    @Value("${jobs.mediafiles.imagesPurgeJob.enable}")
    private boolean imagesPurgeJobEnable;

    @Override
    @Transactional(readOnly=true)
    @Scheduled(cron = "${jobs.mediafiles.imagesPurgeJob.schedule}")
    public void execute() {

         //Do something
        //can use DAO or other autowired beans here
        if(imagesPurgeJobEnable){

            Do your conditional job here...

        }
    }
}
******************************
Original:
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
******************************
Normalized:
******************************
Original:
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
******************************
Normalized:
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
******************************
Original:
@RunWith(Parameterized.class)
 @ContextConfiguration(classes = {ApplicationConfigTest.class})
 public class ServiceTest {

     private TestContextManager testContextManager;

     @Before
     public void setUpContext() throws Exception {
         //this is where the magic happens, we actually do "by hand" what the spring runner would do for us,
        // read the JavaDoc for the class bellow to know exactly what it does, the method names are quite accurate though
       this.testContextManager = new TestContextManager(getClass());
       this.testContextManager.prepareTestInstance(this);
     }
     ...
 }
******************************
Normalized:
******************************
Original:
@RunWith(Parameterized.class)
 @ContextConfiguration(classes = {ApplicationConfigTest.class})
 public class ServiceTest {

     private TestContextManager testContextManager;

     @Before
     public void setUpContext() throws Exception {
         //this is where the magic happens, we actually do "by hand" what the spring runner would do for us,
        // read the JavaDoc for the class bellow to know exactly what it does, the method names are quite accurate though
       this.testContextManager = new TestContextManager(getClass());
       this.testContextManager.prepareTestInstance(this);
     }
     ...
 }
******************************
Normalized:
@RunWith(Parameterized.class)
 @ContextConfiguration(classes = {ApplicationConfigTest.class})
 public class ServiceTest {

     private TestContextManager testContextManager;

     @Before
     public void setUpContext() throws Exception {
         //this is where the magic happens, we actually do "by hand" what the spring runner would do for us,
        // read the JavaDoc for the class bellow to know exactly what it does, the method names are quite accurate though
       this.testContextManager = new TestContextManager(getClass());
       this.testContextManager.prepareTestInstance(this);
     }
     ...
 }
******************************
Original:
@SuppressWarnings("WeakerAccess")
******************************
Normalized:
******************************
Original:
@SuppressWarnings("WeakerAccess")
******************************
Normalized:
@SuppressWarnings("WeakerAccess")
******************************
Original:
-vm
C:\Program Files\Java\jdk1.6.0_07\bin\
******************************
Normalized:
******************************
Original:
-vm
C:\Program Files\Java\jdk1.6.0_07\bin\
******************************
Normalized:
-vm
C:\Program Files\Java\jdk1.6.0_07\bin\
******************************
Original:
final List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
list = new ArrayList&lt;Integer&gt;(); // Since `list' is final, this won't compile
******************************
Normalized:
******************************
Original:
final List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
list = new ArrayList&lt;Integer&gt;(); // Since `list' is final, this won't compile
******************************
Normalized:
final List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
list = new ArrayList&lt;Integer&gt;(); // Since `list' is final, this won't compile
******************************
Original:
JarFile jarFile = new JarFile(pathToJar);
Enumeration&lt;JarEntry&gt; e = jarFile.entries();

URL[] urls = { new URL("jar:file:" + pathToJar+"!/") };
URLClassLoader cl = URLClassLoader.newInstance(urls);

while (e.hasMoreElements()) {
    JarEntry je = e.nextElement();
    if(je.isDirectory() || !je.getName().endsWith(".class")){
        continue;
    }
    // -6 because of .class
    String className = je.getName().substring(0,je.getName().length()-6);
    className = className.replace('/', '.');
    Class c = cl.loadClass(className);

}
******************************
Normalized:
******************************
Original:
JarFile jarFile = new JarFile(pathToJar);
Enumeration&lt;JarEntry&gt; e = jarFile.entries();

URL[] urls = { new URL("jar:file:" + pathToJar+"!/") };
URLClassLoader cl = URLClassLoader.newInstance(urls);

while (e.hasMoreElements()) {
    JarEntry je = e.nextElement();
    if(je.isDirectory() || !je.getName().endsWith(".class")){
        continue;
    }
    // -6 because of .class
    String className = je.getName().substring(0,je.getName().length()-6);
    className = className.replace('/', '.');
    Class c = cl.loadClass(className);

}
******************************
Normalized:
JarFile jarFile = new JarFile(pathToJar);
Enumeration&lt;JarEntry&gt; e = jarFile.entries();

URL[] urls = { new URL("jar:file:" + pathToJar+"!/") };
URLClassLoader cl = URLClassLoader.newInstance(urls);

while (e.hasMoreElements()) {
    JarEntry je = e.nextElement();
    if(je.isDirectory() || !je.getName().endsWith(".class")){
        continue;
    }
    // -6 because of .class
    String className = je.getName().substring(0,je.getName().length()-6);
    className = className.replace('/', '.');
    Class c = cl.loadClass(className);

}
******************************
Original:
// All exception handling omitted!
Class&lt;?&gt; enclosingClass = Class.forName("com.mycompany.Mother");
Object enclosingInstance = enclosingClass.newInstance();

Class&lt;?&gt; innerClass = Class.forName("com.mycompany.Mother$Child");
Constructor&lt;?&gt; ctor = innerClass.getDeclaredConstructor(enclosingClass);

Object innerInstance = ctor.newInstance(enclosingInstance);
******************************
Normalized:
******************************
Original:
// All exception handling omitted!
Class&lt;?&gt; enclosingClass = Class.forName("com.mycompany.Mother");
Object enclosingInstance = enclosingClass.newInstance();

Class&lt;?&gt; innerClass = Class.forName("com.mycompany.Mother$Child");
Constructor&lt;?&gt; ctor = innerClass.getDeclaredConstructor(enclosingClass);

Object innerInstance = ctor.newInstance(enclosingInstance);
******************************
Normalized:
// All exception handling omitted!
Class&lt;?&gt; enclosingClass = Class.forName("com.mycompany.Mother");
Object enclosingInstance = enclosingClass.newInstance();

Class&lt;?&gt; innerClass = Class.forName("com.mycompany.Mother$Child");
Constructor&lt;?&gt; ctor = innerClass.getDeclaredConstructor(enclosingClass);

Object innerInstance = ctor.newInstance(enclosingInstance);
******************************
Original:
private static final Consumer&lt;Object&gt; NOOP = whatever -&gt; {};
******************************
Normalized:
******************************
Original:
private static final Consumer&lt;Object&gt; NOOP = whatever -&gt; {};
******************************
Normalized:
private static final Consumer&lt;Object&gt; NOOP = whatever -&gt; {};
******************************
Original:
&lt;bean id="transactionManager1"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory1" /&gt;
    &lt;qualifier value="account"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionManager2"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory2" /&gt;
    &lt;qualifier value="businessData"/&gt;
&lt;/bean&gt;
******************************
Normalized:
******************************
Original:
&lt;bean id="transactionManager1"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory1" /&gt;
    &lt;qualifier value="account"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionManager2"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory2" /&gt;
    &lt;qualifier value="businessData"/&gt;
&lt;/bean&gt;
******************************
Normalized:
&lt;bean id="transactionManager1"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory1" /&gt;
    &lt;qualifier value="account"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionManager2"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory2" /&gt;
    &lt;qualifier value="businessData"/&gt;
&lt;/bean&gt;
******************************
Original:
// Get file from file name
File file = new File("U:\intranet_root\intranet\R1112B2.zip");

// Get length of file in bytes
long fileSizeInBytes = file.length();
// Convert the bytes to Kilobytes (1 KB = 1024 Bytes)
long fileSizeInKB = fileSizeInBytes / 1024;
// Convert the KB to MegaBytes (1 MB = 1024 KBytes)
long fileSizeInMB = fileSizeInKB / 1024;

if (fileSizeInMB &gt; 27) {
  ...
}
******************************
Normalized:
******************************
Original:
// Get file from file name
File file = new File("U:\intranet_root\intranet\R1112B2.zip");

// Get length of file in bytes
long fileSizeInBytes = file.length();
// Convert the bytes to Kilobytes (1 KB = 1024 Bytes)
long fileSizeInKB = fileSizeInBytes / 1024;
// Convert the KB to MegaBytes (1 MB = 1024 KBytes)
long fileSizeInMB = fileSizeInKB / 1024;

if (fileSizeInMB &gt; 27) {
  ...
}
******************************
Normalized:
// Get file from file name
File file = new File("U:\intranet_root\intranet\R1112B2.zip");

// Get length of file in bytes
long fileSizeInBytes = file.length();
// Convert the bytes to Kilobytes (1 KB = 1024 Bytes)
long fileSizeInKB = fileSizeInBytes / 1024;
// Convert the KB to MegaBytes (1 MB = 1024 KBytes)
long fileSizeInMB = fileSizeInKB / 1024;

if (fileSizeInMB &gt; 27) {
  ...
}
******************************
Original:
[{A,1},{B,1},{C,2}]
******************************
Normalized:
******************************
Original:
[{A,1},{B,1},{C,2}]
******************************
Normalized:
[{A,1},{B,1},{C,2}]
******************************
Original:
grammar Math;

compileUnit
    :   expr EOF
    ;

expr
    :   '(' expr ')'                         # parensExpr
    |   op=('+'|'-') expr                    # unaryExpr
    |   left=expr op=('*'|'/') right=expr    # infixExpr
    |   left=expr op=('+'|'-') right=expr    # infixExpr
    |   func=ID '(' expr ')'                 # funcExpr
    |   value=NUM                            # numberExpr
    ;

OP_ADD: '+';
OP_SUB: '-';
OP_MUL: '*';
OP_DIV: '/';

NUM :   [0-9]+ ('.' [0-9]+)? ([eE] [+-]? [0-9]+)?;
ID  :   [a-zA-Z]+;
WS  :   [ \t\r\n] -&gt; channel(HIDDEN);
******************************
Normalized:
******************************
Original:
grammar Math;

compileUnit
    :   expr EOF
    ;

expr
    :   '(' expr ')'                         # parensExpr
    |   op=('+'|'-') expr                    # unaryExpr
    |   left=expr op=('*'|'/') right=expr    # infixExpr
    |   left=expr op=('+'|'-') right=expr    # infixExpr
    |   func=ID '(' expr ')'                 # funcExpr
    |   value=NUM                            # numberExpr
    ;

OP_ADD: '+';
OP_SUB: '-';
OP_MUL: '*';
OP_DIV: '/';

NUM :   [0-9]+ ('.' [0-9]+)? ([eE] [+-]? [0-9]+)?;
ID  :   [a-zA-Z]+;
WS  :   [ \t\r\n] -&gt; channel(HIDDEN);
******************************
Normalized:
grammar Math;

compileUnit
    :   expr EOF
    ;

expr
    :   '(' expr ')'                         # parensExpr
    |   op=('+'|'-') expr                    # unaryExpr
    |   left=expr op=('*'|'/') right=expr    # infixExpr
    |   left=expr op=('+'|'-') right=expr    # infixExpr
    |   func=ID '(' expr ')'                 # funcExpr
    |   value=NUM                            # numberExpr
    ;

OP_ADD: '+';
OP_SUB: '-';
OP_MUL: '*';
OP_DIV: '/';

NUM :   [0-9]+ ('.' [0-9]+)? ([eE] [+-]? [0-9]+)?;
ID  :   [a-zA-Z]+;
WS  :   [ \t\r\n] -&gt; channel(HIDDEN);
******************************
Original:
byte[] one = getBytesForOne();
byte[] two = getBytesForTwo();
byte[] combined = new byte[one.length + two.length];

for (int i = 0; i &lt; combined.length; ++i)
{
    combined[i] = i &lt; one.length ? one[i] : two[i - one.length];
}
******************************
Normalized:
******************************
Original:
byte[] one = getBytesForOne();
byte[] two = getBytesForTwo();
byte[] combined = new byte[one.length + two.length];

for (int i = 0; i &lt; combined.length; ++i)
{
    combined[i] = i &lt; one.length ? one[i] : two[i - one.length];
}
******************************
Normalized:
byte[] one = getBytesForOne();
byte[] two = getBytesForTwo();
byte[] combined = new byte[one.length + two.length];

for (int i = 0; i &lt; combined.length; ++i)
{
    combined[i] = i &lt; one.length ? one[i] : two[i - one.length];
}
******************************
Original:
&lt;string name="meatShootingMessage"&gt;You shot %1$d pounds of meat!&lt;/string&gt;  


int numPoundsMeat = 123;
String strMeatFormat = getResources().getString(R.string.meatShootingMessage, numPoundsMeat);
******************************
Normalized:
******************************
Original:
&lt;string name="meatShootingMessage"&gt;You shot %1$d pounds of meat!&lt;/string&gt;  


int numPoundsMeat = 123;
String strMeatFormat = getResources().getString(R.string.meatShootingMessage, numPoundsMeat);
******************************
Normalized:
&lt;string name="meatShootingMessage"&gt;You shot %1$d pounds of meat!&lt;/string&gt;  


int numPoundsMeat = 123;
String strMeatFormat = getResources().getString(R.string.meatShootingMessage, numPoundsMeat);
******************************
Original:
class MyClass {
    companion object {
        public const val FOO = 1

    }
}
******************************
Normalized:
******************************
Original:
class MyClass {
    companion object {
        public const val FOO = 1

    }
}
******************************
Normalized:
class MyClass {
    companion object {
        public const val FOO = 1

    }
}
******************************
Original:
Set&lt;String&gt; users = new HashSet&lt;&gt;(Arrays.asList("Alice", "Bob"));

System.out.println(users.contains("Alice"));
// -&gt; prints true

System.out.println(users.contains("Jack"));
// -&gt; prints false
******************************
Normalized:
******************************
Original:
Set&lt;String&gt; users = new HashSet&lt;&gt;(Arrays.asList("Alice", "Bob"));

System.out.println(users.contains("Alice"));
// -&gt; prints true

System.out.println(users.contains("Jack"));
// -&gt; prints false
******************************
Normalized:
Set&lt;String&gt; users = new HashSet&lt;&gt;(Arrays.asList("Alice", "Bob"));

System.out.println(users.contains("Alice"));
// -&gt; prints true

System.out.println(users.contains("Jack"));
// -&gt; prints false
******************************
Original:
@TestPropertySource(properties=
{"spring.autoconfigure.exclude=comma.seperated.ClassNames,com.example.FooAutoConfiguration"})
@SpringBootTest
public class MySpringTest {...}
******************************
Normalized:
******************************
Original:
@TestPropertySource(properties=
{"spring.autoconfigure.exclude=comma.seperated.ClassNames,com.example.FooAutoConfiguration"})
@SpringBootTest
public class MySpringTest {...}
******************************
Normalized:
@TestPropertySource(properties=
{"spring.autoconfigure.exclude=comma.seperated.ClassNames,com.example.FooAutoConfiguration"})
@SpringBootTest
public class MySpringTest {...}
******************************
Original:
// use '..' in the args expression if you have zero or more parameters at that point
@Before("execution(* com.mkyong.customer.bo.CustomerBo.addCustomer(..)) &amp;&amp; args(yourString,..)")
******************************
Normalized:
******************************
Original:
// use '..' in the args expression if you have zero or more parameters at that point
@Before("execution(* com.mkyong.customer.bo.CustomerBo.addCustomer(..)) &amp;&amp; args(yourString,..)")
******************************
Normalized:
// use '..' in the args expression if you have zero or more parameters at that point
@Before("execution(* com.mkyong.customer.bo.CustomerBo.addCustomer(..)) &amp;&amp; args(yourString,..)")
******************************
Original:
mvn eclipse:eclipse
******************************
Normalized:
******************************
Original:
mvn eclipse:eclipse
******************************
Normalized:
mvn eclipse:eclipse
******************************
Original:
java -cp "$LIB/*"
******************************
Normalized:
******************************
Original:
java -cp "$LIB/*"
******************************
Normalized:
java -cp "$LIB/*"
******************************
Original:
&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd" &gt;
&lt;log4j:configuration debug="false"&gt;

    &lt;appender name="default.console" class="org.apache.log4j.ConsoleAppender"&gt;
        &lt;param name="target" value="System.out" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="default.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/mylogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="another.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/anotherlogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;logger name="com.yourcompany.SomeClass" additivity="false"&gt;
        &lt;level value="debug" /&gt;
        &lt;appender-ref ref="another.file" /&gt;
    &lt;/logger&gt;

    &lt;root&gt;
        &lt;priority value="info" /&gt;
        &lt;appender-ref ref="default.console" /&gt;
        &lt;appender-ref ref="default.file" /&gt;
    &lt;/root&gt;
&lt;/log4j:configuration&gt;
******************************
Normalized:
******************************
Original:
&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd" &gt;
&lt;log4j:configuration debug="false"&gt;

    &lt;appender name="default.console" class="org.apache.log4j.ConsoleAppender"&gt;
        &lt;param name="target" value="System.out" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="default.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/mylogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="another.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/anotherlogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;logger name="com.yourcompany.SomeClass" additivity="false"&gt;
        &lt;level value="debug" /&gt;
        &lt;appender-ref ref="another.file" /&gt;
    &lt;/logger&gt;

    &lt;root&gt;
        &lt;priority value="info" /&gt;
        &lt;appender-ref ref="default.console" /&gt;
        &lt;appender-ref ref="default.file" /&gt;
    &lt;/root&gt;
&lt;/log4j:configuration&gt;
******************************
Normalized:
&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd" &gt;
&lt;log4j:configuration debug="false"&gt;

    &lt;appender name="default.console" class="org.apache.log4j.ConsoleAppender"&gt;
        &lt;param name="target" value="System.out" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="default.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/mylogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="another.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/anotherlogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;logger name="com.yourcompany.SomeClass" additivity="false"&gt;
        &lt;level value="debug" /&gt;
        &lt;appender-ref ref="another.file" /&gt;
    &lt;/logger&gt;

    &lt;root&gt;
        &lt;priority value="info" /&gt;
        &lt;appender-ref ref="default.console" /&gt;
        &lt;appender-ref ref="default.file" /&gt;
    &lt;/root&gt;
&lt;/log4j:configuration&gt;
******************************
Original:
Supplier&lt;List&lt;Shape&gt;&gt; supplier = () -&gt; new LinkedList&lt;Shape&gt;();

List&lt;Shape&gt; blue = shapes.stream()
            .filter(s -&gt; s.getColor() == BLUE)
            .collect(Collectors.toCollection(supplier));
******************************
Normalized:
******************************
Original:
Supplier&lt;List&lt;Shape&gt;&gt; supplier = () -&gt; new LinkedList&lt;Shape&gt;();

List&lt;Shape&gt; blue = shapes.stream()
            .filter(s -&gt; s.getColor() == BLUE)
            .collect(Collectors.toCollection(supplier));
******************************
Normalized:
Supplier&lt;List&lt;Shape&gt;&gt; supplier = () -&gt; new LinkedList&lt;Shape&gt;();

List&lt;Shape&gt; blue = shapes.stream()
            .filter(s -&gt; s.getColor() == BLUE)
            .collect(Collectors.toCollection(supplier));
******************************
Original:
Criterion topPercentFromRange(Comparator&lt;Widget&gt; cmp, double from, double to) {
    return stream -&gt; {
        List&lt;Widget&gt; temp =
            stream.sorted(cmp).collect(toList());
        return temp.stream()
                   .skip((long)(temp.size() * from))
                   .limit((long)(temp.size() * (to - from)));
    };
}
******************************
Normalized:
******************************
Original:
Criterion topPercentFromRange(Comparator&lt;Widget&gt; cmp, double from, double to) {
    return stream -&gt; {
        List&lt;Widget&gt; temp =
            stream.sorted(cmp).collect(toList());
        return temp.stream()
                   .skip((long)(temp.size() * from))
                   .limit((long)(temp.size() * (to - from)));
    };
}
******************************
Normalized:
Criterion topPercentFromRange(Comparator&lt;Widget&gt; cmp, double from, double to) {
    return stream -&gt; {
        List&lt;Widget&gt; temp =
            stream.sorted(cmp).collect(toList());
        return temp.stream()
                   .skip((long)(temp.size() * from))
                   .limit((long)(temp.size() * (to - from)));
    };
}
******************************
Original:
Scanner s = new Scanner(new File("filepath"));
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
while (s.hasNext()){
    list.add(s.next());
}
s.close();
******************************
Normalized:
******************************
Original:
Scanner s = new Scanner(new File("filepath"));
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
while (s.hasNext()){
    list.add(s.next());
}
s.close();
******************************
Normalized:
Scanner s = new Scanner(new File("filepath"));
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
while (s.hasNext()){
    list.add(s.next());
}
s.close();
******************************
Original:
Stream&lt;String&gt; texts = optional.stream();
******************************
Normalized:
******************************
Original:
Stream&lt;String&gt; texts = optional.stream();
******************************
Normalized:
Stream&lt;String&gt; texts = optional.stream();
******************************
Original:
ObjectListing listing = s3.listObjects( bucketName, prefix );
List&lt;S3ObjectSummary&gt; summaries = listing.getObjectSummaries();

while (listing.isTruncated()) {
   listing = s3.listNextBatchOfObjects (listing);
   summaries.addAll (listing.getObjectSummaries());
}
******************************
Normalized:
******************************
Original:
ObjectListing listing = s3.listObjects( bucketName, prefix );
List&lt;S3ObjectSummary&gt; summaries = listing.getObjectSummaries();

while (listing.isTruncated()) {
   listing = s3.listNextBatchOfObjects (listing);
   summaries.addAll (listing.getObjectSummaries());
}
******************************
Normalized:
ObjectListing listing = s3.listObjects( bucketName, prefix );
List&lt;S3ObjectSummary&gt; summaries = listing.getObjectSummaries();

while (listing.isTruncated()) {
   listing = s3.listNextBatchOfObjects (listing);
   summaries.addAll (listing.getObjectSummaries());
}
******************************
Original:
/*[local-name()='workbook'
    and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheets'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheet'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main'][1]
******************************
Normalized:
******************************
Original:
/*[local-name()='workbook'
    and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheets'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheet'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main'][1]
******************************
Normalized:
/*[local-name()='workbook'
    and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheets'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheet'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main'][1]
******************************
Original:
/**
 * Stateful filter. T is type of stream element, K is type of extracted key.
 */
static class DistinctByKey&lt;T,K&gt; {
    Map&lt;K,Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;();
    Function&lt;T,K&gt; keyExtractor;
    public DistinctByKey(Function&lt;T,K&gt; ke) {
        this.keyExtractor = ke;
    }
    public boolean filter(T t) {
        return seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
    }
}
******************************
Normalized:
******************************
Original:
/**
 * Stateful filter. T is type of stream element, K is type of extracted key.
 */
static class DistinctByKey&lt;T,K&gt; {
    Map&lt;K,Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;();
    Function&lt;T,K&gt; keyExtractor;
    public DistinctByKey(Function&lt;T,K&gt; ke) {
        this.keyExtractor = ke;
    }
    public boolean filter(T t) {
        return seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
    }
}
******************************
Normalized:
/**
 * Stateful filter. T is type of stream element, K is type of extracted key.
 */
static class DistinctByKey&lt;T,K&gt; {
    Map&lt;K,Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;();
    Function&lt;T,K&gt; keyExtractor;
    public DistinctByKey(Function&lt;T,K&gt; ke) {
        this.keyExtractor = ke;
    }
    public boolean filter(T t) {
        return seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
    }
}
******************************
Original:
List&lt;String&gt; species = Arrays.asList(speciesArr);
******************************
Normalized:
******************************
Original:
List&lt;String&gt; species = Arrays.asList(speciesArr);
******************************
Normalized:
List&lt;String&gt; species = Arrays.asList(speciesArr);
******************************
Original:
ObjectMapper mapper = new ObjectMapper();
Map&lt;String,Object&gt; map = mapper.readValue(json, Map.class);
******************************
Normalized:
******************************
Original:
ObjectMapper mapper = new ObjectMapper();
Map&lt;String,Object&gt; map = mapper.readValue(json, Map.class);
******************************
Normalized:
ObjectMapper mapper = new ObjectMapper();
Map&lt;String,Object&gt; map = mapper.readValue(json, Map.class);
******************************
Original:
for (initialization statement; condition check; update)
    loop body;
******************************
Normalized:
******************************
Original:
for (initialization statement; condition check; update)
    loop body;
******************************
Normalized:
for (initialization statement; condition check; update)
    loop body;
******************************
Original:
public class ArrayIndexComparator implements Comparator&lt;Integer&gt;
{
    private final String[] array;

    public ArrayIndexComparator(String[] array)
    {
        this.array = array;
    }

    public Integer[] createIndexArray()
    {
        Integer[] indexes = new Integer[array.length];
        for (int i = 0; i &lt; array.length; i++)
        {
            indexes[i] = i; // Autoboxing
        }
        return indexes;
    }

    @Override
    public int compare(Integer index1, Integer index2)
    {
         // Autounbox from Integer to int to use as array indexes
        return array[index1].compareTo(array[index2]);
    }
}
******************************
Normalized:
******************************
Original:
public class ArrayIndexComparator implements Comparator&lt;Integer&gt;
{
    private final String[] array;

    public ArrayIndexComparator(String[] array)
    {
        this.array = array;
    }

    public Integer[] createIndexArray()
    {
        Integer[] indexes = new Integer[array.length];
        for (int i = 0; i &lt; array.length; i++)
        {
            indexes[i] = i; // Autoboxing
        }
        return indexes;
    }

    @Override
    public int compare(Integer index1, Integer index2)
    {
         // Autounbox from Integer to int to use as array indexes
        return array[index1].compareTo(array[index2]);
    }
}
******************************
Normalized:
public class ArrayIndexComparator implements Comparator&lt;Integer&gt;
{
    private final String[] array;

    public ArrayIndexComparator(String[] array)
    {
        this.array = array;
    }

    public Integer[] createIndexArray()
    {
        Integer[] indexes = new Integer[array.length];
        for (int i = 0; i &lt; array.length; i++)
        {
            indexes[i] = i; // Autoboxing
        }
        return indexes;
    }

    @Override
    public int compare(Integer index1, Integer index2)
    {
         // Autounbox from Integer to int to use as array indexes
        return array[index1].compareTo(array[index2]);
    }
}
******************************
Original:
android {
    ....
    ....

    sourceSets {
        main.java.srcDirs += 'src/main/&lt;YOUR DIRECTORY&gt;'
    }

}
******************************
Normalized:
******************************
Original:
android {
    ....
    ....

    sourceSets {
        main.java.srcDirs += 'src/main/&lt;YOUR DIRECTORY&gt;'
    }

}
******************************
Normalized:
android {
    ....
    ....

    sourceSets {
        main.java.srcDirs += 'src/main/&lt;YOUR DIRECTORY&gt;'
    }

}
******************************
Original:
import org.mockito.internal.util.MockUtil;

new MockUtil().isMock(obj)
******************************
Normalized:
******************************
Original:
import org.mockito.internal.util.MockUtil;

new MockUtil().isMock(obj)
******************************
Normalized:
import org.mockito.internal.util.MockUtil;

new MockUtil().isMock(obj)
******************************
Original:
[A-Za-z0-9.,-:]*
******************************
Normalized:
******************************
Original:
[A-Za-z0-9.,-:]*
******************************
Normalized:
[A-Za-z0-9.,-:]*
******************************
Original:
Consumer&lt;String&gt; p = ""::equals;
******************************
Normalized:
******************************
Original:
Consumer&lt;String&gt; p = ""::equals;
******************************
Normalized:
Consumer&lt;String&gt; p = ""::equals;
******************************
Original:
# cat Athrow.j 
.source Athrow.j
.class public Athrow
.super java/lang/Object

.method public &lt;init&gt;()V
    aload_0
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    return
.end method

.method public static main([Ljava/lang/String;)V
    .limit stack 2

    new java/lang/Object
    dup
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    athrow

    return
.end method

# java -jar jasmin.jar Athrow.j 
Generated: Athrow.class

# java Athrow
Exception in thread "main" java.lang.VerifyError: (class: Athrow, method: main signature: ([Ljava/lang/String;)V) Can only throw Throwable objects
******************************
Normalized:
******************************
Original:
# cat Athrow.j 
.source Athrow.j
.class public Athrow
.super java/lang/Object

.method public &lt;init&gt;()V
    aload_0
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    return
.end method

.method public static main([Ljava/lang/String;)V
    .limit stack 2

    new java/lang/Object
    dup
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    athrow

    return
.end method

# java -jar jasmin.jar Athrow.j 
Generated: Athrow.class

# java Athrow
Exception in thread "main" java.lang.VerifyError: (class: Athrow, method: main signature: ([Ljava/lang/String;)V) Can only throw Throwable objects
******************************
Normalized:
# cat Athrow.j 
.source Athrow.j
.class public Athrow
.super java/lang/Object

.method public &lt;init&gt;()V
    aload_0
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    return
.end method

.method public static main([Ljava/lang/String;)V
    .limit stack 2

    new java/lang/Object
    dup
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    athrow

    return
.end method

# java -jar jasmin.jar Athrow.j 
Generated: Athrow.class

# java Athrow
Exception in thread "main" java.lang.VerifyError: (class: Athrow, method: main signature: ([Ljava/lang/String;)V) Can only throw Throwable objects
******************************
Original:
&lt;manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:sharedUserId="android.uid.shared"
    android:sharedUserLabel="@string/sharedUserLabel"
    ...&gt;
******************************
Normalized:
******************************
Original:
&lt;manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:sharedUserId="android.uid.shared"
    android:sharedUserLabel="@string/sharedUserLabel"
    ...&gt;
******************************
Normalized:
&lt;manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:sharedUserId="android.uid.shared"
    android:sharedUserLabel="@string/sharedUserLabel"
    ...&gt;
******************************
Original:
ExecutorService executor = Executors.newSingleThreadExecutor();

    // LAMBDA COMPILED INTO A 'Callable&lt;?&gt;'
    executor.submit(() -&gt; {
        while (true)
            throw new Exception();
    });

    // LAMBDA COMPILED INTO A 'Runnable': EXCEPTIONS MUST BE HANDLED BY LAMBDA ITSELF!
    executor.submit(() -&gt; {
        boolean value = true;
        while (value)
            throw new Exception();
    });
******************************
Normalized:
******************************
Original:
ExecutorService executor = Executors.newSingleThreadExecutor();

    // LAMBDA COMPILED INTO A 'Callable&lt;?&gt;'
    executor.submit(() -&gt; {
        while (true)
            throw new Exception();
    });

    // LAMBDA COMPILED INTO A 'Runnable': EXCEPTIONS MUST BE HANDLED BY LAMBDA ITSELF!
    executor.submit(() -&gt; {
        boolean value = true;
        while (value)
            throw new Exception();
    });
******************************
Normalized:
ExecutorService executor = Executors.newSingleThreadExecutor();

    // LAMBDA COMPILED INTO A 'Callable&lt;?&gt;'
    executor.submit(() -&gt; {
        while (true)
            throw new Exception();
    });

    // LAMBDA COMPILED INTO A 'Runnable': EXCEPTIONS MUST BE HANDLED BY LAMBDA ITSELF!
    executor.submit(() -&gt; {
        boolean value = true;
        while (value)
            throw new Exception();
    });
******************************
Original:
public void webmethod(@RequestParam("date") String strDate) {
    Date date = ... // manually parse the date
 }
******************************
Normalized:
******************************
Original:
public void webmethod(@RequestParam("date") String strDate) {
    Date date = ... // manually parse the date
 }
******************************
Normalized:
public void webmethod(@RequestParam("date") String strDate) {
    Date date = ... // manually parse the date
 }
******************************
Original:
(throws IOException)

Image image = null;
try {
    URL url = new URL("http://www.yahoo.com/image_to_read.jpg");
    image = ImageIO.read(url);
} catch (IOException e) {
}
******************************
Normalized:
******************************
Original:
(throws IOException)

Image image = null;
try {
    URL url = new URL("http://www.yahoo.com/image_to_read.jpg");
    image = ImageIO.read(url);
} catch (IOException e) {
}
******************************
Normalized:
(throws IOException)

Image image = null;
try {
    URL url = new URL("http://www.yahoo.com/image_to_read.jpg");
    image = ImageIO.read(url);
} catch (IOException e) {
}
******************************
Original:
&lt;style name="MyTheme" parent="android:Theme.Holo.Light"&gt;
    &lt;item name="actionButtonStyle"&gt;@style/MyActionButtonStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="MyActionButtonStyle" parent="Widget.ActionButton"&gt;
    &lt;item name="android:minWidth"&gt;28dip&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
******************************
Original:
&lt;style name="MyTheme" parent="android:Theme.Holo.Light"&gt;
    &lt;item name="actionButtonStyle"&gt;@style/MyActionButtonStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="MyActionButtonStyle" parent="Widget.ActionButton"&gt;
    &lt;item name="android:minWidth"&gt;28dip&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
&lt;style name="MyTheme" parent="android:Theme.Holo.Light"&gt;
    &lt;item name="actionButtonStyle"&gt;@style/MyActionButtonStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="MyActionButtonStyle" parent="Widget.ActionButton"&gt;
    &lt;item name="android:minWidth"&gt;28dip&lt;/item&gt;
&lt;/style&gt;
******************************
Original:
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;

    &lt;style name="boldText"&gt;
        &lt;item name="android:textStyle"&gt;bold|italic&lt;/item&gt;
        &lt;item name="android:textColor"&gt;#FFFFFF&lt;/item&gt;
    &lt;/style&gt;

    &lt;style name="normalText"&gt;
        &lt;item name="android:textStyle"&gt;normal&lt;/item&gt;
        &lt;item name="android:textColor"&gt;#C0C0C0&lt;/item&gt;
    &lt;/style&gt;

&lt;/resources&gt;
******************************
Normalized:
******************************
Original:
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;

    &lt;style name="boldText"&gt;
        &lt;item name="android:textStyle"&gt;bold|italic&lt;/item&gt;
        &lt;item name="android:textColor"&gt;#FFFFFF&lt;/item&gt;
    &lt;/style&gt;

    &lt;style name="normalText"&gt;
        &lt;item name="android:textStyle"&gt;normal&lt;/item&gt;
        &lt;item name="android:textColor"&gt;#C0C0C0&lt;/item&gt;
    &lt;/style&gt;

&lt;/resources&gt;
******************************
Normalized:
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;

    &lt;style name="boldText"&gt;
        &lt;item name="android:textStyle"&gt;bold|italic&lt;/item&gt;
        &lt;item name="android:textColor"&gt;#FFFFFF&lt;/item&gt;
    &lt;/style&gt;

    &lt;style name="normalText"&gt;
        &lt;item name="android:textStyle"&gt;normal&lt;/item&gt;
        &lt;item name="android:textColor"&gt;#C0C0C0&lt;/item&gt;
    &lt;/style&gt;

&lt;/resources&gt;
******************************
Original:
LocalDate date = ...;
ZoneId zoneId = ZoneId.systemDefault(); // or: ZoneId.of("Europe/Oslo");
long epoch = date.atStartOfDay(zoneId).toEpochSecond();
******************************
Normalized:
******************************
Original:
LocalDate date = ...;
ZoneId zoneId = ZoneId.systemDefault(); // or: ZoneId.of("Europe/Oslo");
long epoch = date.atStartOfDay(zoneId).toEpochSecond();
******************************
Normalized:
LocalDate date = ...;
ZoneId zoneId = ZoneId.systemDefault(); // or: ZoneId.of("Europe/Oslo");
long epoch = date.atStartOfDay(zoneId).toEpochSecond();
******************************
Original:
keytool -import -file &lt;the cert file&gt; -alias &lt;some meaningful name&gt; -keystore &lt;path to cacerts file&gt;
******************************
Normalized:
******************************
Original:
keytool -import -file &lt;the cert file&gt; -alias &lt;some meaningful name&gt; -keystore &lt;path to cacerts file&gt;
******************************
Normalized:
keytool -import -file &lt;the cert file&gt; -alias &lt;some meaningful name&gt; -keystore &lt;path to cacerts file&gt;
******************************
Original:
public class UserEventDeserializer extends StdDeserializer&lt;User&gt; implements ResolvableDeserializer
{
  private static final long serialVersionUID = 7923585097068641765L;

  private final JsonDeserializer&lt;?&gt; defaultDeserializer;

  public UserEventDeserializer(JsonDeserializer&lt;?&gt; defaultDeserializer)
  {
    super(User.class);
    this.defaultDeserializer = defaultDeserializer;
  }

  @Override public User deserialize(JsonParser jp, DeserializationContext ctxt)
      throws IOException, JsonProcessingException
  {
    User deserializedUser = (User) defaultDeserializer.deserialize(jp, ctxt);

    // Special logic

    return deserializedUser;
  }

  // for some reason you have to implement ResolvableDeserializer when modifying BeanDeserializer
  // otherwise deserializing throws JsonMappingException??
  @Override public void resolve(DeserializationContext ctxt) throws JsonMappingException
  {
    ((ResolvableDeserializer) defaultDeserializer).resolve(ctxt);
  }


  public static void main(String[] args) throws JsonParseException, JsonMappingException, IOException
  {
    SimpleModule module = new SimpleModule();
    module.setDeserializerModifier(new BeanDeserializerModifier()
    {
      @Override public JsonDeserializer&lt;?&gt; modifyDeserializer(DeserializationConfig config, BeanDescription beanDesc, JsonDeserializer&lt;?&gt; deserializer)
      {
        if (beanDesc.getBeanClass() == User.class)
          return new UserEventDeserializer(deserializer);
        return deserializer;
      }
    });


    ObjectMapper mapper = new ObjectMapper();
    mapper.registerModule(module);
    User user = mapper.readValue(new File("test.json"), User.class);
  }
}
******************************
Normalized:
******************************
Original:
public class UserEventDeserializer extends StdDeserializer&lt;User&gt; implements ResolvableDeserializer
{
  private static final long serialVersionUID = 7923585097068641765L;

  private final JsonDeserializer&lt;?&gt; defaultDeserializer;

  public UserEventDeserializer(JsonDeserializer&lt;?&gt; defaultDeserializer)
  {
    super(User.class);
    this.defaultDeserializer = defaultDeserializer;
  }

  @Override public User deserialize(JsonParser jp, DeserializationContext ctxt)
      throws IOException, JsonProcessingException
  {
    User deserializedUser = (User) defaultDeserializer.deserialize(jp, ctxt);

    // Special logic

    return deserializedUser;
  }

  // for some reason you have to implement ResolvableDeserializer when modifying BeanDeserializer
  // otherwise deserializing throws JsonMappingException??
  @Override public void resolve(DeserializationContext ctxt) throws JsonMappingException
  {
    ((ResolvableDeserializer) defaultDeserializer).resolve(ctxt);
  }


  public static void main(String[] args) throws JsonParseException, JsonMappingException, IOException
  {
    SimpleModule module = new SimpleModule();
    module.setDeserializerModifier(new BeanDeserializerModifier()
    {
      @Override public JsonDeserializer&lt;?&gt; modifyDeserializer(DeserializationConfig config, BeanDescription beanDesc, JsonDeserializer&lt;?&gt; deserializer)
      {
        if (beanDesc.getBeanClass() == User.class)
          return new UserEventDeserializer(deserializer);
        return deserializer;
      }
    });


    ObjectMapper mapper = new ObjectMapper();
    mapper.registerModule(module);
    User user = mapper.readValue(new File("test.json"), User.class);
  }
}
******************************
Normalized:
public class UserEventDeserializer extends StdDeserializer&lt;User&gt; implements ResolvableDeserializer
{
  private static final long serialVersionUID = 7923585097068641765L;

  private final JsonDeserializer&lt;?&gt; defaultDeserializer;

  public UserEventDeserializer(JsonDeserializer&lt;?&gt; defaultDeserializer)
  {
    super(User.class);
    this.defaultDeserializer = defaultDeserializer;
  }

  @Override public User deserialize(JsonParser jp, DeserializationContext ctxt)
      throws IOException, JsonProcessingException
  {
    User deserializedUser = (User) defaultDeserializer.deserialize(jp, ctxt);

    // Special logic

    return deserializedUser;
  }

  // for some reason you have to implement ResolvableDeserializer when modifying BeanDeserializer
  // otherwise deserializing throws JsonMappingException??
  @Override public void resolve(DeserializationContext ctxt) throws JsonMappingException
  {
    ((ResolvableDeserializer) defaultDeserializer).resolve(ctxt);
  }


  public static void main(String[] args) throws JsonParseException, JsonMappingException, IOException
  {
    SimpleModule module = new SimpleModule();
    module.setDeserializerModifier(new BeanDeserializerModifier()
    {
      @Override public JsonDeserializer&lt;?&gt; modifyDeserializer(DeserializationConfig config, BeanDescription beanDesc, JsonDeserializer&lt;?&gt; deserializer)
      {
        if (beanDesc.getBeanClass() == User.class)
          return new UserEventDeserializer(deserializer);
        return deserializer;
      }
    });


    ObjectMapper mapper = new ObjectMapper();
    mapper.registerModule(module);
    User user = mapper.readValue(new File("test.json"), User.class);
  }
}
******************************
Original:
List&lt;String&gt; myList = new ArrayList&lt;String&gt;(Arrays.asList(s.split(",")));
******************************
Normalized:
******************************
Original:
List&lt;String&gt; myList = new ArrayList&lt;String&gt;(Arrays.asList(s.split(",")));
******************************
Normalized:
List&lt;String&gt; myList = new ArrayList&lt;String&gt;(Arrays.asList(s.split(",")));
******************************
Original:
Benchmark           Mode  Cnt         Score        Error  Units
MyBenchmark.test1  thrpt   20  10463220.493 ± 288805.068  ops/s
MyBenchmark.test2  thrpt   20  14730158.709 ± 530444.444  ops/s
MyBenchmark.test3  thrpt   20  16079551.751 ±  56884.357  ops/s
MyBenchmark.test4  thrpt   20   9762578.446 ± 584316.582  ops/s
MyBenchmark.test5  thrpt   20   6093216.066 ± 180062.872  ops/s
MyBenchmark.test6  thrpt   20   2104102.578 ±  18705.805  ops/s
******************************
Normalized:
******************************
Original:
Benchmark           Mode  Cnt         Score        Error  Units
MyBenchmark.test1  thrpt   20  10463220.493 ± 288805.068  ops/s
MyBenchmark.test2  thrpt   20  14730158.709 ± 530444.444  ops/s
MyBenchmark.test3  thrpt   20  16079551.751 ±  56884.357  ops/s
MyBenchmark.test4  thrpt   20   9762578.446 ± 584316.582  ops/s
MyBenchmark.test5  thrpt   20   6093216.066 ± 180062.872  ops/s
MyBenchmark.test6  thrpt   20   2104102.578 ±  18705.805  ops/s
******************************
Normalized:
Benchmark           Mode  Cnt         Score        Error  Units
MyBenchmark.test1  thrpt   20  10463220.493 ± 288805.068  ops/s
MyBenchmark.test2  thrpt   20  14730158.709 ± 530444.444  ops/s
MyBenchmark.test3  thrpt   20  16079551.751 ±  56884.357  ops/s
MyBenchmark.test4  thrpt   20   9762578.446 ± 584316.582  ops/s
MyBenchmark.test5  thrpt   20   6093216.066 ± 180062.872  ops/s
MyBenchmark.test6  thrpt   20   2104102.578 ±  18705.805  ops/s
******************************
Original:
qsort []     = []
qsort (x:xs) = qsort lesser ++ [x] ++ qsort greater
    where lesser  = (filter (&lt; x) xs)
          greater = (filter (&gt;= x) xs)
******************************
Normalized:
******************************
Original:
qsort []     = []
qsort (x:xs) = qsort lesser ++ [x] ++ qsort greater
    where lesser  = (filter (&lt; x) xs)
          greater = (filter (&gt;= x) xs)
******************************
Normalized:
qsort []     = []
qsort (x:xs) = qsort lesser ++ [x] ++ qsort greater
    where lesser  = (filter (&lt; x) xs)
          greater = (filter (&gt;= x) xs)
******************************
Original:
test {
    systemProperty "cassandra.ip", project.getProperty("cassandra.ip")
}
******************************
Normalized:
******************************
Original:
test {
    systemProperty "cassandra.ip", project.getProperty("cassandra.ip")
}
******************************
Normalized:
test {
    systemProperty "cassandra.ip", project.getProperty("cassandra.ip")
}
******************************
Original:
super();
******************************
Normalized:
******************************
Original:
super();
******************************
Normalized:
super();
******************************
Original:
Current thread (0x0805ac88):  JavaThread "main" [_thread_in_native, id=21139]
                    |             |         |            |          +-- ID
                    |             |         |            +------------- state
                    |             |         +-------------------------- name
                    |             +------------------------------------ type
                    +-------------------------------------------------- pointer
******************************
Normalized:
******************************
Original:
Current thread (0x0805ac88):  JavaThread "main" [_thread_in_native, id=21139]
                    |             |         |            |          +-- ID
                    |             |         |            +------------- state
                    |             |         +-------------------------- name
                    |             +------------------------------------ type
                    +-------------------------------------------------- pointer
******************************
Normalized:
Current thread (0x0805ac88):  JavaThread "main" [_thread_in_native, id=21139]
                    |             |         |            |          +-- ID
                    |             |         |            +------------- state
                    |             |         +-------------------------- name
                    |             +------------------------------------ type
                    +-------------------------------------------------- pointer
******************************
Original:
// extend LinkedBlockingQueue to force offer() to return false conditionally
BlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;Runnable&gt;() {
    private static final long serialVersionUID = -6903933921423432194L;
    @Override
    public boolean offer(Runnable e) {
        // Offer it to the queue if there is 0 items already queued, else
        // return false so the TPE will add another thread. If we return false
        // and max threads have been reached then the RejectedExecutionHandler
        // will be called which will do the put into the queue.
        if (size() == 0) {
            return super.offer(e);
        } else {
            return false;
        }
    }
};
ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1 /*core*/, 50 /*max*/,
        60 /*secs*/, TimeUnit.SECONDS, queue);
threadPool.setRejectedExecutionHandler(new RejectedExecutionHandler() {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        try {
            // This does the actual put into the queue. Once the max threads
            //  have been reached, the tasks will then queue up.
            executor.getQueue().put(r);
            // we do this after the put() to stop race conditions
            if (executor.isShutdown()) {
                throw new RejectedExecutionException(
                    "Task " + r + " rejected from " + e);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return;
        }
    }
});
******************************
Normalized:
******************************
Original:
// extend LinkedBlockingQueue to force offer() to return false conditionally
BlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;Runnable&gt;() {
    private static final long serialVersionUID = -6903933921423432194L;
    @Override
    public boolean offer(Runnable e) {
        // Offer it to the queue if there is 0 items already queued, else
        // return false so the TPE will add another thread. If we return false
        // and max threads have been reached then the RejectedExecutionHandler
        // will be called which will do the put into the queue.
        if (size() == 0) {
            return super.offer(e);
        } else {
            return false;
        }
    }
};
ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1 /*core*/, 50 /*max*/,
        60 /*secs*/, TimeUnit.SECONDS, queue);
threadPool.setRejectedExecutionHandler(new RejectedExecutionHandler() {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        try {
            // This does the actual put into the queue. Once the max threads
            //  have been reached, the tasks will then queue up.
            executor.getQueue().put(r);
            // we do this after the put() to stop race conditions
            if (executor.isShutdown()) {
                throw new RejectedExecutionException(
                    "Task " + r + " rejected from " + e);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return;
        }
    }
});
******************************
Normalized:
// extend LinkedBlockingQueue to force offer() to return false conditionally
BlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;Runnable&gt;() {
    private static final long serialVersionUID = -6903933921423432194L;
    @Override
    public boolean offer(Runnable e) {
        // Offer it to the queue if there is 0 items already queued, else
        // return false so the TPE will add another thread. If we return false
        // and max threads have been reached then the RejectedExecutionHandler
        // will be called which will do the put into the queue.
        if (size() == 0) {
            return super.offer(e);
        } else {
            return false;
        }
    }
};
ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1 /*core*/, 50 /*max*/,
        60 /*secs*/, TimeUnit.SECONDS, queue);
threadPool.setRejectedExecutionHandler(new RejectedExecutionHandler() {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        try {
            // This does the actual put into the queue. Once the max threads
            //  have been reached, the tasks will then queue up.
            executor.getQueue().put(r);
            // we do this after the put() to stop race conditions
            if (executor.isShutdown()) {
                throw new RejectedExecutionException(
                    "Task " + r + " rejected from " + e);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return;
        }
    }
});
******************************
Original:
&lt;properties&gt;
    &lt;!-- ... --&gt;
    &lt;maven-jar-plugin.version&gt;3.1.1&lt;/maven-jar-plugin.version&gt;
&lt;/properties&gt;
******************************
Normalized:
******************************
Original:
&lt;properties&gt;
    &lt;!-- ... --&gt;
    &lt;maven-jar-plugin.version&gt;3.1.1&lt;/maven-jar-plugin.version&gt;
&lt;/properties&gt;
******************************
Normalized:
&lt;properties&gt;
    &lt;!-- ... --&gt;
    &lt;maven-jar-plugin.version&gt;3.1.1&lt;/maven-jar-plugin.version&gt;
&lt;/properties&gt;
******************************
Original:
&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.7&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;add-source&lt;/id&gt;
            &lt;phase&gt;generate-sources&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;add-source&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;sources&gt;
                &lt;source&gt;some directory&lt;/source&gt;
                ...
              &lt;/sources&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
******************************
Normalized:
******************************
Original:
&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.7&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;add-source&lt;/id&gt;
            &lt;phase&gt;generate-sources&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;add-source&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;sources&gt;
                &lt;source&gt;some directory&lt;/source&gt;
                ...
              &lt;/sources&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
******************************
Normalized:
&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.7&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;add-source&lt;/id&gt;
            &lt;phase&gt;generate-sources&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;add-source&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;sources&gt;
                &lt;source&gt;some directory&lt;/source&gt;
                ...
              &lt;/sources&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
******************************
Original:
Months.values()[index]
******************************
Normalized:
******************************
Original:
Months.values()[index]
******************************
Normalized:
Months.values()[index]
******************************
Original:
Object
     /      \
    /        \
String     Integer
******************************
Normalized:
******************************
Original:
Object
     /      \
    /        \
String     Integer
******************************
Normalized:
Object
     /      \
    /        \
String     Integer
******************************
Original:
public void restartApplication()
{
  final String javaBin = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
  final File currentJar = new File(MyClassInTheJar.class.getProtectionDomain().getCodeSource().getLocation().toURI());

  /* is it a jar file? */
  if(!currentJar.getName().endsWith(".jar"))
    return;

  /* Build command: java -jar application.jar */
  final ArrayList&lt;String&gt; command = new ArrayList&lt;String&gt;();
  command.add(javaBin);
  command.add("-jar");
  command.add(currentJar.getPath());

  final ProcessBuilder builder = new ProcessBuilder(command);
  builder.start();
  System.exit(0);
}
******************************
Normalized:
******************************
Original:
public void restartApplication()
{
  final String javaBin = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
  final File currentJar = new File(MyClassInTheJar.class.getProtectionDomain().getCodeSource().getLocation().toURI());

  /* is it a jar file? */
  if(!currentJar.getName().endsWith(".jar"))
    return;

  /* Build command: java -jar application.jar */
  final ArrayList&lt;String&gt; command = new ArrayList&lt;String&gt;();
  command.add(javaBin);
  command.add("-jar");
  command.add(currentJar.getPath());

  final ProcessBuilder builder = new ProcessBuilder(command);
  builder.start();
  System.exit(0);
}
******************************
Normalized:
public void restartApplication()
{
  final String javaBin = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
  final File currentJar = new File(MyClassInTheJar.class.getProtectionDomain().getCodeSource().getLocation().toURI());

  /* is it a jar file? */
  if(!currentJar.getName().endsWith(".jar"))
    return;

  /* Build command: java -jar application.jar */
  final ArrayList&lt;String&gt; command = new ArrayList&lt;String&gt;();
  command.add(javaBin);
  command.add("-jar");
  command.add(currentJar.getPath());

  final ProcessBuilder builder = new ProcessBuilder(command);
  builder.start();
  System.exit(0);
}
******************************
Original:
&lt;A&gt; List&lt;A&gt; flatten(List&lt;List&lt;A&gt;&gt; nestedLists);
******************************
Normalized:
******************************
Original:
&lt;A&gt; List&lt;A&gt; flatten(List&lt;List&lt;A&gt;&gt; nestedLists);
******************************
Normalized:
&lt;A&gt; List&lt;A&gt; flatten(List&lt;List&lt;A&gt;&gt; nestedLists);
******************************
Original:
import java.nio.FloatBuffer;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

@Platform(include = "Dot.h", compiler = "fastfpu")
public class Dot {
    static { Loader.load(); }

    static float[] a = new float[50], b = new float[50];
    static float dot() {
        float sum = 0;
        for (int i = 0; i &lt; 50; i++) {
            sum += a[i]*b[i];
        }
        return sum;
    }
    static native @MemberGetter FloatPointer ac();
    static native @MemberGetter FloatPointer bc();
    static native @NoException float dotc();

    public static void main(String[] args) {
        FloatBuffer ab = ac().capacity(50).asBuffer();
        FloatBuffer bb = bc().capacity(50).asBuffer();

        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t1 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
        }
        long t2 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t3 = System.nanoTime();
        System.out.println("dot(): " + (t2 - t1)/10000000 + " ns");
        System.out.println("dotc(): "  + (t3 - t2)/10000000 + " ns");
    }
}
******************************
Normalized:
******************************
Original:
import java.nio.FloatBuffer;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

@Platform(include = "Dot.h", compiler = "fastfpu")
public class Dot {
    static { Loader.load(); }

    static float[] a = new float[50], b = new float[50];
    static float dot() {
        float sum = 0;
        for (int i = 0; i &lt; 50; i++) {
            sum += a[i]*b[i];
        }
        return sum;
    }
    static native @MemberGetter FloatPointer ac();
    static native @MemberGetter FloatPointer bc();
    static native @NoException float dotc();

    public static void main(String[] args) {
        FloatBuffer ab = ac().capacity(50).asBuffer();
        FloatBuffer bb = bc().capacity(50).asBuffer();

        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t1 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
        }
        long t2 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t3 = System.nanoTime();
        System.out.println("dot(): " + (t2 - t1)/10000000 + " ns");
        System.out.println("dotc(): "  + (t3 - t2)/10000000 + " ns");
    }
}
******************************
Normalized:
import java.nio.FloatBuffer;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

@Platform(include = "Dot.h", compiler = "fastfpu")
public class Dot {
    static { Loader.load(); }

    static float[] a = new float[50], b = new float[50];
    static float dot() {
        float sum = 0;
        for (int i = 0; i &lt; 50; i++) {
            sum += a[i]*b[i];
        }
        return sum;
    }
    static native @MemberGetter FloatPointer ac();
    static native @MemberGetter FloatPointer bc();
    static native @NoException float dotc();

    public static void main(String[] args) {
        FloatBuffer ab = ac().capacity(50).asBuffer();
        FloatBuffer bb = bc().capacity(50).asBuffer();

        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t1 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
        }
        long t2 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t3 = System.nanoTime();
        System.out.println("dot(): " + (t2 - t1)/10000000 + " ns");
        System.out.println("dotc(): "  + (t3 - t2)/10000000 + " ns");
    }
}
******************************
Original:
&lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;!-- config the location(s) of the properties file(s) here --&gt;
    &lt;property name="nullValue" value="@null" /&gt;
&lt;/bean&gt;
******************************
Normalized:
******************************
Original:
&lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;!-- config the location(s) of the properties file(s) here --&gt;
    &lt;property name="nullValue" value="@null" /&gt;
&lt;/bean&gt;
******************************
Normalized:
&lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;!-- config the location(s) of the properties file(s) here --&gt;
    &lt;property name="nullValue" value="@null" /&gt;
&lt;/bean&gt;
******************************
Original:
File[] files = XMLDirectory.listFiles(filter_xml_files);
Arrays.sort(files);
for(File _xml_file : files) {
    ...
}
******************************
Normalized:
******************************
Original:
File[] files = XMLDirectory.listFiles(filter_xml_files);
Arrays.sort(files);
for(File _xml_file : files) {
    ...
}
******************************
Normalized:
File[] files = XMLDirectory.listFiles(filter_xml_files);
Arrays.sort(files);
for(File _xml_file : files) {
    ...
}
******************************
Original:
configurations {
  runtime.exclude group: "org.slf4j", module: "slf4j-log4j12"
}
******************************
Normalized:
******************************
Original:
configurations {
  runtime.exclude group: "org.slf4j", module: "slf4j-log4j12"
}
******************************
Normalized:
configurations {
  runtime.exclude group: "org.slf4j", module: "slf4j-log4j12"
}
******************************
Original:
ObjectMapper mapper = new ObjectMapper();
mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
// do various things, perhaps:
String someJsonString = mapper.writeValueAsString(someClassInstance);
SomeClass someClassInstance = mapper.readValue(someJsonString, SomeClass.class)
******************************
Normalized:
******************************
Original:
ObjectMapper mapper = new ObjectMapper();
mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
// do various things, perhaps:
String someJsonString = mapper.writeValueAsString(someClassInstance);
SomeClass someClassInstance = mapper.readValue(someJsonString, SomeClass.class)
******************************
Normalized:
ObjectMapper mapper = new ObjectMapper();
mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
// do various things, perhaps:
String someJsonString = mapper.writeValueAsString(someClassInstance);
SomeClass someClassInstance = mapper.readValue(someJsonString, SomeClass.class)
******************************
Original:
bootRun {
   jvmArgs = "-Dhttp.proxyHost=xxxxxx", "-Dhttp.proxyPort=xxxxxx"
}
******************************
Normalized:
******************************
Original:
bootRun {
   jvmArgs = "-Dhttp.proxyHost=xxxxxx", "-Dhttp.proxyPort=xxxxxx"
}
******************************
Normalized:
bootRun {
   jvmArgs = "-Dhttp.proxyHost=xxxxxx", "-Dhttp.proxyPort=xxxxxx"
}
******************************
Original:
apply plugin: "java"

sourceSets {
    // Note that just declaring this sourceset creates two configurations.
    intTest {
        java {
            compileClasspath += main.output
            runtimeClasspath += main.output
        }
    }
}

configurations {
    intTestCompile.extendsFrom testCompile
    intTestRuntime.extendsFrom testRuntime
}

task intTest(type:Test){
    description = "Run integration tests (located in src/intTest/...)."
    testClassesDir = project.sourceSets.intTest.output.classesDir
    classpath = project.sourceSets.intTest.runtimeClasspath
}
******************************
Normalized:
******************************
Original:
apply plugin: "java"

sourceSets {
    // Note that just declaring this sourceset creates two configurations.
    intTest {
        java {
            compileClasspath += main.output
            runtimeClasspath += main.output
        }
    }
}

configurations {
    intTestCompile.extendsFrom testCompile
    intTestRuntime.extendsFrom testRuntime
}

task intTest(type:Test){
    description = "Run integration tests (located in src/intTest/...)."
    testClassesDir = project.sourceSets.intTest.output.classesDir
    classpath = project.sourceSets.intTest.runtimeClasspath
}
******************************
Normalized:
apply plugin: "java"

sourceSets {
    // Note that just declaring this sourceset creates two configurations.
    intTest {
        java {
            compileClasspath += main.output
            runtimeClasspath += main.output
        }
    }
}

configurations {
    intTestCompile.extendsFrom testCompile
    intTestRuntime.extendsFrom testRuntime
}

task intTest(type:Test){
    description = "Run integration tests (located in src/intTest/...)."
    testClassesDir = project.sourceSets.intTest.output.classesDir
    classpath = project.sourceSets.intTest.runtimeClasspath
}
******************************
Original:
Runnable r = new Runnable() {
   public void run() { ... }
};
******************************
Normalized:
******************************
Original:
Runnable r = new Runnable() {
   public void run() { ... }
};
******************************
Normalized:
Runnable r = new Runnable() {
   public void run() { ... }
};
******************************
Original:
String getMonthForInt(int num) {
        String month = "wrong";
        DateFormatSymbols dfs = new DateFormatSymbols();
        String[] months = dfs.getMonths();
        if (num &gt;= 0 &amp;&amp; num &lt;= 11 ) {
            month = months[num];
        }
        return month;
    }
******************************
Normalized:
******************************
Original:
String getMonthForInt(int num) {
        String month = "wrong";
        DateFormatSymbols dfs = new DateFormatSymbols();
        String[] months = dfs.getMonths();
        if (num &gt;= 0 &amp;&amp; num &lt;= 11 ) {
            month = months[num];
        }
        return month;
    }
******************************
Normalized:
String getMonthForInt(int num) {
        String month = "wrong";
        DateFormatSymbols dfs = new DateFormatSymbols();
        String[] months = dfs.getMonths();
        if (num &gt;= 0 &amp;&amp; num &lt;= 11 ) {
            month = months[num];
        }
        return month;
    }
******************************
Original:
@Entity
class Employee {
     :
    @OneToOne(cascade=CascadeType.REMOVE)
    private Address address;
     :
}
******************************
Normalized:
******************************
Original:
@Entity
class Employee {
     :
    @OneToOne(cascade=CascadeType.REMOVE)
    private Address address;
     :
}
******************************
Normalized:
@Entity
class Employee {
     :
    @OneToOne(cascade=CascadeType.REMOVE)
    private Address address;
     :
}
******************************
Original:
spring.jackson.serialization-inclusion=non_null
******************************
Normalized:
******************************
Original:
spring.jackson.serialization-inclusion=non_null
******************************
Normalized:
spring.jackson.serialization-inclusion=non_null
******************************
Original:
List&lt;String&gt; strings = list.stream()
   .map(object -&gt; Objects.toString(object, null))
   .collect(Collectors.toList());
******************************
Normalized:
******************************
Original:
List&lt;String&gt; strings = list.stream()
   .map(object -&gt; Objects.toString(object, null))
   .collect(Collectors.toList());
******************************
Normalized:
List&lt;String&gt; strings = list.stream()
   .map(object -&gt; Objects.toString(object, null))
   .collect(Collectors.toList());
******************************
Original:
&lt;build&gt;
  &lt;plugins&gt; 
    &lt;plugin&gt;
      &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;id&gt;attach-sources&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar-no-fork&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;attach-javadocs&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;!-- explicitly define maven-deploy-plugin after other to force exec order --&gt;
      &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;deploy&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;deploy&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
  &lt;/plugins&gt; 
&lt;/build&gt;
******************************
Normalized:
******************************
Original:
&lt;build&gt;
  &lt;plugins&gt; 
    &lt;plugin&gt;
      &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;id&gt;attach-sources&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar-no-fork&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;attach-javadocs&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;!-- explicitly define maven-deploy-plugin after other to force exec order --&gt;
      &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;deploy&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;deploy&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
  &lt;/plugins&gt; 
&lt;/build&gt;
******************************
Normalized:
&lt;build&gt;
  &lt;plugins&gt; 
    &lt;plugin&gt;
      &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;id&gt;attach-sources&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar-no-fork&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;attach-javadocs&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;!-- explicitly define maven-deploy-plugin after other to force exec order --&gt;
      &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;deploy&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;deploy&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
  &lt;/plugins&gt; 
&lt;/build&gt;
******************************
Original:
dependencies {
    ...
    testCompile "junit:junit:4.11"  // Or whatever version
}
******************************
Normalized:
******************************
Original:
dependencies {
    ...
    testCompile "junit:junit:4.11"  // Or whatever version
}
******************************
Normalized:
dependencies {
    ...
    testCompile "junit:junit:4.11"  // Or whatever version
}
******************************
Original:
public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(
    Collection&lt;? extends T&gt; coll
)
******************************
Normalized:
******************************
Original:
public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(
    Collection&lt;? extends T&gt; coll
)
******************************
Normalized:
public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(
    Collection&lt;? extends T&gt; coll
)
******************************
Original:
public static boolean isBetween(int x, int lower, int upper) {
  return lower &lt;= x &amp;&amp; x &lt;= upper;
}

if (isBetween(num, 1, 5)) {
  System.out.println("testing case 1 to 5");
} else if (isBetween(num, 6, 10)) {
  System.out.println("testing case 6 to 10");
}
******************************
Normalized:
******************************
Original:
public static boolean isBetween(int x, int lower, int upper) {
  return lower &lt;= x &amp;&amp; x &lt;= upper;
}

if (isBetween(num, 1, 5)) {
  System.out.println("testing case 1 to 5");
} else if (isBetween(num, 6, 10)) {
  System.out.println("testing case 6 to 10");
}
******************************
Normalized:
public static boolean isBetween(int x, int lower, int upper) {
  return lower &lt;= x &amp;&amp; x &lt;= upper;
}

if (isBetween(num, 1, 5)) {
  System.out.println("testing case 1 to 5");
} else if (isBetween(num, 6, 10)) {
  System.out.println("testing case 6 to 10");
}
******************************
Original:
ObjectMapper objectMapper = new ObjectMapper();
TypeFactory typeFactory = objectMapper.getTypeFactory();
List&lt;SomeClass&gt; someClassList = objectMapper.readValue(jsonString, typeFactory.constructCollectionType(List.class, SomeClass.class));
******************************
Normalized:
******************************
Original:
ObjectMapper objectMapper = new ObjectMapper();
TypeFactory typeFactory = objectMapper.getTypeFactory();
List&lt;SomeClass&gt; someClassList = objectMapper.readValue(jsonString, typeFactory.constructCollectionType(List.class, SomeClass.class));
******************************
Normalized:
ObjectMapper objectMapper = new ObjectMapper();
TypeFactory typeFactory = objectMapper.getTypeFactory();
List&lt;SomeClass&gt; someClassList = objectMapper.readValue(jsonString, typeFactory.constructCollectionType(List.class, SomeClass.class));
******************************
Original:
packagingOptions {
   pickFirst  'META-INF/license.txt'
}
******************************
Normalized:
******************************
Original:
packagingOptions {
   pickFirst  'META-INF/license.txt'
}
******************************
Normalized:
packagingOptions {
   pickFirst  'META-INF/license.txt'
}
******************************
Original:
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
******************************
Normalized:
******************************
Original:
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
******************************
Normalized:
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
******************************
Original:
object ScannerTest {
  def main(args: Array[String]) {
    var ok = true
    while (ok) {
      val ln = readLine()
      ok = ln != null
      if (ok) println(ln)
    }
  }
}
******************************
Normalized:
******************************
Original:
object ScannerTest {
  def main(args: Array[String]) {
    var ok = true
    while (ok) {
      val ln = readLine()
      ok = ln != null
      if (ok) println(ln)
    }
  }
}
******************************
Normalized:
object ScannerTest {
  def main(args: Array[String]) {
    var ok = true
    while (ok) {
      val ln = readLine()
      ok = ln != null
      if (ok) println(ln)
    }
  }
}
******************************
Original:
&lt;global-method-security&gt;
  &lt;expression-handler ref="myMethodSecurityExpressionHandler"/&gt;
&lt;/global-method-security&gt;
******************************
Normalized:
******************************
Original:
&lt;global-method-security&gt;
  &lt;expression-handler ref="myMethodSecurityExpressionHandler"/&gt;
&lt;/global-method-security&gt;
******************************
Normalized:
&lt;global-method-security&gt;
  &lt;expression-handler ref="myMethodSecurityExpressionHandler"/&gt;
&lt;/global-method-security&gt;
******************************
Original:
int r = x % n;
if (r &gt; 0 &amp;&amp; x &lt; 0)
{
    r -= n;
}
******************************
Normalized:
******************************
Original:
int r = x % n;
if (r &gt; 0 &amp;&amp; x &lt; 0)
{
    r -= n;
}
******************************
Normalized:
int r = x % n;
if (r &gt; 0 &amp;&amp; x &lt; 0)
{
    r -= n;
}
******************************
Original:
mvn eclipse:eclipse -DdownloadSources=true
******************************
Normalized:
******************************
Original:
mvn eclipse:eclipse -DdownloadSources=true
******************************
Normalized:
mvn eclipse:eclipse -DdownloadSources=true
******************************
Original:
@POST
public Response postSomething(@QueryParam("name") String name, @Context UriInfo uriInfo, String content) {
     MultivaluedMap&lt;String, String&gt; queryParams = uriInfo.getQueryParameters(); 
     String nameParam = queryParams.getFirst("name");
}
******************************
Normalized:
******************************
Original:
@POST
public Response postSomething(@QueryParam("name") String name, @Context UriInfo uriInfo, String content) {
     MultivaluedMap&lt;String, String&gt; queryParams = uriInfo.getQueryParameters(); 
     String nameParam = queryParams.getFirst("name");
}
******************************
Normalized:
@POST
public Response postSomething(@QueryParam("name") String name, @Context UriInfo uriInfo, String content) {
     MultivaluedMap&lt;String, String&gt; queryParams = uriInfo.getQueryParameters(); 
     String nameParam = queryParams.getFirst("name");
}
******************************
Original:
interface CustomUserRepository {

  List&lt;User&gt; yourCustomMethod();
}
******************************
Normalized:
******************************
Original:
interface CustomUserRepository {

  List&lt;User&gt; yourCustomMethod();
}
******************************
Normalized:
interface CustomUserRepository {

  List&lt;User&gt; yourCustomMethod();
}
******************************
Original:
1372060916 = Mon, 24 Jun 2013 08:01:56 GMT
******************************
Normalized:
******************************
Original:
1372060916 = Mon, 24 Jun 2013 08:01:56 GMT
******************************
Normalized:
1372060916 = Mon, 24 Jun 2013 08:01:56 GMT
******************************
Original:
0x00007fdd859dbb80: test   %eax,0x5f7847a(%rip)  /* fun JVM hack */
0x00007fdd859dbb86: dec    %r11                  /* i-- */
0x00007fdd859dbb89: mov    %r11,0x258(%r10)      /* store i to memory */
0x00007fdd859dbb90: test   %r11,%r11             /* unnecessary test */
0x00007fdd859dbb93: jge    0x00007fdd859dbb80    /* go back to the loop top */
******************************
Normalized:
******************************
Original:
0x00007fdd859dbb80: test   %eax,0x5f7847a(%rip)  /* fun JVM hack */
0x00007fdd859dbb86: dec    %r11                  /* i-- */
0x00007fdd859dbb89: mov    %r11,0x258(%r10)      /* store i to memory */
0x00007fdd859dbb90: test   %r11,%r11             /* unnecessary test */
0x00007fdd859dbb93: jge    0x00007fdd859dbb80    /* go back to the loop top */
******************************
Normalized:
0x00007fdd859dbb80: test   %eax,0x5f7847a(%rip)  /* fun JVM hack */
0x00007fdd859dbb86: dec    %r11                  /* i-- */
0x00007fdd859dbb89: mov    %r11,0x258(%r10)      /* store i to memory */
0x00007fdd859dbb90: test   %r11,%r11             /* unnecessary test */
0x00007fdd859dbb93: jge    0x00007fdd859dbb80    /* go back to the loop top */
******************************
Original:
Class&lt;?&gt; driverClass = Class.forName("oracle.jdbc.driver.OracleDriver");
// and
Class&lt;?&gt; stringClass = Class.forName("java.lang.String");
******************************
Normalized:
******************************
Original:
Class&lt;?&gt; driverClass = Class.forName("oracle.jdbc.driver.OracleDriver");
// and
Class&lt;?&gt; stringClass = Class.forName("java.lang.String");
******************************
Normalized:
Class&lt;?&gt; driverClass = Class.forName("oracle.jdbc.driver.OracleDriver");
// and
Class&lt;?&gt; stringClass = Class.forName("java.lang.String");
******************************
Original:
byte b1 = (byte) 129;
String s1 = String.format("%8s", Integer.toBinaryString(b1 &amp; 0xFF)).replace(' ', '0');
System.out.println(s1); // 10000001

byte b2 = (byte) 2;
String s2 = String.format("%8s", Integer.toBinaryString(b2 &amp; 0xFF)).replace(' ', '0');
System.out.println(s2); // 00000010
******************************
Normalized:
******************************
Original:
byte b1 = (byte) 129;
String s1 = String.format("%8s", Integer.toBinaryString(b1 &amp; 0xFF)).replace(' ', '0');
System.out.println(s1); // 10000001

byte b2 = (byte) 2;
String s2 = String.format("%8s", Integer.toBinaryString(b2 &amp; 0xFF)).replace(' ', '0');
System.out.println(s2); // 00000010
******************************
Normalized:
byte b1 = (byte) 129;
String s1 = String.format("%8s", Integer.toBinaryString(b1 &amp; 0xFF)).replace(' ', '0');
System.out.println(s1); // 10000001

byte b2 = (byte) 2;
String s2 = String.format("%8s", Integer.toBinaryString(b2 &amp; 0xFF)).replace(' ', '0');
System.out.println(s2); // 00000010
******************************
Original:
keytool -genkey -noprompt \
 -alias alias1 \
 -dname "CN=mqttserver.ibm.com, OU=ID, O=IBM, L=Hursley, S=Hants, C=GB" \
 -keystore keystore \
 -storepass password \
 -keypass password
******************************
Normalized:
******************************
Original:
keytool -genkey -noprompt \
 -alias alias1 \
 -dname "CN=mqttserver.ibm.com, OU=ID, O=IBM, L=Hursley, S=Hants, C=GB" \
 -keystore keystore \
 -storepass password \
 -keypass password
******************************
Normalized:
keytool -genkey -noprompt \
 -alias alias1 \
 -dname "CN=mqttserver.ibm.com, OU=ID, O=IBM, L=Hursley, S=Hants, C=GB" \
 -keystore keystore \
 -storepass password \
 -keypass password
******************************
Original:
&lt;c:if test="${not theBooleanVariable}"&gt;It's false!&lt;/c:if&gt;
******************************
Normalized:
******************************
Original:
&lt;c:if test="${not theBooleanVariable}"&gt;It's false!&lt;/c:if&gt;
******************************
Normalized:
&lt;c:if test="${not theBooleanVariable}"&gt;It's false!&lt;/c:if&gt;
******************************
Original:
while (condition) { 
  ... 
}
******************************
Normalized:
******************************
Original:
while (condition) { 
  ... 
}
******************************
Normalized:
while (condition) { 
  ... 
}
******************************
Original:
&lt;build&gt;
  &lt;finalName&gt;bird&lt;/finalName&gt;
 . . .
&lt;/build&gt;
******************************
Normalized:
******************************
Original:
&lt;build&gt;
  &lt;finalName&gt;bird&lt;/finalName&gt;
 . . .
&lt;/build&gt;
******************************
Normalized:
&lt;build&gt;
  &lt;finalName&gt;bird&lt;/finalName&gt;
 . . .
&lt;/build&gt;
******************************
Original:
git init
******************************
Normalized:
******************************
Original:
git init
******************************
Normalized:
git init
******************************
Original:
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST"
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST\\;" + 
                  "SET SCHEMA TEST";
String url = "jdbc:h2:mem;" + 
             "INIT=RUNSCRIPT FROM '~/create.sql'\\;" + 
                  "RUNSCRIPT FROM '~/populate.sql'";
******************************
Normalized:
******************************
Original:
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST"
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST\\;" + 
                  "SET SCHEMA TEST";
String url = "jdbc:h2:mem;" + 
             "INIT=RUNSCRIPT FROM '~/create.sql'\\;" + 
                  "RUNSCRIPT FROM '~/populate.sql'";
******************************
Normalized:
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST"
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST\\;" + 
                  "SET SCHEMA TEST";
String url = "jdbc:h2:mem;" + 
             "INIT=RUNSCRIPT FROM '~/create.sql'\\;" + 
                  "RUNSCRIPT FROM '~/populate.sql'";
******************************
Original:
public void testHardCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    for(int i = 0; i &lt; out.length; i++)
    {
        out[i] = bytes[i];
    }
}

public void testArrayCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    System.arraycopy(bytes, 0, out, 0, out.length);
}
******************************
Normalized:
******************************
Original:
public void testHardCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    for(int i = 0; i &lt; out.length; i++)
    {
        out[i] = bytes[i];
    }
}

public void testArrayCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    System.arraycopy(bytes, 0, out, 0, out.length);
}
******************************
Normalized:
public void testHardCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    for(int i = 0; i &lt; out.length; i++)
    {
        out[i] = bytes[i];
    }
}

public void testArrayCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    System.arraycopy(bytes, 0, out, 0, out.length);
}
******************************
Original:
String commaSeparatedNumbers = Arrays.stream(numbers)
    .mapToObj(i -&gt; ((Integer) i).toString()) //i is an int, not an Integer
    .collect(Collectors.joining(", "));
******************************
Normalized:
******************************
Original:
String commaSeparatedNumbers = Arrays.stream(numbers)
    .mapToObj(i -&gt; ((Integer) i).toString()) //i is an int, not an Integer
    .collect(Collectors.joining(", "));
******************************
Normalized:
String commaSeparatedNumbers = Arrays.stream(numbers)
    .mapToObj(i -&gt; ((Integer) i).toString()) //i is an int, not an Integer
    .collect(Collectors.joining(", "));
******************************
Original:
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;



class FloodIsolation {
public:
  FloodIsolation() :
      numberOfCells(20000),
      data(numberOfCells)
  {
  }
  ~FloodIsolation(){
  }

  void isUpdateNeeded() {
    for (int i = 0; i &lt; numberOfCells; ++i) {
       data[i].h = data[i].h + 1;
       data[i].floodedCells = !data[i].floodedCells;
       data[i].floodedCellsTimeInterval = !data[i].floodedCellsTimeInterval;
       data[i].qInflow = data[i].qInflow + 1;
       data[i].qStartTime = data[i].qStartTime + 1;
       data[i].qEndTime = data[i].qEndTime + 1;
       data[i].lowerFloorCells = data[i].lowerFloorCells + 1;
       data[i].cellLocationX = data[i].cellLocationX + 1;
       data[i].cellLocationY = data[i].cellLocationY + 1;
       data[i].cellLocationZ = data[i].cellLocationZ + 1;
       data[i].levelOfCell = data[i].levelOfCell + 1;
       data[i].valueOfCellIds = data[i].valueOfCellIds + 1;
       data[i].h0 = data[i].h0 + 1;
       data[i].vU = data[i].vU + 1;
       data[i].vV = data[i].vV + 1;
       data[i].vUh = data[i].vUh + 1;
       data[i].vVh = data[i].vVh + 1;
       data[i].vUh0 = data[i].vUh0 + 1;
       data[i].vVh0 = data[i].vVh0 + 1;
       data[i].ghh = data[i].ghh + 1;
       data[i].sfx = data[i].sfx + 1;
       data[i].sfy = data[i].sfy + 1;
       data[i].qIn = data[i].qIn + 1;


      for(int j = 0; j &lt; nEdges; ++j) {
        data[i].flagInterface[j] = !data[i].flagInterface[j];
        data[i].typeInterface[j] = data[i].typeInterface[j] + 1;
        data[i].neighborIds[j] = data[i].neighborIds[j] + 1;
      }
    }

  }

private:

  const int numberOfCells;
  static const int nEdges = 6;
  struct data_t {
    bool floodedCells = 0;
    bool floodedCellsTimeInterval = 0;

    double valueOfCellIds = 0;
    double h = 0;

    double h0 = 0;
    double vU = 0;
    double vV = 0;
    double vUh = 0;
    double vVh = 0;
    double vUh0 = 0;
    double vVh0 = 0;
    double ghh = 0;
    double sfx = 0;
    double sfy = 0;
    double qInflow = 0;
    double qStartTime = 0;
    double qEndTime = 0;
    double qIn = 0;
    double nx = 0;
    double ny = 0;
    double floorLevels = 0;
    int lowerFloorCells = 0;
    bool floorCompleteleyFilled = 0;
    double cellLocationX = 0;
    double cellLocationY = 0;
    double cellLocationZ = 0;
    int levelOfCell = 0;
    bool flagInterface[nEdges] = {};
    int typeInterface[nEdges] = {};
    int neighborIds[nEdges] = {};
  };
  std::vector&lt;data_t&gt; data;

};

int main() {
  std::ios_base::sync_with_stdio(false);
  FloodIsolation isolation;
  clock_t start = clock();
  for (int i = 0; i &lt; 400; ++i) {
    if(i % 100 == 0) {
      std::cout &lt;&lt; i &lt;&lt; "\n";
    }
    isolation.isUpdateNeeded();
  }
  clock_t stop = clock();
  std::cout &lt;&lt; "Time: " &lt;&lt; difftime(stop, start) / 1000 &lt;&lt; "\n";
}
******************************
Normalized:
******************************
Original:
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;



class FloodIsolation {
public:
  FloodIsolation() :
      numberOfCells(20000),
      data(numberOfCells)
  {
  }
  ~FloodIsolation(){
  }

  void isUpdateNeeded() {
    for (int i = 0; i &lt; numberOfCells; ++i) {
       data[i].h = data[i].h + 1;
       data[i].floodedCells = !data[i].floodedCells;
       data[i].floodedCellsTimeInterval = !data[i].floodedCellsTimeInterval;
       data[i].qInflow = data[i].qInflow + 1;
       data[i].qStartTime = data[i].qStartTime + 1;
       data[i].qEndTime = data[i].qEndTime + 1;
       data[i].lowerFloorCells = data[i].lowerFloorCells + 1;
       data[i].cellLocationX = data[i].cellLocationX + 1;
       data[i].cellLocationY = data[i].cellLocationY + 1;
       data[i].cellLocationZ = data[i].cellLocationZ + 1;
       data[i].levelOfCell = data[i].levelOfCell + 1;
       data[i].valueOfCellIds = data[i].valueOfCellIds + 1;
       data[i].h0 = data[i].h0 + 1;
       data[i].vU = data[i].vU + 1;
       data[i].vV = data[i].vV + 1;
       data[i].vUh = data[i].vUh + 1;
       data[i].vVh = data[i].vVh + 1;
       data[i].vUh0 = data[i].vUh0 + 1;
       data[i].vVh0 = data[i].vVh0 + 1;
       data[i].ghh = data[i].ghh + 1;
       data[i].sfx = data[i].sfx + 1;
       data[i].sfy = data[i].sfy + 1;
       data[i].qIn = data[i].qIn + 1;


      for(int j = 0; j &lt; nEdges; ++j) {
        data[i].flagInterface[j] = !data[i].flagInterface[j];
        data[i].typeInterface[j] = data[i].typeInterface[j] + 1;
        data[i].neighborIds[j] = data[i].neighborIds[j] + 1;
      }
    }

  }

private:

  const int numberOfCells;
  static const int nEdges = 6;
  struct data_t {
    bool floodedCells = 0;
    bool floodedCellsTimeInterval = 0;

    double valueOfCellIds = 0;
    double h = 0;

    double h0 = 0;
    double vU = 0;
    double vV = 0;
    double vUh = 0;
    double vVh = 0;
    double vUh0 = 0;
    double vVh0 = 0;
    double ghh = 0;
    double sfx = 0;
    double sfy = 0;
    double qInflow = 0;
    double qStartTime = 0;
    double qEndTime = 0;
    double qIn = 0;
    double nx = 0;
    double ny = 0;
    double floorLevels = 0;
    int lowerFloorCells = 0;
    bool floorCompleteleyFilled = 0;
    double cellLocationX = 0;
    double cellLocationY = 0;
    double cellLocationZ = 0;
    int levelOfCell = 0;
    bool flagInterface[nEdges] = {};
    int typeInterface[nEdges] = {};
    int neighborIds[nEdges] = {};
  };
  std::vector&lt;data_t&gt; data;

};

int main() {
  std::ios_base::sync_with_stdio(false);
  FloodIsolation isolation;
  clock_t start = clock();
  for (int i = 0; i &lt; 400; ++i) {
    if(i % 100 == 0) {
      std::cout &lt;&lt; i &lt;&lt; "\n";
    }
    isolation.isUpdateNeeded();
  }
  clock_t stop = clock();
  std::cout &lt;&lt; "Time: " &lt;&lt; difftime(stop, start) / 1000 &lt;&lt; "\n";
}
******************************
Normalized:
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;



class FloodIsolation {
public:
  FloodIsolation() :
      numberOfCells(20000),
      data(numberOfCells)
  {
  }
  ~FloodIsolation(){
  }

  void isUpdateNeeded() {
    for (int i = 0; i &lt; numberOfCells; ++i) {
       data[i].h = data[i].h + 1;
       data[i].floodedCells = !data[i].floodedCells;
       data[i].floodedCellsTimeInterval = !data[i].floodedCellsTimeInterval;
       data[i].qInflow = data[i].qInflow + 1;
       data[i].qStartTime = data[i].qStartTime + 1;
       data[i].qEndTime = data[i].qEndTime + 1;
       data[i].lowerFloorCells = data[i].lowerFloorCells + 1;
       data[i].cellLocationX = data[i].cellLocationX + 1;
       data[i].cellLocationY = data[i].cellLocationY + 1;
       data[i].cellLocationZ = data[i].cellLocationZ + 1;
       data[i].levelOfCell = data[i].levelOfCell + 1;
       data[i].valueOfCellIds = data[i].valueOfCellIds + 1;
       data[i].h0 = data[i].h0 + 1;
       data[i].vU = data[i].vU + 1;
       data[i].vV = data[i].vV + 1;
       data[i].vUh = data[i].vUh + 1;
       data[i].vVh = data[i].vVh + 1;
       data[i].vUh0 = data[i].vUh0 + 1;
       data[i].vVh0 = data[i].vVh0 + 1;
       data[i].ghh = data[i].ghh + 1;
       data[i].sfx = data[i].sfx + 1;
       data[i].sfy = data[i].sfy + 1;
       data[i].qIn = data[i].qIn + 1;


      for(int j = 0; j &lt; nEdges; ++j) {
        data[i].flagInterface[j] = !data[i].flagInterface[j];
        data[i].typeInterface[j] = data[i].typeInterface[j] + 1;
        data[i].neighborIds[j] = data[i].neighborIds[j] + 1;
      }
    }

  }

private:

  const int numberOfCells;
  static const int nEdges = 6;
  struct data_t {
    bool floodedCells = 0;
    bool floodedCellsTimeInterval = 0;

    double valueOfCellIds = 0;
    double h = 0;

    double h0 = 0;
    double vU = 0;
    double vV = 0;
    double vUh = 0;
    double vVh = 0;
    double vUh0 = 0;
    double vVh0 = 0;
    double ghh = 0;
    double sfx = 0;
    double sfy = 0;
    double qInflow = 0;
    double qStartTime = 0;
    double qEndTime = 0;
    double qIn = 0;
    double nx = 0;
    double ny = 0;
    double floorLevels = 0;
    int lowerFloorCells = 0;
    bool floorCompleteleyFilled = 0;
    double cellLocationX = 0;
    double cellLocationY = 0;
    double cellLocationZ = 0;
    int levelOfCell = 0;
    bool flagInterface[nEdges] = {};
    int typeInterface[nEdges] = {};
    int neighborIds[nEdges] = {};
  };
  std::vector&lt;data_t&gt; data;

};

int main() {
  std::ios_base::sync_with_stdio(false);
  FloodIsolation isolation;
  clock_t start = clock();
  for (int i = 0; i &lt; 400; ++i) {
    if(i % 100 == 0) {
      std::cout &lt;&lt; i &lt;&lt; "\n";
    }
    isolation.isUpdateNeeded();
  }
  clock_t stop = clock();
  std::cout &lt;&lt; "Time: " &lt;&lt; difftime(stop, start) / 1000 &lt;&lt; "\n";
}
******************************
Original:
private static &lt;T&gt; Stream&lt;T&gt; nonEmptyStream(
    Stream&lt;T&gt; stream, Supplier&lt;RuntimeException&gt; e) {

    Spliterator&lt;T&gt; it=stream.spliterator();
    return StreamSupport.stream(new Spliterator&lt;T&gt;() {
        boolean seen;
        public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
            boolean r=it.tryAdvance(action);
            if(!seen &amp;&amp; !r) throw e.get();
            seen=true;
            return r;
        }
        public Spliterator&lt;T&gt; trySplit() { return null; }
        public long estimateSize() { return it.estimateSize(); }
        public int characteristics() { return it.characteristics(); }
    }, false);
}
******************************
Normalized:
******************************
Original:
private static &lt;T&gt; Stream&lt;T&gt; nonEmptyStream(
    Stream&lt;T&gt; stream, Supplier&lt;RuntimeException&gt; e) {

    Spliterator&lt;T&gt; it=stream.spliterator();
    return StreamSupport.stream(new Spliterator&lt;T&gt;() {
        boolean seen;
        public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
            boolean r=it.tryAdvance(action);
            if(!seen &amp;&amp; !r) throw e.get();
            seen=true;
            return r;
        }
        public Spliterator&lt;T&gt; trySplit() { return null; }
        public long estimateSize() { return it.estimateSize(); }
        public int characteristics() { return it.characteristics(); }
    }, false);
}
******************************
Normalized:
private static &lt;T&gt; Stream&lt;T&gt; nonEmptyStream(
    Stream&lt;T&gt; stream, Supplier&lt;RuntimeException&gt; e) {

    Spliterator&lt;T&gt; it=stream.spliterator();
    return StreamSupport.stream(new Spliterator&lt;T&gt;() {
        boolean seen;
        public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
            boolean r=it.tryAdvance(action);
            if(!seen &amp;&amp; !r) throw e.get();
            seen=true;
            return r;
        }
        public Spliterator&lt;T&gt; trySplit() { return null; }
        public long estimateSize() { return it.estimateSize(); }
        public int characteristics() { return it.characteristics(); }
    }, false);
}
******************************
Original:
^[1-9]\d*$
******************************
Normalized:
******************************
Original:
^[1-9]\d*$
******************************
Normalized:
^[1-9]\d*$
******************************
Original:
&lt;Button
        android:id="@+id/header"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="@string/test"
        android:textColor="@color/black"
        android:minHeight="40dip"/&gt;


&lt;style name="Widget.Holo.Button" parent="Widget.Button"&gt;
    &lt;item name="android:background"&gt;@android:drawable/btn_default_holo_dark&lt;/item&gt;
    &lt;item name="android:textAppearance"&gt;?android:attr/textAppearanceMedium&lt;/item&gt;
    &lt;item name="android:textColor"&gt;@android:color/primary_text_holo_dark&lt;/item&gt;
    &lt;item name="android:minHeight"&gt;48dip&lt;/item&gt;
    &lt;item name="android:minWidth"&gt;64dip&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
******************************
Original:
&lt;Button
        android:id="@+id/header"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="@string/test"
        android:textColor="@color/black"
        android:minHeight="40dip"/&gt;


&lt;style name="Widget.Holo.Button" parent="Widget.Button"&gt;
    &lt;item name="android:background"&gt;@android:drawable/btn_default_holo_dark&lt;/item&gt;
    &lt;item name="android:textAppearance"&gt;?android:attr/textAppearanceMedium&lt;/item&gt;
    &lt;item name="android:textColor"&gt;@android:color/primary_text_holo_dark&lt;/item&gt;
    &lt;item name="android:minHeight"&gt;48dip&lt;/item&gt;
    &lt;item name="android:minWidth"&gt;64dip&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
&lt;Button
        android:id="@+id/header"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="@string/test"
        android:textColor="@color/black"
        android:minHeight="40dip"/&gt;


&lt;style name="Widget.Holo.Button" parent="Widget.Button"&gt;
    &lt;item name="android:background"&gt;@android:drawable/btn_default_holo_dark&lt;/item&gt;
    &lt;item name="android:textAppearance"&gt;?android:attr/textAppearanceMedium&lt;/item&gt;
    &lt;item name="android:textColor"&gt;@android:color/primary_text_holo_dark&lt;/item&gt;
    &lt;item name="android:minHeight"&gt;48dip&lt;/item&gt;
    &lt;item name="android:minWidth"&gt;64dip&lt;/item&gt;
&lt;/style&gt;
******************************
Original:
private ArrayList&lt;String&gt; _categories; // Initialize all this stuff

private int getCategoryPos(String category) {
  return _categories.indexOf(category);
}
******************************
Normalized:
******************************
Original:
private ArrayList&lt;String&gt; _categories; // Initialize all this stuff

private int getCategoryPos(String category) {
  return _categories.indexOf(category);
}
******************************
Normalized:
private ArrayList&lt;String&gt; _categories; // Initialize all this stuff

private int getCategoryPos(String category) {
  return _categories.indexOf(category);
}
******************************
Original:
@RequestMapping(value="/orders", method=RequestMethod.GET)
@ResponseBody
public List&lt;Account&gt; accountSummary() {
    return accountManager.getAllAccounts();
}
******************************
Normalized:
******************************
Original:
@RequestMapping(value="/orders", method=RequestMethod.GET)
@ResponseBody
public List&lt;Account&gt; accountSummary() {
    return accountManager.getAllAccounts();
}
******************************
Normalized:
@RequestMapping(value="/orders", method=RequestMethod.GET)
@ResponseBody
public List&lt;Account&gt; accountSummary() {
    return accountManager.getAllAccounts();
}
******************************
Original:
JSONArray jsonarray = new JSONArray(jsonStr);
for (int i = 0; i &lt; jsonarray.length(); i++) {
    JSONObject jsonobject = jsonarray.getJSONObject(i);
    String name = jsonobject.getString("name");
    String url = jsonobject.getString("url");
}
******************************
Normalized:
******************************
Original:
JSONArray jsonarray = new JSONArray(jsonStr);
for (int i = 0; i &lt; jsonarray.length(); i++) {
    JSONObject jsonobject = jsonarray.getJSONObject(i);
    String name = jsonobject.getString("name");
    String url = jsonobject.getString("url");
}
******************************
Normalized:
JSONArray jsonarray = new JSONArray(jsonStr);
for (int i = 0; i &lt; jsonarray.length(); i++) {
    JSONObject jsonobject = jsonarray.getJSONObject(i);
    String name = jsonobject.getString("name");
    String url = jsonobject.getString("url");
}
******************************
Original:
@Entity
@NamedEntityGraph(name = "GroupInfo.detail",
  attributeNodes = @NamedAttributeNode("members"))
public class GroupInfo {

  // default fetch mode is lazy.
  @ManyToMany
  List&lt;GroupMember&gt; members = new ArrayList&lt;GroupMember&gt;();

  …
}

@Repository
public interface GroupRepository extends CrudRepository&lt;GroupInfo, String&gt; {

  @EntityGraph(value = "GroupInfo.detail", type = EntityGraphType.LOAD)
  GroupInfo getByGroupName(String name);

}
******************************
Normalized:
******************************
Original:
@Entity
@NamedEntityGraph(name = "GroupInfo.detail",
  attributeNodes = @NamedAttributeNode("members"))
public class GroupInfo {

  // default fetch mode is lazy.
  @ManyToMany
  List&lt;GroupMember&gt; members = new ArrayList&lt;GroupMember&gt;();

  …
}

@Repository
public interface GroupRepository extends CrudRepository&lt;GroupInfo, String&gt; {

  @EntityGraph(value = "GroupInfo.detail", type = EntityGraphType.LOAD)
  GroupInfo getByGroupName(String name);

}
******************************
Normalized:
@Entity
@NamedEntityGraph(name = "GroupInfo.detail",
  attributeNodes = @NamedAttributeNode("members"))
public class GroupInfo {

  // default fetch mode is lazy.
  @ManyToMany
  List&lt;GroupMember&gt; members = new ArrayList&lt;GroupMember&gt;();

  …
}

@Repository
public interface GroupRepository extends CrudRepository&lt;GroupInfo, String&gt; {

  @EntityGraph(value = "GroupInfo.detail", type = EntityGraphType.LOAD)
  GroupInfo getByGroupName(String name);

}
******************************
Original:
open -a /Applications/IntelliJ\ IDEA\ 12.app/
******************************
Normalized:
******************************
Original:
open -a /Applications/IntelliJ\ IDEA\ 12.app/
******************************
Normalized:
open -a /Applications/IntelliJ\ IDEA\ 12.app/
******************************
Original:
String brandName;

@JsonProperty("brand")
private void unpackNameFromNestedObject(Map&lt;String, String&gt; brand) {
    brandName = brand.get("name");
}
******************************
Normalized:
******************************
Original:
String brandName;

@JsonProperty("brand")
private void unpackNameFromNestedObject(Map&lt;String, String&gt; brand) {
    brandName = brand.get("name");
}
******************************
Normalized:
String brandName;

@JsonProperty("brand")
private void unpackNameFromNestedObject(Map&lt;String, String&gt; brand) {
    brandName = brand.get("name");
}
******************************
Original:
d = D()          // these four computations can happen in any order
b = B()
c = C()
a = A()
sum = a + b      // these two computations can happen in any order
product = c * d
result = sum + product // this has to happen last
******************************
Normalized:
******************************
Original:
d = D()          // these four computations can happen in any order
b = B()
c = C()
a = A()
sum = a + b      // these two computations can happen in any order
product = c * d
result = sum + product // this has to happen last
******************************
Normalized:
d = D()          // these four computations can happen in any order
b = B()
c = C()
a = A()
sum = a + b      // these two computations can happen in any order
product = c * d
result = sum + product // this has to happen last
******************************
Original:
List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
******************************
Normalized:
******************************
Original:
List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
******************************
Normalized:
List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
******************************
Original:
@JsonDeserialize(builder = Address.Builder.class)
******************************
Normalized:
******************************
Original:
@JsonDeserialize(builder = Address.Builder.class)
******************************
Normalized:
@JsonDeserialize(builder = Address.Builder.class)
******************************
Original:
OctalEscape:
    \ OctalDigit
    \ OctalDigit OctalDigit
    \ ZeroToThree OctalDigit OctalDigit

OctalDigit: one of
    0 1 2 3 4 5 6 7

ZeroToThree: one of
    0 1 2 3
******************************
Normalized:
******************************
Original:
OctalEscape:
    \ OctalDigit
    \ OctalDigit OctalDigit
    \ ZeroToThree OctalDigit OctalDigit

OctalDigit: one of
    0 1 2 3 4 5 6 7

ZeroToThree: one of
    0 1 2 3
******************************
Normalized:
OctalEscape:
    \ OctalDigit
    \ OctalDigit OctalDigit
    \ ZeroToThree OctalDigit OctalDigit

OctalDigit: one of
    0 1 2 3 4 5 6 7

ZeroToThree: one of
    0 1 2 3
******************************
Original:
Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full. Compiler has been disabled.
Java HotSpot(TM) 64-Bit Server VM warning: Try increasing the code cache size using -XX:ReservedCodeCacheSize=
Code Cache  [0x000000010958f000, 0x000000010c52f000, 0x000000010c58f000)
 total_blobs=15406 nmethods=14989 adapters=362 free_code_cache=835Kb largest_free_block=449792
******************************
Normalized:
******************************
Original:
Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full. Compiler has been disabled.
Java HotSpot(TM) 64-Bit Server VM warning: Try increasing the code cache size using -XX:ReservedCodeCacheSize=
Code Cache  [0x000000010958f000, 0x000000010c52f000, 0x000000010c58f000)
 total_blobs=15406 nmethods=14989 adapters=362 free_code_cache=835Kb largest_free_block=449792
******************************
Normalized:
Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full. Compiler has been disabled.
Java HotSpot(TM) 64-Bit Server VM warning: Try increasing the code cache size using -XX:ReservedCodeCacheSize=
Code Cache  [0x000000010958f000, 0x000000010c52f000, 0x000000010c58f000)
 total_blobs=15406 nmethods=14989 adapters=362 free_code_cache=835Kb largest_free_block=449792
******************************
Original:
import static java.lang.Math.abs;

public static long roundUp(long num, long divisor) {
    int sign = (num &gt; 0 ? 1 : -1) * (divisor &gt; 0 ? 1 : -1);
    return sign * (abs(num) + abs(divisor) - 1) / abs(divisor);
}
******************************
Normalized:
******************************
Original:
import static java.lang.Math.abs;

public static long roundUp(long num, long divisor) {
    int sign = (num &gt; 0 ? 1 : -1) * (divisor &gt; 0 ? 1 : -1);
    return sign * (abs(num) + abs(divisor) - 1) / abs(divisor);
}
******************************
Normalized:
import static java.lang.Math.abs;

public static long roundUp(long num, long divisor) {
    int sign = (num &gt; 0 ? 1 : -1) * (divisor &gt; 0 ? 1 : -1);
    return sign * (abs(num) + abs(divisor) - 1) / abs(divisor);
}
******************************
Original:
&lt;http&gt;    
    &lt;headers&gt;
        &lt;frame-options policy="SAMEORIGIN"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;
******************************
Normalized:
******************************
Original:
&lt;http&gt;    
    &lt;headers&gt;
        &lt;frame-options policy="SAMEORIGIN"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;
******************************
Normalized:
&lt;http&gt;    
    &lt;headers&gt;
        &lt;frame-options policy="SAMEORIGIN"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;
******************************
Original:
n      0000100...000
-n      1111100...000
 n &amp; -n 0000100...000
******************************
Normalized:
******************************
Original:
n      0000100...000
-n      1111100...000
 n &amp; -n 0000100...000
******************************
Normalized:
n      0000100...000
-n      1111100...000
 n &amp; -n 0000100...000
******************************
Original:
FileOutputStream(File file, boolean append)
******************************
Normalized:
******************************
Original:
FileOutputStream(File file, boolean append)
******************************
Normalized:
FileOutputStream(File file, boolean append)
******************************
Original:
List&lt;Integer&gt; x = new ArrayList&lt;Integer&gt;();
x.add(1);
x.add(2);
******************************
Normalized:
******************************
Original:
List&lt;Integer&gt; x = new ArrayList&lt;Integer&gt;();
x.add(1);
x.add(2);
******************************
Normalized:
List&lt;Integer&gt; x = new ArrayList&lt;Integer&gt;();
x.add(1);
x.add(2);
******************************
Original:
import javax.swing.JOptionPane;
import javax.swing.JFrame;

/*Some piece of code*/
frame.addWindowListener(new java.awt.event.WindowAdapter() {
    @Override
    public void windowClosing(java.awt.event.WindowEvent windowEvent) {
        if (JOptionPane.showConfirmDialog(frame, 
            "Are you sure you want to close this window?", "Close Window?", 
            JOptionPane.YES_NO_OPTION,
            JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION){
            System.exit(0);
        }
    }
});
******************************
Normalized:
******************************
Original:
import javax.swing.JOptionPane;
import javax.swing.JFrame;

/*Some piece of code*/
frame.addWindowListener(new java.awt.event.WindowAdapter() {
    @Override
    public void windowClosing(java.awt.event.WindowEvent windowEvent) {
        if (JOptionPane.showConfirmDialog(frame, 
            "Are you sure you want to close this window?", "Close Window?", 
            JOptionPane.YES_NO_OPTION,
            JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION){
            System.exit(0);
        }
    }
});
******************************
Normalized:
import javax.swing.JOptionPane;
import javax.swing.JFrame;

/*Some piece of code*/
frame.addWindowListener(new java.awt.event.WindowAdapter() {
    @Override
    public void windowClosing(java.awt.event.WindowEvent windowEvent) {
        if (JOptionPane.showConfirmDialog(frame, 
            "Are you sure you want to close this window?", "Close Window?", 
            JOptionPane.YES_NO_OPTION,
            JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION){
            System.exit(0);
        }
    }
});
******************************
Original:
public class RealPayment implements Payment {
   @Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      @Assisted Date startDate,
      @Assisted Money amount) {
     ...
   }
 }
******************************
Normalized:
******************************
Original:
public class RealPayment implements Payment {
   @Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      @Assisted Date startDate,
      @Assisted Money amount) {
     ...
   }
 }
******************************
Normalized:
public class RealPayment implements Payment {
   @Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      @Assisted Date startDate,
      @Assisted Money amount) {
     ...
   }
 }
******************************
Original:
public class Test {
    public static void main(String[] args) {
        int x;
        if (args.length &gt; 0) {
            x = 1;
        } else {
            x = 2;
        }
    }

    public static void main2(String[] args) {
        int x = (args.length &gt; 0) ? 1 : 2;
    }
}
******************************
Normalized:
******************************
Original:
public class Test {
    public static void main(String[] args) {
        int x;
        if (args.length &gt; 0) {
            x = 1;
        } else {
            x = 2;
        }
    }

    public static void main2(String[] args) {
        int x = (args.length &gt; 0) ? 1 : 2;
    }
}
******************************
Normalized:
public class Test {
    public static void main(String[] args) {
        int x;
        if (args.length &gt; 0) {
            x = 1;
        } else {
            x = 2;
        }
    }

    public static void main2(String[] args) {
        int x = (args.length &gt; 0) ? 1 : 2;
    }
}
******************************
Original:
@ComponentScan({"com.my.package.first","com.my.package.second"})
******************************
Normalized:
******************************
Original:
@ComponentScan({"com.my.package.first","com.my.package.second"})
******************************
Normalized:
@ComponentScan({"com.my.package.first","com.my.package.second"})
******************************
Original:
public class Foo&lt;T&gt; 
{
    private Class&lt;T&gt; type;

    public Foo(Class&lt;T&gt; type) { this.type = type; } 
}
******************************
Normalized:
******************************
Original:
public class Foo&lt;T&gt; 
{
    private Class&lt;T&gt; type;

    public Foo(Class&lt;T&gt; type) { this.type = type; } 
}
******************************
Normalized:
public class Foo&lt;T&gt; 
{
    private Class&lt;T&gt; type;

    public Foo(Class&lt;T&gt; type) { this.type = type; } 
}
******************************
Original:
while (true) {
    ....
    if (obj == null) {
        break;
    }
    ....
}
******************************
Normalized:
******************************
Original:
while (true) {
    ....
    if (obj == null) {
        break;
    }
    ....
}
******************************
Normalized:
while (true) {
    ....
    if (obj == null) {
        break;
    }
    ....
}
******************************
Original:
javac dir1/*.java dir2/*.java dir3/dir4/*.java dir3/dir5/*.java dir6/*src/*.java
******************************
Normalized:
******************************
Original:
javac dir1/*.java dir2/*.java dir3/dir4/*.java dir3/dir5/*.java dir6/*src/*.java
******************************
Normalized:
javac dir1/*.java dir2/*.java dir3/dir4/*.java dir3/dir5/*.java dir6/*src/*.java
******************************
Original:
public class Demo {
  private int num = 0;
  /**
  * Access field {@link Demo#num} / {@link #num}  ...
  */
  private void foo() { ... }
...
******************************
Normalized:
******************************
Original:
public class Demo {
  private int num = 0;
  /**
  * Access field {@link Demo#num} / {@link #num}  ...
  */
  private void foo() { ... }
...
******************************
Normalized:
public class Demo {
  private int num = 0;
  /**
  * Access field {@link Demo#num} / {@link #num}  ...
  */
  private void foo() { ... }
...
******************************
Original:
java -XshowSettings:properties -version
******************************
Normalized:
******************************
Original:
java -XshowSettings:properties -version
******************************
Normalized:
java -XshowSettings:properties -version
******************************
Original:
public static &lt;T&gt; T isNull(Class&lt;T&gt; clazz)
******************************
Normalized:
******************************
Original:
public static &lt;T&gt; T isNull(Class&lt;T&gt; clazz)
******************************
Normalized:
public static &lt;T&gt; T isNull(Class&lt;T&gt; clazz)
******************************
Original:
1011 = -3
0011 = +3
******************************
Normalized:
******************************
Original:
1011 = -3
0011 = +3
******************************
Normalized:
1011 = -3
0011 = +3
******************************
Original:
final List&lt;MyObject&gt; list = query.list();
******************************
Normalized:
******************************
Original:
final List&lt;MyObject&gt; list = query.list();
******************************
Normalized:
final List&lt;MyObject&gt; list = query.list();
******************************
Original:
val handler = Handler&lt;String&gt; { println("Hello: $it")}
******************************
Normalized:
******************************
Original:
val handler = Handler&lt;String&gt; { println("Hello: $it")}
******************************
Normalized:
val handler = Handler&lt;String&gt; { println("Hello: $it")}
******************************
Original:
&lt;style name="MyMaterialTheme" parent="MyMaterialTheme.Base"&gt;

&lt;/style&gt;

&lt;style name="MyMaterialTheme.Base" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;
    &lt;item name="windowActionBar"&gt;false&lt;/item&gt;
    &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name="drawerArrowStyle"&gt;@style/DrawerArrowStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="DrawerArrowStyle" parent="@style/Widget.AppCompat.DrawerArrowToggle"&gt;
    &lt;item name="spinBars"&gt;true&lt;/item&gt;
    &lt;item name="color"&gt;@android:color/black&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
******************************
Original:
&lt;style name="MyMaterialTheme" parent="MyMaterialTheme.Base"&gt;

&lt;/style&gt;

&lt;style name="MyMaterialTheme.Base" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;
    &lt;item name="windowActionBar"&gt;false&lt;/item&gt;
    &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name="drawerArrowStyle"&gt;@style/DrawerArrowStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="DrawerArrowStyle" parent="@style/Widget.AppCompat.DrawerArrowToggle"&gt;
    &lt;item name="spinBars"&gt;true&lt;/item&gt;
    &lt;item name="color"&gt;@android:color/black&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
&lt;style name="MyMaterialTheme" parent="MyMaterialTheme.Base"&gt;

&lt;/style&gt;

&lt;style name="MyMaterialTheme.Base" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;
    &lt;item name="windowActionBar"&gt;false&lt;/item&gt;
    &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name="drawerArrowStyle"&gt;@style/DrawerArrowStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="DrawerArrowStyle" parent="@style/Widget.AppCompat.DrawerArrowToggle"&gt;
    &lt;item name="spinBars"&gt;true&lt;/item&gt;
    &lt;item name="color"&gt;@android:color/black&lt;/item&gt;
&lt;/style&gt;
******************************
Original:
Gson gson = new Gson();
String jsonOutput = "Your JSON String";
Type listType = new TypeToken&lt;List&lt;Post&gt;&gt;(){}.getType();
List&lt;Post&gt; posts = gson.fromJson(jsonOutput, listType);
******************************
Normalized:
******************************
Original:
Gson gson = new Gson();
String jsonOutput = "Your JSON String";
Type listType = new TypeToken&lt;List&lt;Post&gt;&gt;(){}.getType();
List&lt;Post&gt; posts = gson.fromJson(jsonOutput, listType);
******************************
Normalized:
Gson gson = new Gson();
String jsonOutput = "Your JSON String";
Type listType = new TypeToken&lt;List&lt;Post&gt;&gt;(){}.getType();
List&lt;Post&gt; posts = gson.fromJson(jsonOutput, listType);
******************************
Original:
&lt;%@ page pageEncoding="UTF-8" %&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;
&lt;c:set var="language" value="${not empty param.language ? param.language : not empty language ? language : pageContext.request.locale}" scope="session" /&gt;
&lt;fmt:setLocale value="${language}" /&gt;
&lt;fmt:setBundle basename="com.example.i18n.text" /&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="${language}"&gt;
    &lt;head&gt;
        &lt;title&gt;JSP/JSTL i18n demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form&gt;
            &lt;select id="language" name="language" onchange="submit()"&gt;
                &lt;option value="en" ${language == 'en' ? 'selected' : ''}&gt;English&lt;/option&gt;
                &lt;option value="nl" ${language == 'nl' ? 'selected' : ''}&gt;Nederlands&lt;/option&gt;
                &lt;option value="es" ${language == 'es' ? 'selected' : ''}&gt;Español&lt;/option&gt;
            &lt;/select&gt;
        &lt;/form&gt;
        &lt;form method="post"&gt;
            &lt;label for="username"&gt;&lt;fmt:message key="login.label.username" /&gt;:&lt;/label&gt;
            &lt;input type="text" id="username" name="username"&gt;
            &lt;br&gt;
            &lt;label for="password"&gt;&lt;fmt:message key="login.label.password" /&gt;:&lt;/label&gt;
            &lt;input type="password" id="password" name="password"&gt;
            &lt;br&gt;
            &lt;fmt:message key="login.button.submit" var="buttonValue" /&gt;
            &lt;input type="submit" name="submit" value="${buttonValue}"&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
******************************
Normalized:
******************************
Original:
&lt;%@ page pageEncoding="UTF-8" %&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;
&lt;c:set var="language" value="${not empty param.language ? param.language : not empty language ? language : pageContext.request.locale}" scope="session" /&gt;
&lt;fmt:setLocale value="${language}" /&gt;
&lt;fmt:setBundle basename="com.example.i18n.text" /&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="${language}"&gt;
    &lt;head&gt;
        &lt;title&gt;JSP/JSTL i18n demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form&gt;
            &lt;select id="language" name="language" onchange="submit()"&gt;
                &lt;option value="en" ${language == 'en' ? 'selected' : ''}&gt;English&lt;/option&gt;
                &lt;option value="nl" ${language == 'nl' ? 'selected' : ''}&gt;Nederlands&lt;/option&gt;
                &lt;option value="es" ${language == 'es' ? 'selected' : ''}&gt;Español&lt;/option&gt;
            &lt;/select&gt;
        &lt;/form&gt;
        &lt;form method="post"&gt;
            &lt;label for="username"&gt;&lt;fmt:message key="login.label.username" /&gt;:&lt;/label&gt;
            &lt;input type="text" id="username" name="username"&gt;
            &lt;br&gt;
            &lt;label for="password"&gt;&lt;fmt:message key="login.label.password" /&gt;:&lt;/label&gt;
            &lt;input type="password" id="password" name="password"&gt;
            &lt;br&gt;
            &lt;fmt:message key="login.button.submit" var="buttonValue" /&gt;
            &lt;input type="submit" name="submit" value="${buttonValue}"&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
******************************
Normalized:
&lt;%@ page pageEncoding="UTF-8" %&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;
&lt;c:set var="language" value="${not empty param.language ? param.language : not empty language ? language : pageContext.request.locale}" scope="session" /&gt;
&lt;fmt:setLocale value="${language}" /&gt;
&lt;fmt:setBundle basename="com.example.i18n.text" /&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="${language}"&gt;
    &lt;head&gt;
        &lt;title&gt;JSP/JSTL i18n demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form&gt;
            &lt;select id="language" name="language" onchange="submit()"&gt;
                &lt;option value="en" ${language == 'en' ? 'selected' : ''}&gt;English&lt;/option&gt;
                &lt;option value="nl" ${language == 'nl' ? 'selected' : ''}&gt;Nederlands&lt;/option&gt;
                &lt;option value="es" ${language == 'es' ? 'selected' : ''}&gt;Español&lt;/option&gt;
            &lt;/select&gt;
        &lt;/form&gt;
        &lt;form method="post"&gt;
            &lt;label for="username"&gt;&lt;fmt:message key="login.label.username" /&gt;:&lt;/label&gt;
            &lt;input type="text" id="username" name="username"&gt;
            &lt;br&gt;
            &lt;label for="password"&gt;&lt;fmt:message key="login.label.password" /&gt;:&lt;/label&gt;
            &lt;input type="password" id="password" name="password"&gt;
            &lt;br&gt;
            &lt;fmt:message key="login.button.submit" var="buttonValue" /&gt;
            &lt;input type="submit" name="submit" value="${buttonValue}"&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
******************************
Original:
for (int i = 0; i &lt; size; i++)
   a += b;
   System.out.println("foo");
******************************
Normalized:
******************************
Original:
for (int i = 0; i &lt; size; i++)
   a += b;
   System.out.println("foo");
******************************
Normalized:
for (int i = 0; i &lt; size; i++)
   a += b;
   System.out.println("foo");
******************************
Original:
myObject = new ArrayList&lt;Object&gt;(myTempObject);
******************************
Normalized:
******************************
Original:
myObject = new ArrayList&lt;Object&gt;(myTempObject);
******************************
Normalized:
myObject = new ArrayList&lt;Object&gt;(myTempObject);
******************************
Original:
public class Utilities {

    private class SolarCalendar {

        public String strWeekDay = "";
        public String strMonth = "";

        int date;
        int month;
        int year;

        public SolarCalendar()
        {
            Date MiladiDate = new Date();
            calcSolarCalendar(MiladiDate);
        }

        public SolarCalendar(Date MiladiDate)
        {
            calcSolarCalendar(MiladiDate);
        }

        private void calcSolarCalendar(Date MiladiDate) {

            int ld;

            int miladiYear = MiladiDate.getYear() + 1900;
            int miladiMonth = MiladiDate.getMonth() + 1;
            int miladiDate = MiladiDate.getDate();
            int WeekDay = MiladiDate.getDay();

            int[] buf1 = new int[12];
            int[] buf2 = new int[12];

            buf1[0] = 0;
            buf1[1] = 31;
            buf1[2] = 59;
            buf1[3] = 90;
            buf1[4] = 120;
            buf1[5] = 151;
            buf1[6] = 181;
            buf1[7] = 212;
            buf1[8] = 243;
            buf1[9] = 273;
            buf1[10] = 304;
            buf1[11] = 334;

            buf2[0] = 0;
            buf2[1] = 31;
            buf2[2] = 60;
            buf2[3] = 91;
            buf2[4] = 121;
            buf2[5] = 152;
            buf2[6] = 182;
            buf2[7] = 213;
            buf2[8] = 244;
            buf2[9] = 274;
            buf2[10] = 305;
            buf2[11] = 335;

            if ((miladiYear % 4) != 0) {
                date = buf1[miladiMonth - 1] + miladiDate;

                if (date &gt; 79) {
                    date = date - 79;
                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = date / 31;
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                } else {
                    if ((miladiYear &gt; 1996) &amp;&amp; (miladiYear % 4) == 1) {
                        ld = 11;
                    } else {
                        ld = 10;
                    }
                    date = date + ld;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }
            } else {
                date = buf2[miladiMonth - 1] + miladiDate;

                if (miladiYear &gt;= 1996) {
                    ld = 79;
                } else {
                    ld = 80;
                }
                if (date &gt; ld) {
                    date = date - ld;

                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = (date / 31);
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                }

                else {
                    date = date + 10;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }

            }

            switch (month) {
            case 1:
                strMonth = "فروردين";
                break;
            case 2:
                strMonth = "ارديبهشت";
                break;
            case 3:
                strMonth = "خرداد";
                break;
            case 4:
                strMonth = "تير";
                break;
            case 5:
                strMonth = "مرداد";
                break;
            case 6:
                strMonth = "شهريور";
                break;
            case 7:
                strMonth = "مهر";
                break;
            case 8:
                strMonth = "آبان";
                break;
            case 9:
                strMonth = "آذر";
                break;
            case 10:
                strMonth = "دي";
                break;
            case 11:
                strMonth = "بهمن";
                break;
            case 12:
                strMonth = "اسفند";
                break;
            }

            switch (WeekDay) {

            case 0:
                strWeekDay = "يکشنبه";
                break;
            case 1:
                strWeekDay = "دوشنبه";
                break;
            case 2:
                strWeekDay = "سه شنبه";
                break;
            case 3:
                strWeekDay = "چهارشنبه";
                break;
            case 4:
                strWeekDay = "پنج شنبه";
                break;
            case 5:
                strWeekDay = "جمعه";
                break;
            case 6:
                strWeekDay = "شنبه";
                break;
            }

        }

    }

    public static String getCurrentShamsidate() {
        Locale loc = new Locale("en_US");
        Utilities util = new Utilities();
        SolarCalendar sc = util.new SolarCalendar();
        return String.valueOf(sc.year) + "/" + String.format(loc, "%02d",
                sc.month) + "/" + String.format(loc, "%02d", sc.date);
    }
}
******************************
Normalized:
******************************
Original:
public class Utilities {

    private class SolarCalendar {

        public String strWeekDay = "";
        public String strMonth = "";

        int date;
        int month;
        int year;

        public SolarCalendar()
        {
            Date MiladiDate = new Date();
            calcSolarCalendar(MiladiDate);
        }

        public SolarCalendar(Date MiladiDate)
        {
            calcSolarCalendar(MiladiDate);
        }

        private void calcSolarCalendar(Date MiladiDate) {

            int ld;

            int miladiYear = MiladiDate.getYear() + 1900;
            int miladiMonth = MiladiDate.getMonth() + 1;
            int miladiDate = MiladiDate.getDate();
            int WeekDay = MiladiDate.getDay();

            int[] buf1 = new int[12];
            int[] buf2 = new int[12];

            buf1[0] = 0;
            buf1[1] = 31;
            buf1[2] = 59;
            buf1[3] = 90;
            buf1[4] = 120;
            buf1[5] = 151;
            buf1[6] = 181;
            buf1[7] = 212;
            buf1[8] = 243;
            buf1[9] = 273;
            buf1[10] = 304;
            buf1[11] = 334;

            buf2[0] = 0;
            buf2[1] = 31;
            buf2[2] = 60;
            buf2[3] = 91;
            buf2[4] = 121;
            buf2[5] = 152;
            buf2[6] = 182;
            buf2[7] = 213;
            buf2[8] = 244;
            buf2[9] = 274;
            buf2[10] = 305;
            buf2[11] = 335;

            if ((miladiYear % 4) != 0) {
                date = buf1[miladiMonth - 1] + miladiDate;

                if (date &gt; 79) {
                    date = date - 79;
                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = date / 31;
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                } else {
                    if ((miladiYear &gt; 1996) &amp;&amp; (miladiYear % 4) == 1) {
                        ld = 11;
                    } else {
                        ld = 10;
                    }
                    date = date + ld;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }
            } else {
                date = buf2[miladiMonth - 1] + miladiDate;

                if (miladiYear &gt;= 1996) {
                    ld = 79;
                } else {
                    ld = 80;
                }
                if (date &gt; ld) {
                    date = date - ld;

                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = (date / 31);
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                }

                else {
                    date = date + 10;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }

            }

            switch (month) {
            case 1:
                strMonth = "فروردين";
                break;
            case 2:
                strMonth = "ارديبهشت";
                break;
            case 3:
                strMonth = "خرداد";
                break;
            case 4:
                strMonth = "تير";
                break;
            case 5:
                strMonth = "مرداد";
                break;
            case 6:
                strMonth = "شهريور";
                break;
            case 7:
                strMonth = "مهر";
                break;
            case 8:
                strMonth = "آبان";
                break;
            case 9:
                strMonth = "آذر";
                break;
            case 10:
                strMonth = "دي";
                break;
            case 11:
                strMonth = "بهمن";
                break;
            case 12:
                strMonth = "اسفند";
                break;
            }

            switch (WeekDay) {

            case 0:
                strWeekDay = "يکشنبه";
                break;
            case 1:
                strWeekDay = "دوشنبه";
                break;
            case 2:
                strWeekDay = "سه شنبه";
                break;
            case 3:
                strWeekDay = "چهارشنبه";
                break;
            case 4:
                strWeekDay = "پنج شنبه";
                break;
            case 5:
                strWeekDay = "جمعه";
                break;
            case 6:
                strWeekDay = "شنبه";
                break;
            }

        }

    }

    public static String getCurrentShamsidate() {
        Locale loc = new Locale("en_US");
        Utilities util = new Utilities();
        SolarCalendar sc = util.new SolarCalendar();
        return String.valueOf(sc.year) + "/" + String.format(loc, "%02d",
                sc.month) + "/" + String.format(loc, "%02d", sc.date);
    }
}
******************************
Normalized:
public class Utilities {

    private class SolarCalendar {

        public String strWeekDay = "";
        public String strMonth = "";

        int date;
        int month;
        int year;

        public SolarCalendar()
        {
            Date MiladiDate = new Date();
            calcSolarCalendar(MiladiDate);
        }

        public SolarCalendar(Date MiladiDate)
        {
            calcSolarCalendar(MiladiDate);
        }

        private void calcSolarCalendar(Date MiladiDate) {

            int ld;

            int miladiYear = MiladiDate.getYear() + 1900;
            int miladiMonth = MiladiDate.getMonth() + 1;
            int miladiDate = MiladiDate.getDate();
            int WeekDay = MiladiDate.getDay();

            int[] buf1 = new int[12];
            int[] buf2 = new int[12];

            buf1[0] = 0;
            buf1[1] = 31;
            buf1[2] = 59;
            buf1[3] = 90;
            buf1[4] = 120;
            buf1[5] = 151;
            buf1[6] = 181;
            buf1[7] = 212;
            buf1[8] = 243;
            buf1[9] = 273;
            buf1[10] = 304;
            buf1[11] = 334;

            buf2[0] = 0;
            buf2[1] = 31;
            buf2[2] = 60;
            buf2[3] = 91;
            buf2[4] = 121;
            buf2[5] = 152;
            buf2[6] = 182;
            buf2[7] = 213;
            buf2[8] = 244;
            buf2[9] = 274;
            buf2[10] = 305;
            buf2[11] = 335;

            if ((miladiYear % 4) != 0) {
                date = buf1[miladiMonth - 1] + miladiDate;

                if (date &gt; 79) {
                    date = date - 79;
                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = date / 31;
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                } else {
                    if ((miladiYear &gt; 1996) &amp;&amp; (miladiYear % 4) == 1) {
                        ld = 11;
                    } else {
                        ld = 10;
                    }
                    date = date + ld;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }
            } else {
                date = buf2[miladiMonth - 1] + miladiDate;

                if (miladiYear &gt;= 1996) {
                    ld = 79;
                } else {
                    ld = 80;
                }
                if (date &gt; ld) {
                    date = date - ld;

                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = (date / 31);
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                }

                else {
                    date = date + 10;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }

            }

            switch (month) {
            case 1:
                strMonth = "فروردين";
                break;
            case 2:
                strMonth = "ارديبهشت";
                break;
            case 3:
                strMonth = "خرداد";
                break;
            case 4:
                strMonth = "تير";
                break;
            case 5:
                strMonth = "مرداد";
                break;
            case 6:
                strMonth = "شهريور";
                break;
            case 7:
                strMonth = "مهر";
                break;
            case 8:
                strMonth = "آبان";
                break;
            case 9:
                strMonth = "آذر";
                break;
            case 10:
                strMonth = "دي";
                break;
            case 11:
                strMonth = "بهمن";
                break;
            case 12:
                strMonth = "اسفند";
                break;
            }

            switch (WeekDay) {

            case 0:
                strWeekDay = "يکشنبه";
                break;
            case 1:
                strWeekDay = "دوشنبه";
                break;
            case 2:
                strWeekDay = "سه شنبه";
                break;
            case 3:
                strWeekDay = "چهارشنبه";
                break;
            case 4:
                strWeekDay = "پنج شنبه";
                break;
            case 5:
                strWeekDay = "جمعه";
                break;
            case 6:
                strWeekDay = "شنبه";
                break;
            }

        }

    }

    public static String getCurrentShamsidate() {
        Locale loc = new Locale("en_US");
        Utilities util = new Utilities();
        SolarCalendar sc = util.new SolarCalendar();
        return String.valueOf(sc.year) + "/" + String.format(loc, "%02d",
                sc.month) + "/" + String.format(loc, "%02d", sc.date);
    }
}
******************************
Original:
public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription
******************************
Normalized:
******************************
Original:
public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription
******************************
Normalized:
public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription
******************************
Original:
void method1() {
    synchronized (this) {
        method2()
    }
}

void method2() {
    synchronized (this) {
    }
}
******************************
Normalized:
******************************
Original:
void method1() {
    synchronized (this) {
        method2()
    }
}

void method2() {
    synchronized (this) {
    }
}
******************************
Normalized:
void method1() {
    synchronized (this) {
        method2()
    }
}

void method2() {
    synchronized (this) {
    }
}
******************************
Original:
AnotherClass anotherObjSpy = Mockito.spy(new AnotherClass());
// do stuff -- e.g. anotherObjSpy.foo(...);
verify(anotherObjSpy).codePath1(...);
******************************
Normalized:
******************************
Original:
AnotherClass anotherObjSpy = Mockito.spy(new AnotherClass());
// do stuff -- e.g. anotherObjSpy.foo(...);
verify(anotherObjSpy).codePath1(...);
******************************
Normalized:
AnotherClass anotherObjSpy = Mockito.spy(new AnotherClass());
// do stuff -- e.g. anotherObjSpy.foo(...);
verify(anotherObjSpy).codePath1(...);
******************************
Original:
public class GenericList &lt;T&gt; extends ArrayList&lt;T&gt;
{
     private Class&lt;T&gt; genericType;

     public GenericList(Class&lt;T&gt; c)
     {
          this.genericType = c;
     }

     public Class&lt;T&gt; getGenericType()
     {
          return genericType;
     }
}
******************************
Normalized:
******************************
Original:
public class GenericList &lt;T&gt; extends ArrayList&lt;T&gt;
{
     private Class&lt;T&gt; genericType;

     public GenericList(Class&lt;T&gt; c)
     {
          this.genericType = c;
     }

     public Class&lt;T&gt; getGenericType()
     {
          return genericType;
     }
}
******************************
Normalized:
public class GenericList &lt;T&gt; extends ArrayList&lt;T&gt;
{
     private Class&lt;T&gt; genericType;

     public GenericList(Class&lt;T&gt; c)
     {
          this.genericType = c;
     }

     public Class&lt;T&gt; getGenericType()
     {
          return genericType;
     }
}
******************************
Original:
package hashmaptest;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

public class HashMapTest {

    private static final List&lt;Result&gt; results = new ArrayList&lt;Result&gt;();

    public static void main(String[] args) throws IOException {

        //First entry of each array is the sample collection size, subsequent entries
        //are the hash limits
        final int[][] sampleSizesAndHashLimits = new int[][] {
            {100, 50, 90, 100},
            {1000, 500, 900, 990, 1000},
            {100000, 10000, 90000, 99000, 100000}
        };
        final double[] initialCapacityFactors = new double[] {0.5, 0.75, 1.0, 1.25, 1.5, 2.0};
        final float[] loadFactors = new float[] {0.5f, 0.75f, 1.0f, 1.25f};

        //Doing a warmup run to eliminate JIT influence
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        results.clear();

        //Now for the real thing...
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        Collections.sort(results);

        for(final Result result : results) {
            result.printSummary();
        }

//      ResultVisualizer.visualizeResults(results);

    }

    private static void runTest(final int hashLimit, final int sampleSize,
            final double initCapacityFactor, final float loadFactor) {

        final int initialCapacity = (int)(sampleSize * initCapacityFactor);

        System.out.println("Running test for a sample collection of size " + sampleSize 
            + ", an initial capacity of " + initialCapacity + ", a load factor of "
            + loadFactor + " and keys with a hash code limited to " + hashLimit);
        System.out.println("====================");

        double hashOverload = (((double)sampleSize/hashLimit) - 1.0) * 100.0;

        System.out.println("Hash code overload: " + hashOverload + "%");

        //Generating our sample key collection.
        final List&lt;Key&gt; keys = generateSamples(hashLimit, sampleSize);

        //Generating our value collection
        final List&lt;Object&gt; values = generateValues(sampleSize);

        final HashMap&lt;Key, Object&gt; map = new HashMap&lt;Key, Object&gt;(initialCapacity, loadFactor);

        final long startPut = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.put(keys.get(i), values.get(i));
        }

        final long endPut = System.nanoTime();

        final long putTime = endPut - startPut;
        final long averagePutTime = putTime/(sampleSize/10);

        System.out.println("Time to map all keys to their values: " + putTime + " ns");
        System.out.println("Average put time per 10 entries: " + averagePutTime + " ns");

        final long startGet = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.get(keys.get(i));
        }

        final long endGet = System.nanoTime();

        final long getTime = endGet - startGet;
        final long averageGetTime = getTime/(sampleSize/10);

        System.out.println("Time to get the value for every key: " + getTime + " ns");
        System.out.println("Average get time per 10 entries: " + averageGetTime + " ns");

        System.out.println("");

        final Result result = 
            new Result(sampleSize, initialCapacity, loadFactor, hashOverload, averagePutTime, averageGetTime, hashLimit);

        results.add(result);

        //Haha, what kind of noob explicitly calls for garbage collection?
        System.gc();

        try {
            Thread.sleep(200);
        } catch(final InterruptedException e) {}

    }

    private static List&lt;Key&gt; generateSamples(final int hashLimit, final int sampleSize) {

        final ArrayList&lt;Key&gt; result = new ArrayList&lt;Key&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Key(i, hashLimit));
        }

        return result;

    }

    private static List&lt;Object&gt; generateValues(final int sampleSize) {

        final ArrayList&lt;Object&gt; result = new ArrayList&lt;Object&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Object());
        }

        return result;

    }

    private static class Key {

        private final int hashCode;
        private final int id;

        Key(final int id, final int hashLimit) {

            //Equals implies same hashCode if limit is the same
            //Same hashCode doesn't necessarily implies equals

            this.id = id;
            this.hashCode = id % hashLimit;

        }

        @Override
        public int hashCode() {
            return hashCode;
        }

        @Override
        public boolean equals(final Object o) {
            return ((Key)o).id == this.id;
        }

    }

    static class Result implements Comparable&lt;Result&gt; {

        final int sampleSize;
        final int initialCapacity;
        final float loadFactor;
        final double hashOverloadPercentage;
        final long averagePutTime;
        final long averageGetTime;
        final int hashLimit;

        Result(final int sampleSize, final int initialCapacity, final float loadFactor, 
                final double hashOverloadPercentage, final long averagePutTime, 
                final long averageGetTime, final int hashLimit) {

            this.sampleSize = sampleSize;
            this.initialCapacity = initialCapacity;
            this.loadFactor = loadFactor;
            this.hashOverloadPercentage = hashOverloadPercentage;
            this.averagePutTime = averagePutTime;
            this.averageGetTime = averageGetTime;
            this.hashLimit = hashLimit;

        }

        @Override
        public int compareTo(final Result o) {

            final long putDiff = o.averagePutTime - this.averagePutTime;
            final long getDiff = o.averageGetTime - this.averageGetTime;

            return (int)(putDiff + getDiff);
        }

        void printSummary() {

            System.out.println("" + averagePutTime + " ns per 10 puts, "
                + averageGetTime + " ns per 10 gets, for a load factor of "
                + loadFactor + ", initial capacity of " + initialCapacity
                + " for " + sampleSize + " mappings and " + hashOverloadPercentage 
                + "% hash code overload.");

        }

    }

}
******************************
Normalized:
******************************
Original:
package hashmaptest;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

public class HashMapTest {

    private static final List&lt;Result&gt; results = new ArrayList&lt;Result&gt;();

    public static void main(String[] args) throws IOException {

        //First entry of each array is the sample collection size, subsequent entries
        //are the hash limits
        final int[][] sampleSizesAndHashLimits = new int[][] {
            {100, 50, 90, 100},
            {1000, 500, 900, 990, 1000},
            {100000, 10000, 90000, 99000, 100000}
        };
        final double[] initialCapacityFactors = new double[] {0.5, 0.75, 1.0, 1.25, 1.5, 2.0};
        final float[] loadFactors = new float[] {0.5f, 0.75f, 1.0f, 1.25f};

        //Doing a warmup run to eliminate JIT influence
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        results.clear();

        //Now for the real thing...
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        Collections.sort(results);

        for(final Result result : results) {
            result.printSummary();
        }

//      ResultVisualizer.visualizeResults(results);

    }

    private static void runTest(final int hashLimit, final int sampleSize,
            final double initCapacityFactor, final float loadFactor) {

        final int initialCapacity = (int)(sampleSize * initCapacityFactor);

        System.out.println("Running test for a sample collection of size " + sampleSize 
            + ", an initial capacity of " + initialCapacity + ", a load factor of "
            + loadFactor + " and keys with a hash code limited to " + hashLimit);
        System.out.println("====================");

        double hashOverload = (((double)sampleSize/hashLimit) - 1.0) * 100.0;

        System.out.println("Hash code overload: " + hashOverload + "%");

        //Generating our sample key collection.
        final List&lt;Key&gt; keys = generateSamples(hashLimit, sampleSize);

        //Generating our value collection
        final List&lt;Object&gt; values = generateValues(sampleSize);

        final HashMap&lt;Key, Object&gt; map = new HashMap&lt;Key, Object&gt;(initialCapacity, loadFactor);

        final long startPut = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.put(keys.get(i), values.get(i));
        }

        final long endPut = System.nanoTime();

        final long putTime = endPut - startPut;
        final long averagePutTime = putTime/(sampleSize/10);

        System.out.println("Time to map all keys to their values: " + putTime + " ns");
        System.out.println("Average put time per 10 entries: " + averagePutTime + " ns");

        final long startGet = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.get(keys.get(i));
        }

        final long endGet = System.nanoTime();

        final long getTime = endGet - startGet;
        final long averageGetTime = getTime/(sampleSize/10);

        System.out.println("Time to get the value for every key: " + getTime + " ns");
        System.out.println("Average get time per 10 entries: " + averageGetTime + " ns");

        System.out.println("");

        final Result result = 
            new Result(sampleSize, initialCapacity, loadFactor, hashOverload, averagePutTime, averageGetTime, hashLimit);

        results.add(result);

        //Haha, what kind of noob explicitly calls for garbage collection?
        System.gc();

        try {
            Thread.sleep(200);
        } catch(final InterruptedException e) {}

    }

    private static List&lt;Key&gt; generateSamples(final int hashLimit, final int sampleSize) {

        final ArrayList&lt;Key&gt; result = new ArrayList&lt;Key&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Key(i, hashLimit));
        }

        return result;

    }

    private static List&lt;Object&gt; generateValues(final int sampleSize) {

        final ArrayList&lt;Object&gt; result = new ArrayList&lt;Object&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Object());
        }

        return result;

    }

    private static class Key {

        private final int hashCode;
        private final int id;

        Key(final int id, final int hashLimit) {

            //Equals implies same hashCode if limit is the same
            //Same hashCode doesn't necessarily implies equals

            this.id = id;
            this.hashCode = id % hashLimit;

        }

        @Override
        public int hashCode() {
            return hashCode;
        }

        @Override
        public boolean equals(final Object o) {
            return ((Key)o).id == this.id;
        }

    }

    static class Result implements Comparable&lt;Result&gt; {

        final int sampleSize;
        final int initialCapacity;
        final float loadFactor;
        final double hashOverloadPercentage;
        final long averagePutTime;
        final long averageGetTime;
        final int hashLimit;

        Result(final int sampleSize, final int initialCapacity, final float loadFactor, 
                final double hashOverloadPercentage, final long averagePutTime, 
                final long averageGetTime, final int hashLimit) {

            this.sampleSize = sampleSize;
            this.initialCapacity = initialCapacity;
            this.loadFactor = loadFactor;
            this.hashOverloadPercentage = hashOverloadPercentage;
            this.averagePutTime = averagePutTime;
            this.averageGetTime = averageGetTime;
            this.hashLimit = hashLimit;

        }

        @Override
        public int compareTo(final Result o) {

            final long putDiff = o.averagePutTime - this.averagePutTime;
            final long getDiff = o.averageGetTime - this.averageGetTime;

            return (int)(putDiff + getDiff);
        }

        void printSummary() {

            System.out.println("" + averagePutTime + " ns per 10 puts, "
                + averageGetTime + " ns per 10 gets, for a load factor of "
                + loadFactor + ", initial capacity of " + initialCapacity
                + " for " + sampleSize + " mappings and " + hashOverloadPercentage 
                + "% hash code overload.");

        }

    }

}
******************************
Normalized:
package hashmaptest;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

public class HashMapTest {

    private static final List&lt;Result&gt; results = new ArrayList&lt;Result&gt;();

    public static void main(String[] args) throws IOException {

        //First entry of each array is the sample collection size, subsequent entries
        //are the hash limits
        final int[][] sampleSizesAndHashLimits = new int[][] {
            {100, 50, 90, 100},
            {1000, 500, 900, 990, 1000},
            {100000, 10000, 90000, 99000, 100000}
        };
        final double[] initialCapacityFactors = new double[] {0.5, 0.75, 1.0, 1.25, 1.5, 2.0};
        final float[] loadFactors = new float[] {0.5f, 0.75f, 1.0f, 1.25f};

        //Doing a warmup run to eliminate JIT influence
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        results.clear();

        //Now for the real thing...
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        Collections.sort(results);

        for(final Result result : results) {
            result.printSummary();
        }

//      ResultVisualizer.visualizeResults(results);

    }

    private static void runTest(final int hashLimit, final int sampleSize,
            final double initCapacityFactor, final float loadFactor) {

        final int initialCapacity = (int)(sampleSize * initCapacityFactor);

        System.out.println("Running test for a sample collection of size " + sampleSize 
            + ", an initial capacity of " + initialCapacity + ", a load factor of "
            + loadFactor + " and keys with a hash code limited to " + hashLimit);
        System.out.println("====================");

        double hashOverload = (((double)sampleSize/hashLimit) - 1.0) * 100.0;

        System.out.println("Hash code overload: " + hashOverload + "%");

        //Generating our sample key collection.
        final List&lt;Key&gt; keys = generateSamples(hashLimit, sampleSize);

        //Generating our value collection
        final List&lt;Object&gt; values = generateValues(sampleSize);

        final HashMap&lt;Key, Object&gt; map = new HashMap&lt;Key, Object&gt;(initialCapacity, loadFactor);

        final long startPut = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.put(keys.get(i), values.get(i));
        }

        final long endPut = System.nanoTime();

        final long putTime = endPut - startPut;
        final long averagePutTime = putTime/(sampleSize/10);

        System.out.println("Time to map all keys to their values: " + putTime + " ns");
        System.out.println("Average put time per 10 entries: " + averagePutTime + " ns");

        final long startGet = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.get(keys.get(i));
        }

        final long endGet = System.nanoTime();

        final long getTime = endGet - startGet;
        final long averageGetTime = getTime/(sampleSize/10);

        System.out.println("Time to get the value for every key: " + getTime + " ns");
        System.out.println("Average get time per 10 entries: " + averageGetTime + " ns");

        System.out.println("");

        final Result result = 
            new Result(sampleSize, initialCapacity, loadFactor, hashOverload, averagePutTime, averageGetTime, hashLimit);

        results.add(result);

        //Haha, what kind of noob explicitly calls for garbage collection?
        System.gc();

        try {
            Thread.sleep(200);
        } catch(final InterruptedException e) {}

    }

    private static List&lt;Key&gt; generateSamples(final int hashLimit, final int sampleSize) {

        final ArrayList&lt;Key&gt; result = new ArrayList&lt;Key&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Key(i, hashLimit));
        }

        return result;

    }

    private static List&lt;Object&gt; generateValues(final int sampleSize) {

        final ArrayList&lt;Object&gt; result = new ArrayList&lt;Object&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Object());
        }

        return result;

    }

    private static class Key {

        private final int hashCode;
        private final int id;

        Key(final int id, final int hashLimit) {

            //Equals implies same hashCode if limit is the same
            //Same hashCode doesn't necessarily implies equals

            this.id = id;
            this.hashCode = id % hashLimit;

        }

        @Override
        public int hashCode() {
            return hashCode;
        }

        @Override
        public boolean equals(final Object o) {
            return ((Key)o).id == this.id;
        }

    }

    static class Result implements Comparable&lt;Result&gt; {

        final int sampleSize;
        final int initialCapacity;
        final float loadFactor;
        final double hashOverloadPercentage;
        final long averagePutTime;
        final long averageGetTime;
        final int hashLimit;

        Result(final int sampleSize, final int initialCapacity, final float loadFactor, 
                final double hashOverloadPercentage, final long averagePutTime, 
                final long averageGetTime, final int hashLimit) {

            this.sampleSize = sampleSize;
            this.initialCapacity = initialCapacity;
            this.loadFactor = loadFactor;
            this.hashOverloadPercentage = hashOverloadPercentage;
            this.averagePutTime = averagePutTime;
            this.averageGetTime = averageGetTime;
            this.hashLimit = hashLimit;

        }

        @Override
        public int compareTo(final Result o) {

            final long putDiff = o.averagePutTime - this.averagePutTime;
            final long getDiff = o.averageGetTime - this.averageGetTime;

            return (int)(putDiff + getDiff);
        }

        void printSummary() {

            System.out.println("" + averagePutTime + " ns per 10 puts, "
                + averageGetTime + " ns per 10 gets, for a load factor of "
                + loadFactor + ", initial capacity of " + initialCapacity
                + " for " + sampleSize + " mappings and " + hashOverloadPercentage 
                + "% hash code overload.");

        }

    }

}
******************************
Original:
StringBuilder sb = new StringBuilder();
for (int i = 0; i &lt; 500; i ++) {
    sb.append(i);
}
******************************
Normalized:
******************************
Original:
StringBuilder sb = new StringBuilder();
for (int i = 0; i &lt; 500; i ++) {
    sb.append(i);
}
******************************
Normalized:
StringBuilder sb = new StringBuilder();
for (int i = 0; i &lt; 500; i ++) {
    sb.append(i);
}
******************************
Original:
arrayList.set(index i,String replaceElement);
******************************
Normalized:
******************************
Original:
arrayList.set(index i,String replaceElement);
******************************
Normalized:
arrayList.set(index i,String replaceElement);
******************************
Original:
&lt;properties&gt;
  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
******************************
Normalized:
******************************
Original:
&lt;properties&gt;
  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
******************************
Normalized:
&lt;properties&gt;
  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
******************************
Original:
public class RetryTest {
    public class Retry implements TestRule {
        private int retryCount;

        public Retry(int retryCount) {
            this.retryCount = retryCount;
        }

        public Statement apply(Statement base, Description description) {
            return statement(base, description);
        }

        private Statement statement(final Statement base, final Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    Throwable caughtThrowable = null;

                    // implement retry logic here
                    for (int i = 0; i &lt; retryCount; i++) {
                        try {
                            base.evaluate();
                            return;
                        } catch (Throwable t) {
                            caughtThrowable = t;
                            System.err.println(description.getDisplayName() + ": run " + (i+1) + " failed");
                        }
                    }
                    System.err.println(description.getDisplayName() + ": giving up after " + retryCount + " failures");
                    throw caughtThrowable;
                }
            };
        }
    }

    @Rule
    public Retry retry = new Retry(3);

    @Test
    public void test1() {
    }

    @Test
    public void test2() {
        Object o = null;
        o.equals("foo");
    }
}
******************************
Normalized:
******************************
Original:
public class RetryTest {
    public class Retry implements TestRule {
        private int retryCount;

        public Retry(int retryCount) {
            this.retryCount = retryCount;
        }

        public Statement apply(Statement base, Description description) {
            return statement(base, description);
        }

        private Statement statement(final Statement base, final Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    Throwable caughtThrowable = null;

                    // implement retry logic here
                    for (int i = 0; i &lt; retryCount; i++) {
                        try {
                            base.evaluate();
                            return;
                        } catch (Throwable t) {
                            caughtThrowable = t;
                            System.err.println(description.getDisplayName() + ": run " + (i+1) + " failed");
                        }
                    }
                    System.err.println(description.getDisplayName() + ": giving up after " + retryCount + " failures");
                    throw caughtThrowable;
                }
            };
        }
    }

    @Rule
    public Retry retry = new Retry(3);

    @Test
    public void test1() {
    }

    @Test
    public void test2() {
        Object o = null;
        o.equals("foo");
    }
}
******************************
Normalized:
public class RetryTest {
    public class Retry implements TestRule {
        private int retryCount;

        public Retry(int retryCount) {
            this.retryCount = retryCount;
        }

        public Statement apply(Statement base, Description description) {
            return statement(base, description);
        }

        private Statement statement(final Statement base, final Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    Throwable caughtThrowable = null;

                    // implement retry logic here
                    for (int i = 0; i &lt; retryCount; i++) {
                        try {
                            base.evaluate();
                            return;
                        } catch (Throwable t) {
                            caughtThrowable = t;
                            System.err.println(description.getDisplayName() + ": run " + (i+1) + " failed");
                        }
                    }
                    System.err.println(description.getDisplayName() + ": giving up after " + retryCount + " failures");
                    throw caughtThrowable;
                }
            };
        }
    }

    @Rule
    public Retry retry = new Retry(3);

    @Test
    public void test1() {
    }

    @Test
    public void test2() {
        Object o = null;
        o.equals("foo");
    }
}
******************************
Original:
Set&lt;Integer&gt; s; //contains your Integers
...
Set&lt;Integer&gt; temp = new Set&lt;Integer&gt;();
for(Integer i : s)
    temp.add(i+1);
s.clear();
s.addAll(temp);
******************************
Normalized:
******************************
Original:
Set&lt;Integer&gt; s; //contains your Integers
...
Set&lt;Integer&gt; temp = new Set&lt;Integer&gt;();
for(Integer i : s)
    temp.add(i+1);
s.clear();
s.addAll(temp);
******************************
Normalized:
Set&lt;Integer&gt; s; //contains your Integers
...
Set&lt;Integer&gt; temp = new Set&lt;Integer&gt;();
for(Integer i : s)
    temp.add(i+1);
s.clear();
s.addAll(temp);
******************************
Original:
Future&lt;T&gt; future = ConcurrentUtils.constantFuture(T myValue);
******************************
Normalized:
******************************
Original:
Future&lt;T&gt; future = ConcurrentUtils.constantFuture(T myValue);
******************************
Normalized:
Future&lt;T&gt; future = ConcurrentUtils.constantFuture(T myValue);
******************************
Original:
final EditText edittext = (EditText) findViewById(R.id.edittext);
edittext.setOnKeyListener(new View.OnKeyListener() {
    public boolean onKey(View v, int keyCode, KeyEvent event) {
        if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; keyCode == KeyEvent.KEYCODE_ENTER) {
            Toast.makeText(HelloFormStuff.this, edittext.getText(), Toast.LENGTH_SHORT).show();
            return true;
        }
        return false;
    }
});
******************************
Normalized:
******************************
Original:
final EditText edittext = (EditText) findViewById(R.id.edittext);
edittext.setOnKeyListener(new View.OnKeyListener() {
    public boolean onKey(View v, int keyCode, KeyEvent event) {
        if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; keyCode == KeyEvent.KEYCODE_ENTER) {
            Toast.makeText(HelloFormStuff.this, edittext.getText(), Toast.LENGTH_SHORT).show();
            return true;
        }
        return false;
    }
});
******************************
Normalized:
final EditText edittext = (EditText) findViewById(R.id.edittext);
edittext.setOnKeyListener(new View.OnKeyListener() {
    public boolean onKey(View v, int keyCode, KeyEvent event) {
        if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; keyCode == KeyEvent.KEYCODE_ENTER) {
            Toast.makeText(HelloFormStuff.this, edittext.getText(), Toast.LENGTH_SHORT).show();
            return true;
        }
        return false;
    }
});
******************************
Original:
&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;otherOutputDir&lt;/id&gt;
        &lt;build&gt;
            &lt;directory&gt;yourDirectory&lt;/directory&gt;
        &lt;/build&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
******************************
Normalized:
******************************
Original:
&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;otherOutputDir&lt;/id&gt;
        &lt;build&gt;
            &lt;directory&gt;yourDirectory&lt;/directory&gt;
        &lt;/build&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
******************************
Normalized:
&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;otherOutputDir&lt;/id&gt;
        &lt;build&gt;
            &lt;directory&gt;yourDirectory&lt;/directory&gt;
        &lt;/build&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
******************************
Original:
...10110110
******************************
Normalized:
******************************
Original:
...10110110
******************************
Normalized:
...10110110
******************************
Original:
@ManyToMany(fetch = FetchType.EAGER)
******************************
Normalized:
******************************
Original:
@ManyToMany(fetch = FetchType.EAGER)
******************************
Normalized:
@ManyToMany(fetch = FetchType.EAGER)
******************************
Original:
(IDLjava/lang/Thread;)Ljava/lang/Object;
******************************
Normalized:
******************************
Original:
(IDLjava/lang/Thread;)Ljava/lang/Object;
******************************
Normalized:
(IDLjava/lang/Thread;)Ljava/lang/Object;
******************************
Original:
$ mvn dependency:copy-dependencies -DoutputDirectory=OUTPUT_DIR
******************************
Normalized:
******************************
Original:
$ mvn dependency:copy-dependencies -DoutputDirectory=OUTPUT_DIR
******************************
Normalized:
$ mvn dependency:copy-dependencies -DoutputDirectory=OUTPUT_DIR
******************************
Original:
(?:\u{D A}|(?!\u{D A})[\u{A}-\u{D}\u{85}\u{2028}\u{2029}]
******************************
Normalized:
******************************
Original:
(?:\u{D A}|(?!\u{D A})[\u{A}-\u{D}\u{85}\u{2028}\u{2029}]
******************************
Normalized:
(?:\u{D A}|(?!\u{D A})[\u{A}-\u{D}\u{85}\u{2028}\u{2029}]
******************************
Original:
module org.example.foo {
    requires java.xml.bind;
}
******************************
Normalized:
******************************
Original:
module org.example.foo {
    requires java.xml.bind;
}
******************************
Normalized:
module org.example.foo {
    requires java.xml.bind;
}
******************************
Original:
public class CompletionServiceTest {

        class CalcResult {
             long result ;

             CalcResult(long l) {
                 result = l;
             }
        }

        class CallableTask implements Callable&lt;CalcResult&gt; {
            String taskName ;
            long  input1 ;
            int input2 ;

            CallableTask(String name , long v1 , int v2 ) {
                taskName = name;
                input1 = v1;
                input2 = v2 ;
            }

            public CalcResult call() throws Exception {
                System.out.println(" Task " + taskName + " Started -----");
                for(int i=0;i&lt;input2 ;i++) {
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        System.out.println(" Task " + taskName + " Interrupted !! ");
                        e.printStackTrace();
                    }
                    input1 += i;
                }
                System.out.println(" Task " + taskName + " Completed @@@@@@");
                return new CalcResult(input1) ;
            }

        }

        public void test(){
            ExecutorService taskExecutor = Executors.newFixedThreadPool(3);
            CompletionService&lt;CalcResult&gt; taskCompletionService = new ExecutorCompletionService&lt;CalcResult&gt;(taskExecutor);

            int submittedTasks = 5;
            for (int i=0;i&lt; submittedTasks;i++) {
                taskCompletionService.submit(new CallableTask (
                        String.valueOf(i), 
                            (i * 10), 
                            ((i * 10) + 10  )
                        ));
               System.out.println("Task " + String.valueOf(i) + "subitted");
            }
            for (int tasksHandled=0;tasksHandled&lt;submittedTasks;tasksHandled++) {
                try {
                    System.out.println("trying to take from Completion service");
                    Future&lt;CalcResult&gt; result = taskCompletionService.take();
                    System.out.println("result for a task availble in queue.Trying to get()");
                    // above call blocks till atleast one task is completed and results availble for it
                    // but we dont have to worry which one

                    // process the result here by doing result.get()
                    CalcResult l = result.get();
                    System.out.println("Task " + String.valueOf(tasksHandled) + "Completed - results obtained : " + String.valueOf(l.result));

                } catch (InterruptedException e) {
                    // Something went wrong with a task submitted
                    System.out.println("Error Interrupted exception");
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    // Something went wrong with the result
                    e.printStackTrace();
                    System.out.println("Error get() threw exception");
                }
            }
        }
    }
******************************
Normalized:
******************************
Original:
public class CompletionServiceTest {

        class CalcResult {
             long result ;

             CalcResult(long l) {
                 result = l;
             }
        }

        class CallableTask implements Callable&lt;CalcResult&gt; {
            String taskName ;
            long  input1 ;
            int input2 ;

            CallableTask(String name , long v1 , int v2 ) {
                taskName = name;
                input1 = v1;
                input2 = v2 ;
            }

            public CalcResult call() throws Exception {
                System.out.println(" Task " + taskName + " Started -----");
                for(int i=0;i&lt;input2 ;i++) {
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        System.out.println(" Task " + taskName + " Interrupted !! ");
                        e.printStackTrace();
                    }
                    input1 += i;
                }
                System.out.println(" Task " + taskName + " Completed @@@@@@");
                return new CalcResult(input1) ;
            }

        }

        public void test(){
            ExecutorService taskExecutor = Executors.newFixedThreadPool(3);
            CompletionService&lt;CalcResult&gt; taskCompletionService = new ExecutorCompletionService&lt;CalcResult&gt;(taskExecutor);

            int submittedTasks = 5;
            for (int i=0;i&lt; submittedTasks;i++) {
                taskCompletionService.submit(new CallableTask (
                        String.valueOf(i), 
                            (i * 10), 
                            ((i * 10) + 10  )
                        ));
               System.out.println("Task " + String.valueOf(i) + "subitted");
            }
            for (int tasksHandled=0;tasksHandled&lt;submittedTasks;tasksHandled++) {
                try {
                    System.out.println("trying to take from Completion service");
                    Future&lt;CalcResult&gt; result = taskCompletionService.take();
                    System.out.println("result for a task availble in queue.Trying to get()");
                    // above call blocks till atleast one task is completed and results availble for it
                    // but we dont have to worry which one

                    // process the result here by doing result.get()
                    CalcResult l = result.get();
                    System.out.println("Task " + String.valueOf(tasksHandled) + "Completed - results obtained : " + String.valueOf(l.result));

                } catch (InterruptedException e) {
                    // Something went wrong with a task submitted
                    System.out.println("Error Interrupted exception");
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    // Something went wrong with the result
                    e.printStackTrace();
                    System.out.println("Error get() threw exception");
                }
            }
        }
    }
******************************
Normalized:
public class CompletionServiceTest {

        class CalcResult {
             long result ;

             CalcResult(long l) {
                 result = l;
             }
        }

        class CallableTask implements Callable&lt;CalcResult&gt; {
            String taskName ;
            long  input1 ;
            int input2 ;

            CallableTask(String name , long v1 , int v2 ) {
                taskName = name;
                input1 = v1;
                input2 = v2 ;
            }

            public CalcResult call() throws Exception {
                System.out.println(" Task " + taskName + " Started -----");
                for(int i=0;i&lt;input2 ;i++) {
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        System.out.println(" Task " + taskName + " Interrupted !! ");
                        e.printStackTrace();
                    }
                    input1 += i;
                }
                System.out.println(" Task " + taskName + " Completed @@@@@@");
                return new CalcResult(input1) ;
            }

        }

        public void test(){
            ExecutorService taskExecutor = Executors.newFixedThreadPool(3);
            CompletionService&lt;CalcResult&gt; taskCompletionService = new ExecutorCompletionService&lt;CalcResult&gt;(taskExecutor);

            int submittedTasks = 5;
            for (int i=0;i&lt; submittedTasks;i++) {
                taskCompletionService.submit(new CallableTask (
                        String.valueOf(i), 
                            (i * 10), 
                            ((i * 10) + 10  )
                        ));
               System.out.println("Task " + String.valueOf(i) + "subitted");
            }
            for (int tasksHandled=0;tasksHandled&lt;submittedTasks;tasksHandled++) {
                try {
                    System.out.println("trying to take from Completion service");
                    Future&lt;CalcResult&gt; result = taskCompletionService.take();
                    System.out.println("result for a task availble in queue.Trying to get()");
                    // above call blocks till atleast one task is completed and results availble for it
                    // but we dont have to worry which one

                    // process the result here by doing result.get()
                    CalcResult l = result.get();
                    System.out.println("Task " + String.valueOf(tasksHandled) + "Completed - results obtained : " + String.valueOf(l.result));

                } catch (InterruptedException e) {
                    // Something went wrong with a task submitted
                    System.out.println("Error Interrupted exception");
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    // Something went wrong with the result
                    e.printStackTrace();
                    System.out.println("Error get() threw exception");
                }
            }
        }
    }
******************************
Original:
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/*")
public class MyApplication extends Application {
    ...
}
******************************
Normalized:
******************************
Original:
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/*")
public class MyApplication extends Application {
    ...
}
******************************
Normalized:
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/*")
public class MyApplication extends Application {
    ...
}
******************************
Original:
List&lt;Integer&gt; idList = students.stream().map(Student::getId).collect(Collectors.toList());
******************************
Normalized:
******************************
Original:
List&lt;Integer&gt; idList = students.stream().map(Student::getId).collect(Collectors.toList());
******************************
Normalized:
List&lt;Integer&gt; idList = students.stream().map(Student::getId).collect(Collectors.toList());
******************************
Original:
Collectors.toMap(p -&gt; p.getLast(), Function.identity())
******************************
Normalized:
******************************
Original:
Collectors.toMap(p -&gt; p.getLast(), Function.identity())
******************************
Normalized:
Collectors.toMap(p -&gt; p.getLast(), Function.identity())
******************************
Original:
for(int k = 0; k &lt; strings.length; k++){
   // something
}
******************************
Normalized:
******************************
Original:
for(int k = 0; k &lt; strings.length; k++){
   // something
}
******************************
Normalized:
for(int k = 0; k &lt; strings.length; k++){
   // something
}
******************************
Original:
public void writeToParcel(Parcel out, int flags) {
    out.writeString(_mac);
    out.writeString(_pan);
    out.writeInt(_band);
    out.writeSerializable(_lqis);
    out.writeTypedList(_devices);
}

private ZigBeeNetwork(Parcel in) {
    _mac = in.readString();
    _pan = in.readString();
    _band = in.readInt();
    _lqis = (ArrayList&lt;Integer&gt;) in.readSerializable();
    in.readTypedList(_devices, ZigBeeDev.CREATOR);
}
******************************
Normalized:
******************************
Original:
public void writeToParcel(Parcel out, int flags) {
    out.writeString(_mac);
    out.writeString(_pan);
    out.writeInt(_band);
    out.writeSerializable(_lqis);
    out.writeTypedList(_devices);
}

private ZigBeeNetwork(Parcel in) {
    _mac = in.readString();
    _pan = in.readString();
    _band = in.readInt();
    _lqis = (ArrayList&lt;Integer&gt;) in.readSerializable();
    in.readTypedList(_devices, ZigBeeDev.CREATOR);
}
******************************
Normalized:
public void writeToParcel(Parcel out, int flags) {
    out.writeString(_mac);
    out.writeString(_pan);
    out.writeInt(_band);
    out.writeSerializable(_lqis);
    out.writeTypedList(_devices);
}

private ZigBeeNetwork(Parcel in) {
    _mac = in.readString();
    _pan = in.readString();
    _band = in.readInt();
    _lqis = (ArrayList&lt;Integer&gt;) in.readSerializable();
    in.readTypedList(_devices, ZigBeeDev.CREATOR);
}
******************************
Original:
@Test(expected=IncorrectArgumentForSetter.class)
public void testSetterForeignWord("") throws Exception {
  card.setForeignWord("");
}
******************************
Normalized:
******************************
Original:
@Test(expected=IncorrectArgumentForSetter.class)
public void testSetterForeignWord("") throws Exception {
  card.setForeignWord("");
}
******************************
Normalized:
@Test(expected=IncorrectArgumentForSetter.class)
public void testSetterForeignWord("") throws Exception {
  card.setForeignWord("");
}
******************************
Original:
jboss-as-7
 |
 |---&gt; standalone
 |      |----&gt; lib
 |      |----&gt; configuration
 |      |----&gt; deployments
 |      
 |---&gt; domain
 |....
******************************
Normalized:
******************************
Original:
jboss-as-7
 |
 |---&gt; standalone
 |      |----&gt; lib
 |      |----&gt; configuration
 |      |----&gt; deployments
 |      
 |---&gt; domain
 |....
******************************
Normalized:
jboss-as-7
 |
 |---&gt; standalone
 |      |----&gt; lib
 |      |----&gt; configuration
 |      |----&gt; deployments
 |      
 |---&gt; domain
 |....
******************************
Original:
@ 16   org.sample.IntStr::inlineSideEffect (25 bytes)   force inline by CompilerOracle
   @ 4   java.lang.StringBuilder::&lt;init&gt; (7 bytes)   inline (hot)
   @ 18   java.lang.StringBuilder::append (8 bytes)   already compiled into a big method
   @ 21   java.lang.StringBuilder::toString (17 bytes)   inline (hot)
******************************
Normalized:
******************************
Original:
@ 16   org.sample.IntStr::inlineSideEffect (25 bytes)   force inline by CompilerOracle
   @ 4   java.lang.StringBuilder::&lt;init&gt; (7 bytes)   inline (hot)
   @ 18   java.lang.StringBuilder::append (8 bytes)   already compiled into a big method
   @ 21   java.lang.StringBuilder::toString (17 bytes)   inline (hot)
******************************
Normalized:
@ 16   org.sample.IntStr::inlineSideEffect (25 bytes)   force inline by CompilerOracle
   @ 4   java.lang.StringBuilder::&lt;init&gt; (7 bytes)   inline (hot)
   @ 18   java.lang.StringBuilder::append (8 bytes)   already compiled into a big method
   @ 21   java.lang.StringBuilder::toString (17 bytes)   inline (hot)
******************************
Original:
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
}
******************************
Normalized:
******************************
Original:
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
}
******************************
Normalized:
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
}
******************************
Original:
@Controller
@RequestMapping(value = "/adminservice")
@Secured("ROLE_ADMIN")
public class AdminServiceController {
******************************
Normalized:
******************************
Original:
@Controller
@RequestMapping(value = "/adminservice")
@Secured("ROLE_ADMIN")
public class AdminServiceController {
******************************
Normalized:
@Controller
@RequestMapping(value = "/adminservice")
@Secured("ROLE_ADMIN")
public class AdminServiceController {
******************************
Original:
public void add(int index, E element)
******************************
Normalized:
******************************
Original:
public void add(int index, E element)
******************************
Normalized:
public void add(int index, E element)
******************************
Original:
dataList = dataList.subList(30, 38 &gt; dataList.size() ? dataList.size() : 38);
******************************
Normalized:
******************************
Original:
dataList = dataList.subList(30, 38 &gt; dataList.size() ? dataList.size() : 38);
******************************
Normalized:
dataList = dataList.subList(30, 38 &gt; dataList.size() ? dataList.size() : 38);
******************************
Original:
String item;

for(int x = 0; x &lt; 10; x++)
{
    // Linear search.
    if(array[x].equals("Item I am looking for"))
    {
       //you've found the item. Let's stop.
       item = array[x];
       break; 
    }
}
******************************
Normalized:
******************************
Original:
String item;

for(int x = 0; x &lt; 10; x++)
{
    // Linear search.
    if(array[x].equals("Item I am looking for"))
    {
       //you've found the item. Let's stop.
       item = array[x];
       break; 
    }
}
******************************
Normalized:
String item;

for(int x = 0; x &lt; 10; x++)
{
    // Linear search.
    if(array[x].equals("Item I am looking for"))
    {
       //you've found the item. Let's stop.
       item = array[x];
       break; 
    }
}
******************************
Original:
public void scheduleAtFixedRate(TimerTask task,
                                long delay,
                                long period)
******************************
Normalized:
******************************
Original:
public void scheduleAtFixedRate(TimerTask task,
                                long delay,
                                long period)
******************************
Normalized:
public void scheduleAtFixedRate(TimerTask task,
                                long delay,
                                long period)
******************************
Original:
@GeneratedValue(strategy = GenerationType.IDENTITY)
******************************
Normalized:
******************************
Original:
@GeneratedValue(strategy = GenerationType.IDENTITY)
******************************
Normalized:
@GeneratedValue(strategy = GenerationType.IDENTITY)
******************************
Original:
ZonedDateTime now = ZonedDateTime.now(ZoneId.of("America/Los_Angeles"));
ZonedDateTime nextRun = now.withHour(5).withMinute(0).withSecond(0);
if(now.compareTo(nextRun) &gt; 0)
    nextRun = nextRun.plusDays(1);

Duration duration = Duration.between(now, nextRun);
long initalDelay = duration.getSeconds();

ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);            
scheduler.scheduleAtFixedRate(new MyRunnableTask(),
    initalDelay,
    TimeUnit.DAYS.toSeconds(1),
    TimeUnit.SECONDS);
******************************
Normalized:
******************************
Original:
ZonedDateTime now = ZonedDateTime.now(ZoneId.of("America/Los_Angeles"));
ZonedDateTime nextRun = now.withHour(5).withMinute(0).withSecond(0);
if(now.compareTo(nextRun) &gt; 0)
    nextRun = nextRun.plusDays(1);

Duration duration = Duration.between(now, nextRun);
long initalDelay = duration.getSeconds();

ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);            
scheduler.scheduleAtFixedRate(new MyRunnableTask(),
    initalDelay,
    TimeUnit.DAYS.toSeconds(1),
    TimeUnit.SECONDS);
******************************
Normalized:
ZonedDateTime now = ZonedDateTime.now(ZoneId.of("America/Los_Angeles"));
ZonedDateTime nextRun = now.withHour(5).withMinute(0).withSecond(0);
if(now.compareTo(nextRun) &gt; 0)
    nextRun = nextRun.plusDays(1);

Duration duration = Duration.between(now, nextRun);
long initalDelay = duration.getSeconds();

ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);            
scheduler.scheduleAtFixedRate(new MyRunnableTask(),
    initalDelay,
    TimeUnit.DAYS.toSeconds(1),
    TimeUnit.SECONDS);
******************************
Original:
\p{L}+
******************************
Normalized:
******************************
Original:
\p{L}+
******************************
Normalized:
\p{L}+
******************************
Original:
Class&lt;?&gt; beanClass = beanDefinition.getClass();
Object bean = beanClass.newInstance();
if (bean instanceof ApplicationContextAware) {
    ((ApplicationContextAware) bean).setApplicationContext(ctx);
}
******************************
Normalized:
******************************
Original:
Class&lt;?&gt; beanClass = beanDefinition.getClass();
Object bean = beanClass.newInstance();
if (bean instanceof ApplicationContextAware) {
    ((ApplicationContextAware) bean).setApplicationContext(ctx);
}
******************************
Normalized:
Class&lt;?&gt; beanClass = beanDefinition.getClass();
Object bean = beanClass.newInstance();
if (bean instanceof ApplicationContextAware) {
    ((ApplicationContextAware) bean).setApplicationContext(ctx);
}
******************************
Original:
Observable
   .from(modifications)
   .flatmap( (data1) -&gt; { 
       return op1(data1)
           ...
           .flatmap( (data2) -&gt; { 
               // I can access data1 here
               return op2(data2);
           })
   });
******************************
Normalized:
******************************
Original:
Observable
   .from(modifications)
   .flatmap( (data1) -&gt; { 
       return op1(data1)
           ...
           .flatmap( (data2) -&gt; { 
               // I can access data1 here
               return op2(data2);
           })
   });
******************************
Normalized:
Observable
   .from(modifications)
   .flatmap( (data1) -&gt; { 
       return op1(data1)
           ...
           .flatmap( (data2) -&gt; { 
               // I can access data1 here
               return op2(data2);
           })
   });
******************************
Original:
class A implements ICallback {
     MyObject o;
     B b = new B(this, someParameter);

     @Override
     public void callback(MyObject o){
           this.o = o;
     }
}

class B {
     ICallback ic;
     B(ICallback ic, someParameter){
         this.ic = ic;
     }

    new Thread(new Runnable(){
         public void run(){
             // some calculation
             ic.callback(myObject)
         }
    }).start(); 
}

interface ICallback{
    public void callback(MyObject o);
}
******************************
Normalized:
******************************
Original:
class A implements ICallback {
     MyObject o;
     B b = new B(this, someParameter);

     @Override
     public void callback(MyObject o){
           this.o = o;
     }
}

class B {
     ICallback ic;
     B(ICallback ic, someParameter){
         this.ic = ic;
     }

    new Thread(new Runnable(){
         public void run(){
             // some calculation
             ic.callback(myObject)
         }
    }).start(); 
}

interface ICallback{
    public void callback(MyObject o);
}
******************************
Normalized:
class A implements ICallback {
     MyObject o;
     B b = new B(this, someParameter);

     @Override
     public void callback(MyObject o){
           this.o = o;
     }
}

class B {
     ICallback ic;
     B(ICallback ic, someParameter){
         this.ic = ic;
     }

    new Thread(new Runnable(){
         public void run(){
             // some calculation
             ic.callback(myObject)
         }
    }).start(); 
}

interface ICallback{
    public void callback(MyObject o);
}
******************************
Original:
&lt;import resource="classpath:spring-config.xml" /&gt;
******************************
Normalized:
******************************
Original:
&lt;import resource="classpath:spring-config.xml" /&gt;
******************************
Normalized:
&lt;import resource="classpath:spring-config.xml" /&gt;
******************************
Original:
Optional&lt;&gt; opt = dao.find();

opt.ifPresentOrElse(obj -&gt; obj.setAvailable(true),
                    () -&gt; logger.error("…"));
******************************
Normalized:
******************************
Original:
Optional&lt;&gt; opt = dao.find();

opt.ifPresentOrElse(obj -&gt; obj.setAvailable(true),
                    () -&gt; logger.error("…"));
******************************
Normalized:
Optional&lt;&gt; opt = dao.find();

opt.ifPresentOrElse(obj -&gt; obj.setAvailable(true),
                    () -&gt; logger.error("…"));
******************************
Original:
PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:*.java");

Path filename = ...;
if (matcher.matches(filename)) {
    System.out.println(filename);
}
******************************
Normalized:
******************************
Original:
PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:*.java");

Path filename = ...;
if (matcher.matches(filename)) {
    System.out.println(filename);
}
******************************
Normalized:
PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:*.java");

Path filename = ...;
if (matcher.matches(filename)) {
    System.out.println(filename);
}
******************************
Original:
final class Either&lt;L,R&gt;
{
    public static &lt;L,R&gt; Either&lt;L,R&gt; left(L value) {
        return new Either&lt;&gt;(Optional.of(value), Optional.empty());
    }
    public static &lt;L,R&gt; Either&lt;L,R&gt; right(R value) {
        return new Either&lt;&gt;(Optional.empty(), Optional.of(value));
    }
    private final Optional&lt;L&gt; left;
    private final Optional&lt;R&gt; right;
    private Either(Optional&lt;L&gt; l, Optional&lt;R&gt; r) {
      left=l;
      right=r;
    }
    public &lt;T&gt; T map(
        Function&lt;? super L, ? extends T&gt; lFunc,
        Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return left.&lt;T&gt;map(lFunc).orElseGet(()-&gt;right.map(rFunc).get());
    }
    public &lt;T&gt; Either&lt;T,R&gt; mapLeft(Function&lt;? super L, ? extends T&gt; lFunc)
    {
        return new Either&lt;&gt;(left.map(lFunc),right);
    }
    public &lt;T&gt; Either&lt;L,T&gt; mapRight(Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return new Either&lt;&gt;(left, right.map(rFunc));
    }
    public void apply(Consumer&lt;? super L&gt; lFunc, Consumer&lt;? super R&gt; rFunc)
    {
        left.ifPresent(lFunc);
        right.ifPresent(rFunc);
    }
}
******************************
Normalized:
******************************
Original:
final class Either&lt;L,R&gt;
{
    public static &lt;L,R&gt; Either&lt;L,R&gt; left(L value) {
        return new Either&lt;&gt;(Optional.of(value), Optional.empty());
    }
    public static &lt;L,R&gt; Either&lt;L,R&gt; right(R value) {
        return new Either&lt;&gt;(Optional.empty(), Optional.of(value));
    }
    private final Optional&lt;L&gt; left;
    private final Optional&lt;R&gt; right;
    private Either(Optional&lt;L&gt; l, Optional&lt;R&gt; r) {
      left=l;
      right=r;
    }
    public &lt;T&gt; T map(
        Function&lt;? super L, ? extends T&gt; lFunc,
        Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return left.&lt;T&gt;map(lFunc).orElseGet(()-&gt;right.map(rFunc).get());
    }
    public &lt;T&gt; Either&lt;T,R&gt; mapLeft(Function&lt;? super L, ? extends T&gt; lFunc)
    {
        return new Either&lt;&gt;(left.map(lFunc),right);
    }
    public &lt;T&gt; Either&lt;L,T&gt; mapRight(Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return new Either&lt;&gt;(left, right.map(rFunc));
    }
    public void apply(Consumer&lt;? super L&gt; lFunc, Consumer&lt;? super R&gt; rFunc)
    {
        left.ifPresent(lFunc);
        right.ifPresent(rFunc);
    }
}
******************************
Normalized:
final class Either&lt;L,R&gt;
{
    public static &lt;L,R&gt; Either&lt;L,R&gt; left(L value) {
        return new Either&lt;&gt;(Optional.of(value), Optional.empty());
    }
    public static &lt;L,R&gt; Either&lt;L,R&gt; right(R value) {
        return new Either&lt;&gt;(Optional.empty(), Optional.of(value));
    }
    private final Optional&lt;L&gt; left;
    private final Optional&lt;R&gt; right;
    private Either(Optional&lt;L&gt; l, Optional&lt;R&gt; r) {
      left=l;
      right=r;
    }
    public &lt;T&gt; T map(
        Function&lt;? super L, ? extends T&gt; lFunc,
        Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return left.&lt;T&gt;map(lFunc).orElseGet(()-&gt;right.map(rFunc).get());
    }
    public &lt;T&gt; Either&lt;T,R&gt; mapLeft(Function&lt;? super L, ? extends T&gt; lFunc)
    {
        return new Either&lt;&gt;(left.map(lFunc),right);
    }
    public &lt;T&gt; Either&lt;L,T&gt; mapRight(Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return new Either&lt;&gt;(left, right.map(rFunc));
    }
    public void apply(Consumer&lt;? super L&gt; lFunc, Consumer&lt;? super R&gt; rFunc)
    {
        left.ifPresent(lFunc);
        right.ifPresent(rFunc);
    }
}
******************************
Original:
Foo[] array = ...;
List&lt;Foo&gt; list = new ArrayList&lt;Foo&gt;(Arrays.asList(array));
******************************
Normalized:
******************************
Original:
Foo[] array = ...;
List&lt;Foo&gt; list = new ArrayList&lt;Foo&gt;(Arrays.asList(array));
******************************
Normalized:
Foo[] array = ...;
List&lt;Foo&gt; list = new ArrayList&lt;Foo&gt;(Arrays.asList(array));
******************************
Original:
first:
for( int i = 0; i &lt; 10; i++) {
  second:
  for(int j = 0; j &lt; 5; j ++ )
  {
    break xxx;
  }
}

third:
for( int a = 0; a &lt; 10; a++) {

}
******************************
Normalized:
******************************
Original:
first:
for( int i = 0; i &lt; 10; i++) {
  second:
  for(int j = 0; j &lt; 5; j ++ )
  {
    break xxx;
  }
}

third:
for( int a = 0; a &lt; 10; a++) {

}
******************************
Normalized:
first:
for( int i = 0; i &lt; 10; i++) {
  second:
  for(int j = 0; j &lt; 5; j ++ )
  {
    break xxx;
  }
}

third:
for( int a = 0; a &lt; 10; a++) {

}
******************************
Original:
private final CompositeDisposable disposables = new CompositeDisposable();


// adding an Observable to the disposable
disposables.add(sampleObservable()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeWith(new DisposableObserver&lt;String&gt;() {
                    @Override
                    public void onComplete() {
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(String value) {
                    }
                }));

    static Observable&lt;String&gt; sampleObservable() {
        return Observable.defer(new Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() {
            @Override
            public ObservableSource&lt;? extends String&gt; call() throws Exception {
                // Do some long running operation
                SystemClock.sleep(2000);
                return Observable.just("one", "two", "three", "four", "five");
            }
        });
    }                


// Using clear will clear all, but can accept new disposable
disposables.clear(); 
// Using dispose will clear all and set isDisposed = true, so it will not accept any new disposable
disposables.dispose();
******************************
Normalized:
******************************
Original:
private final CompositeDisposable disposables = new CompositeDisposable();


// adding an Observable to the disposable
disposables.add(sampleObservable()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeWith(new DisposableObserver&lt;String&gt;() {
                    @Override
                    public void onComplete() {
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(String value) {
                    }
                }));

    static Observable&lt;String&gt; sampleObservable() {
        return Observable.defer(new Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() {
            @Override
            public ObservableSource&lt;? extends String&gt; call() throws Exception {
                // Do some long running operation
                SystemClock.sleep(2000);
                return Observable.just("one", "two", "three", "four", "five");
            }
        });
    }                


// Using clear will clear all, but can accept new disposable
disposables.clear(); 
// Using dispose will clear all and set isDisposed = true, so it will not accept any new disposable
disposables.dispose();
******************************
Normalized:
private final CompositeDisposable disposables = new CompositeDisposable();


// adding an Observable to the disposable
disposables.add(sampleObservable()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeWith(new DisposableObserver&lt;String&gt;() {
                    @Override
                    public void onComplete() {
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(String value) {
                    }
                }));

    static Observable&lt;String&gt; sampleObservable() {
        return Observable.defer(new Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() {
            @Override
            public ObservableSource&lt;? extends String&gt; call() throws Exception {
                // Do some long running operation
                SystemClock.sleep(2000);
                return Observable.just("one", "two", "three", "four", "five");
            }
        });
    }                


// Using clear will clear all, but can accept new disposable
disposables.clear(); 
// Using dispose will clear all and set isDisposed = true, so it will not accept any new disposable
disposables.dispose();
******************************
Original:
public void setShapeValue(int shapeValue){
  if(shapeValue &lt; 100){
    //do something here like throw exception.
  }
}
******************************
Normalized:
******************************
Original:
public void setShapeValue(int shapeValue){
  if(shapeValue &lt; 100){
    //do something here like throw exception.
  }
}
******************************
Normalized:
public void setShapeValue(int shapeValue){
  if(shapeValue &lt; 100){
    //do something here like throw exception.
  }
}
******************************
Original:
[req]
req_extensions = v3_req

[ v3_req ]
subjectAltName=IP:10.0.0.1
# or subjectAltName=DNS:www.example.com
******************************
Normalized:
******************************
Original:
[req]
req_extensions = v3_req

[ v3_req ]
subjectAltName=IP:10.0.0.1
# or subjectAltName=DNS:www.example.com
******************************
Normalized:
[req]
req_extensions = v3_req

[ v3_req ]
subjectAltName=IP:10.0.0.1
# or subjectAltName=DNS:www.example.com
******************************
Original:
List&lt;T&gt; list = Collections.list(enumeration);
******************************
Normalized:
******************************
Original:
List&lt;T&gt; list = Collections.list(enumeration);
******************************
Normalized:
List&lt;T&gt; list = Collections.list(enumeration);
******************************
Original:
public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {
    list.sort(null);
}
******************************
Normalized:
******************************
Original:
public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {
    list.sort(null);
}
******************************
Normalized:
public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {
    list.sort(null);
}
******************************
Original:
public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(
    Function&lt;? super T, ? extends K&gt; keyMapper, 
    Function&lt;? super T, ? extends U&gt; valueMapper) 
{
    return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new);
}
******************************
Normalized:
******************************
Original:
public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(
    Function&lt;? super T, ? extends K&gt; keyMapper, 
    Function&lt;? super T, ? extends U&gt; valueMapper) 
{
    return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new);
}
******************************
Normalized:
public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(
    Function&lt;? super T, ? extends K&gt; keyMapper, 
    Function&lt;? super T, ? extends U&gt; valueMapper) 
{
    return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new);
}
******************************
Original:
&lt;javac ...&gt;
    &lt;compilerarg value="-Xlint"/&gt;
  &lt;/javac&gt;
******************************
Normalized:
******************************
Original:
&lt;javac ...&gt;
    &lt;compilerarg value="-Xlint"/&gt;
  &lt;/javac&gt;
******************************
Normalized:
&lt;javac ...&gt;
    &lt;compilerarg value="-Xlint"/&gt;
  &lt;/javac&gt;
******************************
Original:
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE roles SYSTEM "roles.dtd"&gt;
&lt;roles&gt;
    &lt;role1&gt;User&lt;/role1&gt;
    &lt;role2&gt;Author&lt;/role2&gt;
    &lt;role3&gt;Admin&lt;/role3&gt;
    &lt;role4/&gt;
&lt;/roles&gt;
******************************
Normalized:
******************************
Original:
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE roles SYSTEM "roles.dtd"&gt;
&lt;roles&gt;
    &lt;role1&gt;User&lt;/role1&gt;
    &lt;role2&gt;Author&lt;/role2&gt;
    &lt;role3&gt;Admin&lt;/role3&gt;
    &lt;role4/&gt;
&lt;/roles&gt;
******************************
Normalized:
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE roles SYSTEM "roles.dtd"&gt;
&lt;roles&gt;
    &lt;role1&gt;User&lt;/role1&gt;
    &lt;role2&gt;Author&lt;/role2&gt;
    &lt;role3&gt;Admin&lt;/role3&gt;
    &lt;role4/&gt;
&lt;/roles&gt;
******************************
Original:
if (1 / x &gt; 0)
    // +0 here
else
    // -0 here
******************************
Normalized:
******************************
Original:
if (1 / x &gt; 0)
    // +0 here
else
    // -0 here
******************************
Normalized:
if (1 / x &gt; 0)
    // +0 here
else
    // -0 here
******************************
Original:
log4j.rootLogger=TRACE, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.debugLog=org.apache.log4j.FileAppender
log4j.appender.debugLog.File=logs/debug.log
log4j.appender.debugLog.layout=org.apache.log4j.PatternLayout
log4j.appender.debugLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.reportsLog=org.apache.log4j.FileAppender
log4j.appender.reportsLog.File=logs/reports.log
log4j.appender.reportsLog.layout=org.apache.log4j.PatternLayout
log4j.appender.reportsLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.category.debugLogger=TRACE, debugLog
log4j.additivity.debugLogger=false

log4j.category.reportsLogger=DEBUG, reportsLog
log4j.additivity.reportsLogger=false
******************************
Normalized:
******************************
Original:
log4j.rootLogger=TRACE, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.debugLog=org.apache.log4j.FileAppender
log4j.appender.debugLog.File=logs/debug.log
log4j.appender.debugLog.layout=org.apache.log4j.PatternLayout
log4j.appender.debugLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.reportsLog=org.apache.log4j.FileAppender
log4j.appender.reportsLog.File=logs/reports.log
log4j.appender.reportsLog.layout=org.apache.log4j.PatternLayout
log4j.appender.reportsLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.category.debugLogger=TRACE, debugLog
log4j.additivity.debugLogger=false

log4j.category.reportsLogger=DEBUG, reportsLog
log4j.additivity.reportsLogger=false
******************************
Normalized:
log4j.rootLogger=TRACE, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.debugLog=org.apache.log4j.FileAppender
log4j.appender.debugLog.File=logs/debug.log
log4j.appender.debugLog.layout=org.apache.log4j.PatternLayout
log4j.appender.debugLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.reportsLog=org.apache.log4j.FileAppender
log4j.appender.reportsLog.File=logs/reports.log
log4j.appender.reportsLog.layout=org.apache.log4j.PatternLayout
log4j.appender.reportsLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.category.debugLogger=TRACE, debugLog
log4j.additivity.debugLogger=false

log4j.category.reportsLogger=DEBUG, reportsLog
log4j.additivity.reportsLogger=false
******************************
Original:
@Override
final void forEachWithCancel(Spliterator&lt;P_OUT&gt; spliterator, Sink&lt;P_OUT&gt; sink) {
    do { } while (!sink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(sink));
}
******************************
Normalized:
******************************
Original:
@Override
final void forEachWithCancel(Spliterator&lt;P_OUT&gt; spliterator, Sink&lt;P_OUT&gt; sink) {
    do { } while (!sink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(sink));
}
******************************
Normalized:
@Override
final void forEachWithCancel(Spliterator&lt;P_OUT&gt; spliterator, Sink&lt;P_OUT&gt; sink) {
    do { } while (!sink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(sink));
}
******************************
Original:
IntPredicate neg = x -&gt; x &lt;- x;
System.out.println(neg.test(4));   // false
System.out.println(neg.test(0));   // false
System.out.println(neg.test(-4));  // true
******************************
Normalized:
******************************
Original:
IntPredicate neg = x -&gt; x &lt;- x;
System.out.println(neg.test(4));   // false
System.out.println(neg.test(0));   // false
System.out.println(neg.test(-4));  // true
******************************
Normalized:
IntPredicate neg = x -&gt; x &lt;- x;
System.out.println(neg.test(4));   // false
System.out.println(neg.test(0));   // false
System.out.println(neg.test(-4));  // true
******************************
Original:
Runnable r1=null;
    for(int i=0; i&lt;2; i++) {
        Runnable r2=System::gc;
        if(r1==null) r1=r2;
        else System.out.println(r1==r2? "shared": "unshared");
    }
******************************
Normalized:
******************************
Original:
Runnable r1=null;
    for(int i=0; i&lt;2; i++) {
        Runnable r2=System::gc;
        if(r1==null) r1=r2;
        else System.out.println(r1==r2? "shared": "unshared");
    }
******************************
Normalized:
Runnable r1=null;
    for(int i=0; i&lt;2; i++) {
        Runnable r2=System::gc;
        if(r1==null) r1=r2;
        else System.out.println(r1==r2? "shared": "unshared");
    }
******************************
Original:
char c = /* whatever */;

switch(c) {
    case 'a':
    case 'A':
        //get the 'A' image;
        break;
    case 'b':
    case 'B':
        //get the 'B' image;
        break;
    // (...)
    case 'z':
    case 'Z':
        //get the 'Z' image;
        break;
}
******************************
Normalized:
******************************
Original:
char c = /* whatever */;

switch(c) {
    case 'a':
    case 'A':
        //get the 'A' image;
        break;
    case 'b':
    case 'B':
        //get the 'B' image;
        break;
    // (...)
    case 'z':
    case 'Z':
        //get the 'Z' image;
        break;
}
******************************
Normalized:
char c = /* whatever */;

switch(c) {
    case 'a':
    case 'A':
        //get the 'A' image;
        break;
    case 'b':
    case 'B':
        //get the 'B' image;
        break;
    // (...)
    case 'z':
    case 'Z':
        //get the 'Z' image;
        break;
}
******************************
Original:
mvn -o install
******************************
Normalized:
******************************
Original:
mvn -o install
******************************
Normalized:
mvn -o install
******************************
Original:
InputStream is = entity.getContent();

.... process the input stream ....

is.close();       // releases all resources
******************************
Normalized:
******************************
Original:
InputStream is = entity.getContent();

.... process the input stream ....

is.close();       // releases all resources
******************************
Normalized:
InputStream is = entity.getContent();

.... process the input stream ....

is.close();       // releases all resources
******************************
Original:
public boolean retryingFindClick(By by) {
    boolean result = false;
    int attempts = 0;
    while(attempts &lt; 2) {
        try {
            driver.findElement(by).click();
            result = true;
            break;
        } catch(StaleElementException e) {
        }
        attempts++;
    }
    return result;
}
******************************
Normalized:
******************************
Original:
public boolean retryingFindClick(By by) {
    boolean result = false;
    int attempts = 0;
    while(attempts &lt; 2) {
        try {
            driver.findElement(by).click();
            result = true;
            break;
        } catch(StaleElementException e) {
        }
        attempts++;
    }
    return result;
}
******************************
Normalized:
public boolean retryingFindClick(By by) {
    boolean result = false;
    int attempts = 0;
    while(attempts &lt; 2) {
        try {
            driver.findElement(by).click();
            result = true;
            break;
        } catch(StaleElementException e) {
        }
        attempts++;
    }
    return result;
}
******************************
Original:
public static void main(String[] args) throws SAXException, IOException,
        ParserConfigurationException, TransformerException {

    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory
        .newInstance();
    DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
    Document document = docBuilder.parse(new File("document.xml"));
    doSomething(document.getDocumentElement());
}

public static void doSomething(Node node) {
    // do something with the current node instead of System.out
    System.out.println(node.getNodeName());

    NodeList nodeList = node.getChildNodes();
    for (int i = 0; i &lt; nodeList.getLength(); i++) {
        Node currentNode = nodeList.item(i);
        if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
            //calls this method for all the children which is Element
            doSomething(currentNode);
        }
    }
}
******************************
Normalized:
******************************
Original:
public static void main(String[] args) throws SAXException, IOException,
        ParserConfigurationException, TransformerException {

    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory
        .newInstance();
    DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
    Document document = docBuilder.parse(new File("document.xml"));
    doSomething(document.getDocumentElement());
}

public static void doSomething(Node node) {
    // do something with the current node instead of System.out
    System.out.println(node.getNodeName());

    NodeList nodeList = node.getChildNodes();
    for (int i = 0; i &lt; nodeList.getLength(); i++) {
        Node currentNode = nodeList.item(i);
        if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
            //calls this method for all the children which is Element
            doSomething(currentNode);
        }
    }
}
******************************
Normalized:
public static void main(String[] args) throws SAXException, IOException,
        ParserConfigurationException, TransformerException {

    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory
        .newInstance();
    DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
    Document document = docBuilder.parse(new File("document.xml"));
    doSomething(document.getDocumentElement());
}

public static void doSomething(Node node) {
    // do something with the current node instead of System.out
    System.out.println(node.getNodeName());

    NodeList nodeList = node.getChildNodes();
    for (int i = 0; i &lt; nodeList.getLength(); i++) {
        Node currentNode = nodeList.item(i);
        if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
            //calls this method for all the children which is Element
            doSomething(currentNode);
        }
    }
}
******************************
Original:
List&lt;V&gt; al = new ArrayList&lt;V&gt;(hashMapVar.values());
******************************
Normalized:
******************************
Original:
List&lt;V&gt; al = new ArrayList&lt;V&gt;(hashMapVar.values());
******************************
Normalized:
List&lt;V&gt; al = new ArrayList&lt;V&gt;(hashMapVar.values());
******************************
Original:
List&lt;Foo&gt; list = createItSomehow();
Random random = new Random();
Foo foo = list.get(random.nextInt(list.size()));
******************************
Normalized:
******************************
Original:
List&lt;Foo&gt; list = createItSomehow();
Random random = new Random();
Foo foo = list.get(random.nextInt(list.size()));
******************************
Normalized:
List&lt;Foo&gt; list = createItSomehow();
Random random = new Random();
Foo foo = list.get(random.nextInt(list.size()));
******************************
Original:
void callback(int val) {
    JNIEnv * g_env;
    // double check it's all ok
    int getEnvStat = g_vm-&gt;GetEnv((void **)&amp;g_env, JNI_VERSION_1_6);
    if (getEnvStat == JNI_EDETACHED) {
        std::cout &lt;&lt; "GetEnv: not attached" &lt;&lt; std::endl;
        if (g_vm-&gt;AttachCurrentThread((void **) &amp;g_env, NULL) != 0) {
            std::cout &lt;&lt; "Failed to attach" &lt;&lt; std::endl;
        }
    } else if (getEnvStat == JNI_OK) {
        //
    } else if (getEnvStat == JNI_EVERSION) {
        std::cout &lt;&lt; "GetEnv: version not supported" &lt;&lt; std::endl;
    }

    g_env-&gt;CallVoidMethod(g_obj, g_mid, val);

    if (g_env-&gt;ExceptionCheck()) {
        g_env-&gt;ExceptionDescribe();
    }

    g_vm-&gt;DetachCurrentThread();
}
******************************
Normalized:
******************************
Original:
void callback(int val) {
    JNIEnv * g_env;
    // double check it's all ok
    int getEnvStat = g_vm-&gt;GetEnv((void **)&amp;g_env, JNI_VERSION_1_6);
    if (getEnvStat == JNI_EDETACHED) {
        std::cout &lt;&lt; "GetEnv: not attached" &lt;&lt; std::endl;
        if (g_vm-&gt;AttachCurrentThread((void **) &amp;g_env, NULL) != 0) {
            std::cout &lt;&lt; "Failed to attach" &lt;&lt; std::endl;
        }
    } else if (getEnvStat == JNI_OK) {
        //
    } else if (getEnvStat == JNI_EVERSION) {
        std::cout &lt;&lt; "GetEnv: version not supported" &lt;&lt; std::endl;
    }

    g_env-&gt;CallVoidMethod(g_obj, g_mid, val);

    if (g_env-&gt;ExceptionCheck()) {
        g_env-&gt;ExceptionDescribe();
    }

    g_vm-&gt;DetachCurrentThread();
}
******************************
Normalized:
void callback(int val) {
    JNIEnv * g_env;
    // double check it's all ok
    int getEnvStat = g_vm-&gt;GetEnv((void **)&amp;g_env, JNI_VERSION_1_6);
    if (getEnvStat == JNI_EDETACHED) {
        std::cout &lt;&lt; "GetEnv: not attached" &lt;&lt; std::endl;
        if (g_vm-&gt;AttachCurrentThread((void **) &amp;g_env, NULL) != 0) {
            std::cout &lt;&lt; "Failed to attach" &lt;&lt; std::endl;
        }
    } else if (getEnvStat == JNI_OK) {
        //
    } else if (getEnvStat == JNI_EVERSION) {
        std::cout &lt;&lt; "GetEnv: version not supported" &lt;&lt; std::endl;
    }

    g_env-&gt;CallVoidMethod(g_obj, g_mid, val);

    if (g_env-&gt;ExceptionCheck()) {
        g_env-&gt;ExceptionDescribe();
    }

    g_vm-&gt;DetachCurrentThread();
}
******************************
Original:
&lt;dependency&gt;
    &lt;groupId&gt;postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;version&gt;VERSION&lt;/version&gt;
&lt;/dependency&gt;
******************************
Normalized:
******************************
Original:
&lt;dependency&gt;
    &lt;groupId&gt;postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;version&gt;VERSION&lt;/version&gt;
&lt;/dependency&gt;
******************************
Normalized:
&lt;dependency&gt;
    &lt;groupId&gt;postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;version&gt;VERSION&lt;/version&gt;
&lt;/dependency&gt;
******************************
Original:
byte[] bytes = new byte[10];
Byte[] byteObjects = new Byte[bytes.length];

int i=0;    
// Associating Byte array values with bytes. (byte[] to Byte[])
for(byte b: bytes)
   byteObjects[i++] = b;  // Autoboxing.

....

int j=0;
// Unboxing Byte values. (Byte[] to byte[])
for(Byte b: byteObjects)
    bytes[j++] = b.byteValue();
******************************
Normalized:
******************************
Original:
byte[] bytes = new byte[10];
Byte[] byteObjects = new Byte[bytes.length];

int i=0;    
// Associating Byte array values with bytes. (byte[] to Byte[])
for(byte b: bytes)
   byteObjects[i++] = b;  // Autoboxing.

....

int j=0;
// Unboxing Byte values. (Byte[] to byte[])
for(Byte b: byteObjects)
    bytes[j++] = b.byteValue();
******************************
Normalized:
byte[] bytes = new byte[10];
Byte[] byteObjects = new Byte[bytes.length];

int i=0;    
// Associating Byte array values with bytes. (byte[] to Byte[])
for(byte b: bytes)
   byteObjects[i++] = b;  // Autoboxing.

....

int j=0;
// Unboxing Byte values. (Byte[] to byte[])
for(Byte b: byteObjects)
    bytes[j++] = b.byteValue();
******************************
Original:
val arrayOfZeros = IntArray(size) //equivalent in Java: new int[size]
val numbersFromOne = IntArray(size) { it + 1 }
val myInts = intArrayOf(1, 1, 2, 3, 5, 8, 13, 21)
******************************
Normalized:
******************************
Original:
val arrayOfZeros = IntArray(size) //equivalent in Java: new int[size]
val numbersFromOne = IntArray(size) { it + 1 }
val myInts = intArrayOf(1, 1, 2, 3, 5, 8, 13, 21)
******************************
Normalized:
val arrayOfZeros = IntArray(size) //equivalent in Java: new int[size]
val numbersFromOne = IntArray(size) { it + 1 }
val myInts = intArrayOf(1, 1, 2, 3, 5, 8, 13, 21)
******************************
Original:
&lt;FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:id="@+id/root_view"&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText1"
        android:layout_height="fill_parent"&gt;
    &lt;/EditText&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText2"
        android:layout_height="fill_parent"&gt;
        &lt;requestFocus&gt;&lt;/requestFocus&gt;
    &lt;/EditText&gt;

&lt;/FrameLayout&gt;
******************************
Normalized:
******************************
Original:
&lt;FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:id="@+id/root_view"&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText1"
        android:layout_height="fill_parent"&gt;
    &lt;/EditText&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText2"
        android:layout_height="fill_parent"&gt;
        &lt;requestFocus&gt;&lt;/requestFocus&gt;
    &lt;/EditText&gt;

&lt;/FrameLayout&gt;
******************************
Normalized:
&lt;FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:id="@+id/root_view"&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText1"
        android:layout_height="fill_parent"&gt;
    &lt;/EditText&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText2"
        android:layout_height="fill_parent"&gt;
        &lt;requestFocus&gt;&lt;/requestFocus&gt;
    &lt;/EditText&gt;

&lt;/FrameLayout&gt;
******************************
Original:
public boolean AndSC(int x, int value, int y) {
    return value &gt;= x &amp;&amp; value &lt;= y;
}

public boolean AndNonSC(int x, int value, int y) {
    return value &gt;= x &amp; value &lt;= y;
}
******************************
Normalized:
******************************
Original:
public boolean AndSC(int x, int value, int y) {
    return value &gt;= x &amp;&amp; value &lt;= y;
}

public boolean AndNonSC(int x, int value, int y) {
    return value &gt;= x &amp; value &lt;= y;
}
******************************
Normalized:
public boolean AndSC(int x, int value, int y) {
    return value &gt;= x &amp;&amp; value &lt;= y;
}

public boolean AndNonSC(int x, int value, int y) {
    return value &gt;= x &amp; value &lt;= y;
}
******************************
Original:
&lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt;
******************************
Normalized:
******************************
Original:
&lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt;
******************************
Normalized:
&lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt;
******************************
Original:
sudo apt-get install openjdk-11-jdk
******************************
Normalized:
******************************
Original:
sudo apt-get install openjdk-11-jdk
******************************
Normalized:
sudo apt-get install openjdk-11-jdk
******************************
Original:
@Configuration
@EnableScheduling
public class SpringConfiguration {

    @Bean(destroyMethod = "shutdown")
    public Executor taskScheduler() {
        return Executors.newScheduledThreadPool(5);
    }
    ...
******************************
Normalized:
******************************
Original:
@Configuration
@EnableScheduling
public class SpringConfiguration {

    @Bean(destroyMethod = "shutdown")
    public Executor taskScheduler() {
        return Executors.newScheduledThreadPool(5);
    }
    ...
******************************
Normalized:
@Configuration
@EnableScheduling
public class SpringConfiguration {

    @Bean(destroyMethod = "shutdown")
    public Executor taskScheduler() {
        return Executors.newScheduledThreadPool(5);
    }
    ...
******************************
Original:
@Autowired
private Item&lt;String&gt; strItem; // Injects the stringItem bean

@Autowired
private Item&lt;Integer&gt; intItem; // Injects the integerItem bean
******************************
Normalized:
******************************
Original:
@Autowired
private Item&lt;String&gt; strItem; // Injects the stringItem bean

@Autowired
private Item&lt;Integer&gt; intItem; // Injects the integerItem bean
******************************
Normalized:
@Autowired
private Item&lt;String&gt; strItem; // Injects the stringItem bean

@Autowired
private Item&lt;Integer&gt; intItem; // Injects the integerItem bean
******************************
Original:
Project
| src
| | main
|   | java
|     | [your source code]
|   | resources
|     | META-INF
|       | services
|         | [your service files]
******************************
Normalized:
******************************
Original:
Project
| src
| | main
|   | java
|     | [your source code]
|   | resources
|     | META-INF
|       | services
|         | [your service files]
******************************
Normalized:
Project
| src
| | main
|   | java
|     | [your source code]
|   | resources
|     | META-INF
|       | services
|         | [your service files]
******************************
Original:
import org.springframework.batch.item.ItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("foo-reader")
@Scope("step")
public final class MyReader implements ItemReader&lt;MyData&gt; {
  @Override
  public MyData read() throws Exception {
    //...
  }

  @Value("#{jobParameters['fileName']}")
  public void setFileName(final String name) {
    //...
  }
}
******************************
Normalized:
******************************
Original:
import org.springframework.batch.item.ItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("foo-reader")
@Scope("step")
public final class MyReader implements ItemReader&lt;MyData&gt; {
  @Override
  public MyData read() throws Exception {
    //...
  }

  @Value("#{jobParameters['fileName']}")
  public void setFileName(final String name) {
    //...
  }
}
******************************
Normalized:
import org.springframework.batch.item.ItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("foo-reader")
@Scope("step")
public final class MyReader implements ItemReader&lt;MyData&gt; {
  @Override
  public MyData read() throws Exception {
    //...
  }

  @Value("#{jobParameters['fileName']}")
  public void setFileName(final String name) {
    //...
  }
}
******************************
Original:
Object[] array;
for(Object o : array) { }
Iterable&lt;Object&gt; list;
for(Object o : list) { }
Iterator&lt;Object&gt; iter;
while(iter.hasNext()) { Object o = iter.next(); }
******************************
Normalized:
******************************
Original:
Object[] array;
for(Object o : array) { }
Iterable&lt;Object&gt; list;
for(Object o : list) { }
Iterator&lt;Object&gt; iter;
while(iter.hasNext()) { Object o = iter.next(); }
******************************
Normalized:
Object[] array;
for(Object o : array) { }
Iterable&lt;Object&gt; list;
for(Object o : list) { }
Iterator&lt;Object&gt; iter;
while(iter.hasNext()) { Object o = iter.next(); }
******************************
Original:
import java.text.Normalizer;

public static String stripAccents(String s) 
{
    s = Normalizer.normalize(s, Normalizer.Form.NFD);
    s = s.replaceAll("[\\p{InCombiningDiacriticalMarks}]", "");
    return s;
}
******************************
Normalized:
******************************
Original:
import java.text.Normalizer;

public static String stripAccents(String s) 
{
    s = Normalizer.normalize(s, Normalizer.Form.NFD);
    s = s.replaceAll("[\\p{InCombiningDiacriticalMarks}]", "");
    return s;
}
******************************
Normalized:
import java.text.Normalizer;

public static String stripAccents(String s) 
{
    s = Normalizer.normalize(s, Normalizer.Form.NFD);
    s = s.replaceAll("[\\p{InCombiningDiacriticalMarks}]", "");
    return s;
}
******************************
Original:
public class CustomJsonDateDeserializer extends JsonDeserializer&lt;Date&gt;
{
    @Override
    public Date deserialize(JsonParser jsonParser,
            DeserializationContext deserializationContext) throws IOException, JsonProcessingException {

        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
        String date = jsonParser.getText();
        try {
            return format.parse(date);
        } catch (ParseException e) {
            throw new RuntimeException(e);
        }

    }

}
******************************
Normalized:
******************************
Original:
public class CustomJsonDateDeserializer extends JsonDeserializer&lt;Date&gt;
{
    @Override
    public Date deserialize(JsonParser jsonParser,
            DeserializationContext deserializationContext) throws IOException, JsonProcessingException {

        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
        String date = jsonParser.getText();
        try {
            return format.parse(date);
        } catch (ParseException e) {
            throw new RuntimeException(e);
        }

    }

}
******************************
Normalized:
public class CustomJsonDateDeserializer extends JsonDeserializer&lt;Date&gt;
{
    @Override
    public Date deserialize(JsonParser jsonParser,
            DeserializationContext deserializationContext) throws IOException, JsonProcessingException {

        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
        String date = jsonParser.getText();
        try {
            return format.parse(date);
        } catch (ParseException e) {
            throw new RuntimeException(e);
        }

    }

}
******************************
Original:
00 00 00 00 =&gt; (byte) 0
00 00 00 01 =&gt; (byte) 1
00 00 00 10 =&gt; (byte) 2
...
01 11 11 11 =&gt; (byte) Byte.MAX_VALUE
******************************
Normalized:
******************************
Original:
00 00 00 00 =&gt; (byte) 0
00 00 00 01 =&gt; (byte) 1
00 00 00 10 =&gt; (byte) 2
...
01 11 11 11 =&gt; (byte) Byte.MAX_VALUE
******************************
Normalized:
00 00 00 00 =&gt; (byte) 0
00 00 00 01 =&gt; (byte) 1
00 00 00 10 =&gt; (byte) 2
...
01 11 11 11 =&gt; (byte) Byte.MAX_VALUE
******************************
Original:
!StringUtils.isAlphanumeric(String)
******************************
Normalized:
******************************
Original:
!StringUtils.isAlphanumeric(String)
******************************
Normalized:
!StringUtils.isAlphanumeric(String)
******************************
Original:
#
# Build stage
#
FROM maven:3.6.0-jdk-11-slim AS build
COPY src /home/app/src
COPY pom.xml /home/app
RUN mvn -f /home/app/pom.xml clean package

#
# Package stage
#
FROM openjdk:11-jre-slim
COPY --from=build /home/app/target/demo-0.0.1-SNAPSHOT.jar /usr/local/lib/demo.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","/usr/local/lib/demo.jar"]
******************************
Normalized:
******************************
Original:
#
# Build stage
#
FROM maven:3.6.0-jdk-11-slim AS build
COPY src /home/app/src
COPY pom.xml /home/app
RUN mvn -f /home/app/pom.xml clean package

#
# Package stage
#
FROM openjdk:11-jre-slim
COPY --from=build /home/app/target/demo-0.0.1-SNAPSHOT.jar /usr/local/lib/demo.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","/usr/local/lib/demo.jar"]
******************************
Normalized:
#
# Build stage
#
FROM maven:3.6.0-jdk-11-slim AS build
COPY src /home/app/src
COPY pom.xml /home/app
RUN mvn -f /home/app/pom.xml clean package

#
# Package stage
#
FROM openjdk:11-jre-slim
COPY --from=build /home/app/target/demo-0.0.1-SNAPSHOT.jar /usr/local/lib/demo.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","/usr/local/lib/demo.jar"]
******************************
Original:
set.removeIf(item -&gt; {
    if (!item.qualify())
        return false;
    item.operate();
    return true;
});
******************************
Normalized:
******************************
Original:
set.removeIf(item -&gt; {
    if (!item.qualify())
        return false;
    item.operate();
    return true;
});
******************************
Normalized:
set.removeIf(item -&gt; {
    if (!item.qualify())
        return false;
    item.operate();
    return true;
});
******************************
Original:
List&lt;String&gt; numbers = Arrays.asList("zero", "one", "two");
ListIterator&lt;String&gt; it = numbers.listIterator();
while (it.hasNext()) {
    System.out.println(it.nextIndex() + " " + it.next());
}
******************************
Normalized:
******************************
Original:
List&lt;String&gt; numbers = Arrays.asList("zero", "one", "two");
ListIterator&lt;String&gt; it = numbers.listIterator();
while (it.hasNext()) {
    System.out.println(it.nextIndex() + " " + it.next());
}
******************************
Normalized:
List&lt;String&gt; numbers = Arrays.asList("zero", "one", "two");
ListIterator&lt;String&gt; it = numbers.listIterator();
while (it.hasNext()) {
    System.out.println(it.nextIndex() + " " + it.next());
}
******************************
Original:
public class MyAdapter extends Adapter {
     private Context context;

     public MyAdapter(Context context) {
          this.context = context;     
     }

     public View getView(...){
         View v;
         v.setOnClickListener(new OnClickListener() {
             void onClick() {
                 context.startActivity(...);
             }
         });
     }
}
******************************
Normalized:
******************************
Original:
public class MyAdapter extends Adapter {
     private Context context;

     public MyAdapter(Context context) {
          this.context = context;     
     }

     public View getView(...){
         View v;
         v.setOnClickListener(new OnClickListener() {
             void onClick() {
                 context.startActivity(...);
             }
         });
     }
}
******************************
Normalized:
public class MyAdapter extends Adapter {
     private Context context;

     public MyAdapter(Context context) {
          this.context = context;     
     }

     public View getView(...){
         View v;
         v.setOnClickListener(new OnClickListener() {
             void onClick() {
                 context.startActivity(...);
             }
         });
     }
}
******************************
Original:
sudo apt-get install openjdk-11-jdk
******************************
Normalized:
******************************
Original:
sudo apt-get install openjdk-11-jdk
******************************
Normalized:
sudo apt-get install openjdk-11-jdk
******************************
Original:
double[] target = new double[doubles.size()];
 for (int i = 0; i &lt; target.length; i++) {
    target[i] = doubles.get(i).doubleValue();  // java 1.4 style
    // or:
    target[i] = doubles.get(i);                // java 1.5+ style (outboxing)
 }
******************************
Normalized:
******************************
Original:
double[] target = new double[doubles.size()];
 for (int i = 0; i &lt; target.length; i++) {
    target[i] = doubles.get(i).doubleValue();  // java 1.4 style
    // or:
    target[i] = doubles.get(i);                // java 1.5+ style (outboxing)
 }
******************************
Normalized:
double[] target = new double[doubles.size()];
 for (int i = 0; i &lt; target.length; i++) {
    target[i] = doubles.get(i).doubleValue();  // java 1.4 style
    // or:
    target[i] = doubles.get(i);                // java 1.5+ style (outboxing)
 }
******************************
Original:
List&lt;Email&gt; findByEmailIdInAndPincodeIn(List&lt;String&gt; emails, List&lt;String&gt; pinCodes);
******************************
Normalized:
******************************
Original:
List&lt;Email&gt; findByEmailIdInAndPincodeIn(List&lt;String&gt; emails, List&lt;String&gt; pinCodes);
******************************
Normalized:
List&lt;Email&gt; findByEmailIdInAndPincodeIn(List&lt;String&gt; emails, List&lt;String&gt; pinCodes);
******************************
Original:
.andExpect(jsonPath("$.password").doesNotExist())
******************************
Normalized:
******************************
Original:
.andExpect(jsonPath("$.password").doesNotExist())
******************************
Normalized:
.andExpect(jsonPath("$.password").doesNotExist())
******************************
Original:
class SomethingSyncd {
    @Synchronized fun syncFoo() {

    }

    val myLock = Any()

    fun foo() {
        synchronized(myLock) {
            // ... code
        }
    }

    @Volatile var thing = mapOf(...)
}
******************************
Normalized:
******************************
Original:
class SomethingSyncd {
    @Synchronized fun syncFoo() {

    }

    val myLock = Any()

    fun foo() {
        synchronized(myLock) {
            // ... code
        }
    }

    @Volatile var thing = mapOf(...)
}
******************************
Normalized:
class SomethingSyncd {
    @Synchronized fun syncFoo() {

    }

    val myLock = Any()

    fun foo() {
        synchronized(myLock) {
            // ... code
        }
    }

    @Volatile var thing = mapOf(...)
}
******************************
Original:
private fun &lt;T&gt; anyObject(): T {
    Mockito.anyObject&lt;T&gt;()
    return uninitialized()
}

private fun &lt;T&gt; uninitialized(): T = null as T

@Test
fun myTest() {
    `when`(mockedBackend).login(anyObject())).thenAnswer { ... }
}
******************************
Normalized:
******************************
Original:
private fun &lt;T&gt; anyObject(): T {
    Mockito.anyObject&lt;T&gt;()
    return uninitialized()
}

private fun &lt;T&gt; uninitialized(): T = null as T

@Test
fun myTest() {
    `when`(mockedBackend).login(anyObject())).thenAnswer { ... }
}
******************************
Normalized:
private fun &lt;T&gt; anyObject(): T {
    Mockito.anyObject&lt;T&gt;()
    return uninitialized()
}

private fun &lt;T&gt; uninitialized(): T = null as T

@Test
fun myTest() {
    `when`(mockedBackend).login(anyObject())).thenAnswer { ... }
}
******************************
Original:
public final class SupplierUtils {
    private SupplierUtils() {
    }

    public static &lt;T&gt; Supplier&lt;T&gt; wrap(Callable&lt;T&gt; callable) {
        return () -&gt; {
            try {
                return callable.call();
            }
            catch (RuntimeException e) {
                throw e;
            }
            catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
}

public class JdbcConnectionPool extends ObjectPool&lt;Connection&gt; {

    public JdbcConnectionPool(int maxConnections, String url) {
        super(SupplierUtils.wrap(() -&gt; DriverManager.getConnection(url)), maxConnections);
    }
}
******************************
Normalized:
******************************
Original:
public final class SupplierUtils {
    private SupplierUtils() {
    }

    public static &lt;T&gt; Supplier&lt;T&gt; wrap(Callable&lt;T&gt; callable) {
        return () -&gt; {
            try {
                return callable.call();
            }
            catch (RuntimeException e) {
                throw e;
            }
            catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
}

public class JdbcConnectionPool extends ObjectPool&lt;Connection&gt; {

    public JdbcConnectionPool(int maxConnections, String url) {
        super(SupplierUtils.wrap(() -&gt; DriverManager.getConnection(url)), maxConnections);
    }
}
******************************
Normalized:
public final class SupplierUtils {
    private SupplierUtils() {
    }

    public static &lt;T&gt; Supplier&lt;T&gt; wrap(Callable&lt;T&gt; callable) {
        return () -&gt; {
            try {
                return callable.call();
            }
            catch (RuntimeException e) {
                throw e;
            }
            catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
}

public class JdbcConnectionPool extends ObjectPool&lt;Connection&gt; {

    public JdbcConnectionPool(int maxConnections, String url) {
        super(SupplierUtils.wrap(() -&gt; DriverManager.getConnection(url)), maxConnections);
    }
}
******************************
Original:
/**
 * This resolver handles command objects annotated with @SupportsAnnotationParameterResolution
 * that are passed as parameters to controller methods.
 * 
 * It parses @CommandPerameter annotations on command objects to
 * populate the Binder with the appropriate values (that is, the filed names
 * corresponding to the GET parameters)
 * 
 * In order to achieve this, small pieces of code are copied from spring-mvc
 * classes (indicated in-place). The alternative to the copied lines would be to
 * have a decorator around the Binder, but that would be more tedious, and still
 * some methods would need to be copied.
 * 
 * @author bozho
 * 
 */
public class AnnotationServletModelAttributeResolver extends ServletModelAttributeMethodProcessor {

    /**
     * A map caching annotation definitions of command objects (@CommandParameter-to-fieldname mappings)
     */
    private ConcurrentMap&lt;Class&lt;?&gt;, Map&lt;String, String&gt;&gt; definitionsCache = Maps.newConcurrentMap();

    public AnnotationServletModelAttributeResolver(boolean annotationNotRequired) {
        super(annotationNotRequired);
    }

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        if (parameter.getParameterType().isAnnotationPresent(SupportsAnnotationParameterResolution.class)) {
            return true;
        }
        return false;
    }

    @Override
    protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
        ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);
        ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
        bind(servletRequest, servletBinder);
    }

    @SuppressWarnings("unchecked")
    public void bind(ServletRequest request, ServletRequestDataBinder binder) {
        Map&lt;String, ?&gt; propertyValues = parsePropertyValues(request, binder);
        MutablePropertyValues mpvs = new MutablePropertyValues(propertyValues);
        MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);
        if (multipartRequest != null) {
            bindMultipart(multipartRequest.getMultiFileMap(), mpvs);
        }

        // two lines copied from ExtendedServletRequestDataBinder
        String attr = HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;
        mpvs.addPropertyValues((Map&lt;String, String&gt;) request.getAttribute(attr));
        binder.bind(mpvs);
    }

    private Map&lt;String, ?&gt; parsePropertyValues(ServletRequest request, ServletRequestDataBinder binder) {

        // similar to WebUtils.getParametersStartingWith(..) (prefixes not supported)
        Map&lt;String, Object&gt; params = Maps.newTreeMap();
        Assert.notNull(request, "Request must not be null");
        Enumeration&lt;?&gt; paramNames = request.getParameterNames();
        Map&lt;String, String&gt; parameterMappings = getParameterMappings(binder);
        while (paramNames != null &amp;&amp; paramNames.hasMoreElements()) {
            String paramName = (String) paramNames.nextElement();
            String[] values = request.getParameterValues(paramName);

            String fieldName = parameterMappings.get(paramName);
            // no annotation exists, use the default - the param name=field name
            if (fieldName == null) {
                fieldName = paramName;
            }

            if (values == null || values.length == 0) {
                // Do nothing, no values found at all.
            } else if (values.length &gt; 1) {
                params.put(fieldName, values);
            } else {
                params.put(fieldName, values[0]);
            }
        }

        return params;
    }

    /**
     * Gets a mapping between request parameter names and field names.
     * If no annotation is specified, no entry is added
     * @return
     */
    private Map&lt;String, String&gt; getParameterMappings(ServletRequestDataBinder binder) {
        Class&lt;?&gt; targetClass = binder.getTarget().getClass();
        Map&lt;String, String&gt; map = definitionsCache.get(targetClass);
        if (map == null) {
            Field[] fields = targetClass.getDeclaredFields();
            map = Maps.newHashMapWithExpectedSize(fields.length);
            for (Field field : fields) {
                CommandParameter annotation = field.getAnnotation(CommandParameter.class);
                if (annotation != null &amp;&amp; !annotation.value().isEmpty()) {
                    map.put(annotation.value(), field.getName());
                }
            }
            definitionsCache.putIfAbsent(targetClass, map);
            return map;
        } else {
            return map;
        }
    }

    /**
     * Copied from WebDataBinder.
     * 
     * @param multipartFiles
     * @param mpvs
     */
    protected void bindMultipart(Map&lt;String, List&lt;MultipartFile&gt;&gt; multipartFiles, MutablePropertyValues mpvs) {
        for (Map.Entry&lt;String, List&lt;MultipartFile&gt;&gt; entry : multipartFiles.entrySet()) {
            String key = entry.getKey();
            List&lt;MultipartFile&gt; values = entry.getValue();
            if (values.size() == 1) {
                MultipartFile value = values.get(0);
                if (!value.isEmpty()) {
                    mpvs.add(key, value);
                }
            } else {
                mpvs.add(key, values);
            }
        }
    }
}
******************************
Normalized:
******************************
Original:
/**
 * This resolver handles command objects annotated with @SupportsAnnotationParameterResolution
 * that are passed as parameters to controller methods.
 * 
 * It parses @CommandPerameter annotations on command objects to
 * populate the Binder with the appropriate values (that is, the filed names
 * corresponding to the GET parameters)
 * 
 * In order to achieve this, small pieces of code are copied from spring-mvc
 * classes (indicated in-place). The alternative to the copied lines would be to
 * have a decorator around the Binder, but that would be more tedious, and still
 * some methods would need to be copied.
 * 
 * @author bozho
 * 
 */
public class AnnotationServletModelAttributeResolver extends ServletModelAttributeMethodProcessor {

    /**
     * A map caching annotation definitions of command objects (@CommandParameter-to-fieldname mappings)
     */
    private ConcurrentMap&lt;Class&lt;?&gt;, Map&lt;String, String&gt;&gt; definitionsCache = Maps.newConcurrentMap();

    public AnnotationServletModelAttributeResolver(boolean annotationNotRequired) {
        super(annotationNotRequired);
    }

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        if (parameter.getParameterType().isAnnotationPresent(SupportsAnnotationParameterResolution.class)) {
            return true;
        }
        return false;
    }

    @Override
    protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
        ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);
        ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
        bind(servletRequest, servletBinder);
    }

    @SuppressWarnings("unchecked")
    public void bind(ServletRequest request, ServletRequestDataBinder binder) {
        Map&lt;String, ?&gt; propertyValues = parsePropertyValues(request, binder);
        MutablePropertyValues mpvs = new MutablePropertyValues(propertyValues);
        MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);
        if (multipartRequest != null) {
            bindMultipart(multipartRequest.getMultiFileMap(), mpvs);
        }

        // two lines copied from ExtendedServletRequestDataBinder
        String attr = HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;
        mpvs.addPropertyValues((Map&lt;String, String&gt;) request.getAttribute(attr));
        binder.bind(mpvs);
    }

    private Map&lt;String, ?&gt; parsePropertyValues(ServletRequest request, ServletRequestDataBinder binder) {

        // similar to WebUtils.getParametersStartingWith(..) (prefixes not supported)
        Map&lt;String, Object&gt; params = Maps.newTreeMap();
        Assert.notNull(request, "Request must not be null");
        Enumeration&lt;?&gt; paramNames = request.getParameterNames();
        Map&lt;String, String&gt; parameterMappings = getParameterMappings(binder);
        while (paramNames != null &amp;&amp; paramNames.hasMoreElements()) {
            String paramName = (String) paramNames.nextElement();
            String[] values = request.getParameterValues(paramName);

            String fieldName = parameterMappings.get(paramName);
            // no annotation exists, use the default - the param name=field name
            if (fieldName == null) {
                fieldName = paramName;
            }

            if (values == null || values.length == 0) {
                // Do nothing, no values found at all.
            } else if (values.length &gt; 1) {
                params.put(fieldName, values);
            } else {
                params.put(fieldName, values[0]);
            }
        }

        return params;
    }

    /**
     * Gets a mapping between request parameter names and field names.
     * If no annotation is specified, no entry is added
     * @return
     */
    private Map&lt;String, String&gt; getParameterMappings(ServletRequestDataBinder binder) {
        Class&lt;?&gt; targetClass = binder.getTarget().getClass();
        Map&lt;String, String&gt; map = definitionsCache.get(targetClass);
        if (map == null) {
            Field[] fields = targetClass.getDeclaredFields();
            map = Maps.newHashMapWithExpectedSize(fields.length);
            for (Field field : fields) {
                CommandParameter annotation = field.getAnnotation(CommandParameter.class);
                if (annotation != null &amp;&amp; !annotation.value().isEmpty()) {
                    map.put(annotation.value(), field.getName());
                }
            }
            definitionsCache.putIfAbsent(targetClass, map);
            return map;
        } else {
            return map;
        }
    }

    /**
     * Copied from WebDataBinder.
     * 
     * @param multipartFiles
     * @param mpvs
     */
    protected void bindMultipart(Map&lt;String, List&lt;MultipartFile&gt;&gt; multipartFiles, MutablePropertyValues mpvs) {
        for (Map.Entry&lt;String, List&lt;MultipartFile&gt;&gt; entry : multipartFiles.entrySet()) {
            String key = entry.getKey();
            List&lt;MultipartFile&gt; values = entry.getValue();
            if (values.size() == 1) {
                MultipartFile value = values.get(0);
                if (!value.isEmpty()) {
                    mpvs.add(key, value);
                }
            } else {
                mpvs.add(key, values);
            }
        }
    }
}
******************************
Normalized:
/**
 * This resolver handles command objects annotated with @SupportsAnnotationParameterResolution
 * that are passed as parameters to controller methods.
 * 
 * It parses @CommandPerameter annotations on command objects to
 * populate the Binder with the appropriate values (that is, the filed names
 * corresponding to the GET parameters)
 * 
 * In order to achieve this, small pieces of code are copied from spring-mvc
 * classes (indicated in-place). The alternative to the copied lines would be to
 * have a decorator around the Binder, but that would be more tedious, and still
 * some methods would need to be copied.
 * 
 * @author bozho
 * 
 */
public class AnnotationServletModelAttributeResolver extends ServletModelAttributeMethodProcessor {

    /**
     * A map caching annotation definitions of command objects (@CommandParameter-to-fieldname mappings)
     */
    private ConcurrentMap&lt;Class&lt;?&gt;, Map&lt;String, String&gt;&gt; definitionsCache = Maps.newConcurrentMap();

    public AnnotationServletModelAttributeResolver(boolean annotationNotRequired) {
        super(annotationNotRequired);
    }

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        if (parameter.getParameterType().isAnnotationPresent(SupportsAnnotationParameterResolution.class)) {
            return true;
        }
        return false;
    }

    @Override
    protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
        ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);
        ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
        bind(servletRequest, servletBinder);
    }

    @SuppressWarnings("unchecked")
    public void bind(ServletRequest request, ServletRequestDataBinder binder) {
        Map&lt;String, ?&gt; propertyValues = parsePropertyValues(request, binder);
        MutablePropertyValues mpvs = new MutablePropertyValues(propertyValues);
        MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);
        if (multipartRequest != null) {
            bindMultipart(multipartRequest.getMultiFileMap(), mpvs);
        }

        // two lines copied from ExtendedServletRequestDataBinder
        String attr = HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;
        mpvs.addPropertyValues((Map&lt;String, String&gt;) request.getAttribute(attr));
        binder.bind(mpvs);
    }

    private Map&lt;String, ?&gt; parsePropertyValues(ServletRequest request, ServletRequestDataBinder binder) {

        // similar to WebUtils.getParametersStartingWith(..) (prefixes not supported)
        Map&lt;String, Object&gt; params = Maps.newTreeMap();
        Assert.notNull(request, "Request must not be null");
        Enumeration&lt;?&gt; paramNames = request.getParameterNames();
        Map&lt;String, String&gt; parameterMappings = getParameterMappings(binder);
        while (paramNames != null &amp;&amp; paramNames.hasMoreElements()) {
            String paramName = (String) paramNames.nextElement();
            String[] values = request.getParameterValues(paramName);

            String fieldName = parameterMappings.get(paramName);
            // no annotation exists, use the default - the param name=field name
            if (fieldName == null) {
                fieldName = paramName;
            }

            if (values == null || values.length == 0) {
                // Do nothing, no values found at all.
            } else if (values.length &gt; 1) {
                params.put(fieldName, values);
            } else {
                params.put(fieldName, values[0]);
            }
        }

        return params;
    }

    /**
     * Gets a mapping between request parameter names and field names.
     * If no annotation is specified, no entry is added
     * @return
     */
    private Map&lt;String, String&gt; getParameterMappings(ServletRequestDataBinder binder) {
        Class&lt;?&gt; targetClass = binder.getTarget().getClass();
        Map&lt;String, String&gt; map = definitionsCache.get(targetClass);
        if (map == null) {
            Field[] fields = targetClass.getDeclaredFields();
            map = Maps.newHashMapWithExpectedSize(fields.length);
            for (Field field : fields) {
                CommandParameter annotation = field.getAnnotation(CommandParameter.class);
                if (annotation != null &amp;&amp; !annotation.value().isEmpty()) {
                    map.put(annotation.value(), field.getName());
                }
            }
            definitionsCache.putIfAbsent(targetClass, map);
            return map;
        } else {
            return map;
        }
    }

    /**
     * Copied from WebDataBinder.
     * 
     * @param multipartFiles
     * @param mpvs
     */
    protected void bindMultipart(Map&lt;String, List&lt;MultipartFile&gt;&gt; multipartFiles, MutablePropertyValues mpvs) {
        for (Map.Entry&lt;String, List&lt;MultipartFile&gt;&gt; entry : multipartFiles.entrySet()) {
            String key = entry.getKey();
            List&lt;MultipartFile&gt; values = entry.getValue();
            if (values.size() == 1) {
                MultipartFile value = values.get(0);
                if (!value.isEmpty()) {
                    mpvs.add(key, value);
                }
            } else {
                mpvs.add(key, values);
            }
        }
    }
}
******************************
Original:
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:id="@+id/mainLayout"
  android:descendantFocusability="beforeDescendants"
  android:focusableInTouchMode="true" &gt;

    &lt;EditText
        android:id="@+id/password"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@+id/changePass"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="167dp"
        android:ems="10"
        android:imeOptions="flagNoExtractUi"
        android:inputType="textPassword"
        android:maxLength="30" &gt;
    &lt;/EditText&gt;

&lt;/RelativeLayout&gt;
******************************
Normalized:
******************************
Original:
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:id="@+id/mainLayout"
  android:descendantFocusability="beforeDescendants"
  android:focusableInTouchMode="true" &gt;

    &lt;EditText
        android:id="@+id/password"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@+id/changePass"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="167dp"
        android:ems="10"
        android:imeOptions="flagNoExtractUi"
        android:inputType="textPassword"
        android:maxLength="30" &gt;
    &lt;/EditText&gt;

&lt;/RelativeLayout&gt;
******************************
Normalized:
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:id="@+id/mainLayout"
  android:descendantFocusability="beforeDescendants"
  android:focusableInTouchMode="true" &gt;

    &lt;EditText
        android:id="@+id/password"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@+id/changePass"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="167dp"
        android:ems="10"
        android:imeOptions="flagNoExtractUi"
        android:inputType="textPassword"
        android:maxLength="30" &gt;
    &lt;/EditText&gt;

&lt;/RelativeLayout&gt;
******************************
Original:
[Desktop Entry]                                                                 
Encoding=UTF-8
Name=IntelliJ IDEA
Comment=IntelliJ IDEA
Exec=/opt/ideaIC-14.1.2/bin/idea.sh
Icon=/opt/ideaIC-14.1.2/bin/idea.png
Terminal=false
StartupNotify=true
Type=Application
******************************
Normalized:
******************************
Original:
[Desktop Entry]                                                                 
Encoding=UTF-8
Name=IntelliJ IDEA
Comment=IntelliJ IDEA
Exec=/opt/ideaIC-14.1.2/bin/idea.sh
Icon=/opt/ideaIC-14.1.2/bin/idea.png
Terminal=false
StartupNotify=true
Type=Application
******************************
Normalized:
[Desktop Entry]                                                                 
Encoding=UTF-8
Name=IntelliJ IDEA
Comment=IntelliJ IDEA
Exec=/opt/ideaIC-14.1.2/bin/idea.sh
Icon=/opt/ideaIC-14.1.2/bin/idea.png
Terminal=false
StartupNotify=true
Type=Application
******************************
Original:
Throwable getRootCause(Throwable throwable)
******************************
Normalized:
******************************
Original:
Throwable getRootCause(Throwable throwable)
******************************
Normalized:
Throwable getRootCause(Throwable throwable)
******************************
Original:
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.1&lt;/version&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;download-sources&lt;/id&gt;
        &lt;goals&gt;
          &lt;goal&gt;sources&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
  &lt;/plugin&gt;
******************************
Normalized:
******************************
Original:
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.1&lt;/version&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;download-sources&lt;/id&gt;
        &lt;goals&gt;
          &lt;goal&gt;sources&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
  &lt;/plugin&gt;
******************************
Normalized:
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.1&lt;/version&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;download-sources&lt;/id&gt;
        &lt;goals&gt;
          &lt;goal&gt;sources&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
  &lt;/plugin&gt;
******************************
Original:
&lt;li&gt;&lt;a href="#{request.contextPath}/index.xhtml"&gt;Home&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#{request.contextPath}/about_us.xhtml"&gt;About us&lt;/a&gt;&lt;/li&gt;
******************************
Normalized:
******************************
Original:
&lt;li&gt;&lt;a href="#{request.contextPath}/index.xhtml"&gt;Home&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#{request.contextPath}/about_us.xhtml"&gt;About us&lt;/a&gt;&lt;/li&gt;
******************************
Normalized:
&lt;li&gt;&lt;a href="#{request.contextPath}/index.xhtml"&gt;Home&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#{request.contextPath}/about_us.xhtml"&gt;About us&lt;/a&gt;&lt;/li&gt;
******************************
Original:
&lt;servlet&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        &lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;
            org.package.YouConfigurationAnnotatedClass
        &lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
******************************
Normalized:
******************************
Original:
&lt;servlet&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        &lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;
            org.package.YouConfigurationAnnotatedClass
        &lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
******************************
Normalized:
&lt;servlet&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        &lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;
            org.package.YouConfigurationAnnotatedClass
        &lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
******************************
Original:
&lt;target name="compile1"&gt; 
  &lt;mkdir dir="./build/reports"/&gt; 
  &lt;jrc 
    srcdir="./reports"
    destdir="./build/reports"
    tempdir="./build/reports"
    keepjava="true"
    xmlvalidation="true"&gt;
   &lt;classpath refid="runClasspath"/&gt;
   &lt;include name="**/*.jrxml"/&gt;
  &lt;/jrc&gt;
&lt;/target&gt;
******************************
Normalized:
******************************
Original:
&lt;target name="compile1"&gt; 
  &lt;mkdir dir="./build/reports"/&gt; 
  &lt;jrc 
    srcdir="./reports"
    destdir="./build/reports"
    tempdir="./build/reports"
    keepjava="true"
    xmlvalidation="true"&gt;
   &lt;classpath refid="runClasspath"/&gt;
   &lt;include name="**/*.jrxml"/&gt;
  &lt;/jrc&gt;
&lt;/target&gt;
******************************
Normalized:
&lt;target name="compile1"&gt; 
  &lt;mkdir dir="./build/reports"/&gt; 
  &lt;jrc 
    srcdir="./reports"
    destdir="./build/reports"
    tempdir="./build/reports"
    keepjava="true"
    xmlvalidation="true"&gt;
   &lt;classpath refid="runClasspath"/&gt;
   &lt;include name="**/*.jrxml"/&gt;
  &lt;/jrc&gt;
&lt;/target&gt;
******************************
Original:
List&lt;List&lt;String&gt;&gt; first = list1.stream().map(Arrays::asList).collect(toList());
List&lt;List&lt;String&gt;&gt; second = list2.stream().map(Arrays::asList).collect(toList());
return first.equals(second);
******************************
Normalized:
******************************
Original:
List&lt;List&lt;String&gt;&gt; first = list1.stream().map(Arrays::asList).collect(toList());
List&lt;List&lt;String&gt;&gt; second = list2.stream().map(Arrays::asList).collect(toList());
return first.equals(second);
******************************
Normalized:
List&lt;List&lt;String&gt;&gt; first = list1.stream().map(Arrays::asList).collect(toList());
List&lt;List&lt;String&gt;&gt; second = list2.stream().map(Arrays::asList).collect(toList());
return first.equals(second);
******************************
Original:
&lt;c:if test="${content.contentType.name ne 'MCE'}"&gt;
    &lt;%-- snip --%&gt;
&lt;/c:if&gt;
******************************
Normalized:
******************************
Original:
&lt;c:if test="${content.contentType.name ne 'MCE'}"&gt;
    &lt;%-- snip --%&gt;
&lt;/c:if&gt;
******************************
Normalized:
&lt;c:if test="${content.contentType.name ne 'MCE'}"&gt;
    &lt;%-- snip --%&gt;
&lt;/c:if&gt;
******************************
Original:
Your keystore contains 1 entry

myalias, Feb 15, 2012, PrivateKeyEntry, 
Certificate fingerprint (MD5): xxxxxxxx
******************************
Normalized:
******************************
Original:
Your keystore contains 1 entry

myalias, Feb 15, 2012, PrivateKeyEntry, 
Certificate fingerprint (MD5): xxxxxxxx
******************************
Normalized:
Your keystore contains 1 entry

myalias, Feb 15, 2012, PrivateKeyEntry, 
Certificate fingerprint (MD5): xxxxxxxx
******************************
Original:
GOTO --&gt;JAVA--Compiler---&gt; and change compiler level to `1.5` instead of `1.6`
******************************
Normalized:
******************************
Original:
GOTO --&gt;JAVA--Compiler---&gt; and change compiler level to `1.5` instead of `1.6`
******************************
Normalized:
GOTO --&gt;JAVA--Compiler---&gt; and change compiler level to `1.5` instead of `1.6`
******************************
Original:
try{
    int i = Integer.parseInt(input);
} catch(NumberFormatException ex){ // handle your exception
    ...
}
******************************
Normalized:
******************************
Original:
try{
    int i = Integer.parseInt(input);
} catch(NumberFormatException ex){ // handle your exception
    ...
}
******************************
Normalized:
try{
    int i = Integer.parseInt(input);
} catch(NumberFormatException ex){ // handle your exception
    ...
}
******************************
Original:
0x021dd753: test   %eax,0x180100      ;   {poll}
  0x021dd759: cmp    $0x0,%ecx
  0x021dd75c: je     0x021dd748         ;*ifeq
                                        ; - Test$1::run@7 (line 13)
  0x021dd75e: cmp    $0x0,%edx
  0x021dd761: jne    0x021dd788         ;*ifne
                                        ; - Test$1::run@13 (line 17)
  0x021dd767: nop    
  0x021dd768: jmp    0x021dd7b8         ;   {no_reloc}
  0x021dd76d: xchg   %ax,%ax
  0x021dd770: jmp    0x021dd7d2         ; implicit exception: dispatches to 0x021dd7c2
  0x021dd775: nop                       ;*getstatic out
                                        ; - Test$1::run@16 (line 18)
  0x021dd776: cmp    (%ecx),%eax        ; implicit exception: dispatches to 0x021dd7dc
  0x021dd778: mov    $0x39239500,%edx   ;*invokevirtual println
******************************
Normalized:
******************************
Original:
0x021dd753: test   %eax,0x180100      ;   {poll}
  0x021dd759: cmp    $0x0,%ecx
  0x021dd75c: je     0x021dd748         ;*ifeq
                                        ; - Test$1::run@7 (line 13)
  0x021dd75e: cmp    $0x0,%edx
  0x021dd761: jne    0x021dd788         ;*ifne
                                        ; - Test$1::run@13 (line 17)
  0x021dd767: nop    
  0x021dd768: jmp    0x021dd7b8         ;   {no_reloc}
  0x021dd76d: xchg   %ax,%ax
  0x021dd770: jmp    0x021dd7d2         ; implicit exception: dispatches to 0x021dd7c2
  0x021dd775: nop                       ;*getstatic out
                                        ; - Test$1::run@16 (line 18)
  0x021dd776: cmp    (%ecx),%eax        ; implicit exception: dispatches to 0x021dd7dc
  0x021dd778: mov    $0x39239500,%edx   ;*invokevirtual println
******************************
Normalized:
0x021dd753: test   %eax,0x180100      ;   {poll}
  0x021dd759: cmp    $0x0,%ecx
  0x021dd75c: je     0x021dd748         ;*ifeq
                                        ; - Test$1::run@7 (line 13)
  0x021dd75e: cmp    $0x0,%edx
  0x021dd761: jne    0x021dd788         ;*ifne
                                        ; - Test$1::run@13 (line 17)
  0x021dd767: nop    
  0x021dd768: jmp    0x021dd7b8         ;   {no_reloc}
  0x021dd76d: xchg   %ax,%ax
  0x021dd770: jmp    0x021dd7d2         ; implicit exception: dispatches to 0x021dd7c2
  0x021dd775: nop                       ;*getstatic out
                                        ; - Test$1::run@16 (line 18)
  0x021dd776: cmp    (%ecx),%eax        ; implicit exception: dispatches to 0x021dd7dc
  0x021dd778: mov    $0x39239500,%edx   ;*invokevirtual println
******************************
Original:
final Path path = FileSystems.getDefault().getPath(System.getProperty("user.home"), "Desktop");
System.out.println(path);
try (final WatchService watchService = FileSystems.getDefault().newWatchService()) {
    final WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);
    while (true) {
        final WatchKey wk = watchService.take();
        for (WatchEvent&lt;?&gt; event : wk.pollEvents()) {
            //we only register "ENTRY_MODIFY" so the context is always a Path.
            final Path changed = (Path) event.context();
            System.out.println(changed);
            if (changed.endsWith("myFile.txt")) {
                System.out.println("My file has changed");
            }
        }
        // reset the key
        boolean valid = wk.reset();
        if (!valid) {
            System.out.println("Key has been unregisterede");
        }
    }
}
******************************
Normalized:
******************************
Original:
final Path path = FileSystems.getDefault().getPath(System.getProperty("user.home"), "Desktop");
System.out.println(path);
try (final WatchService watchService = FileSystems.getDefault().newWatchService()) {
    final WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);
    while (true) {
        final WatchKey wk = watchService.take();
        for (WatchEvent&lt;?&gt; event : wk.pollEvents()) {
            //we only register "ENTRY_MODIFY" so the context is always a Path.
            final Path changed = (Path) event.context();
            System.out.println(changed);
            if (changed.endsWith("myFile.txt")) {
                System.out.println("My file has changed");
            }
        }
        // reset the key
        boolean valid = wk.reset();
        if (!valid) {
            System.out.println("Key has been unregisterede");
        }
    }
}
******************************
Normalized:
final Path path = FileSystems.getDefault().getPath(System.getProperty("user.home"), "Desktop");
System.out.println(path);
try (final WatchService watchService = FileSystems.getDefault().newWatchService()) {
    final WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);
    while (true) {
        final WatchKey wk = watchService.take();
        for (WatchEvent&lt;?&gt; event : wk.pollEvents()) {
            //we only register "ENTRY_MODIFY" so the context is always a Path.
            final Path changed = (Path) event.context();
            System.out.println(changed);
            if (changed.endsWith("myFile.txt")) {
                System.out.println("My file has changed");
            }
        }
        // reset the key
        boolean valid = wk.reset();
        if (!valid) {
            System.out.println("Key has been unregisterede");
        }
    }
}
******************************
Original:
Map&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();

// Add Items to the TreeMap
map.put(1, "One");
map.put(2, "Two");
map.put(3, "Three");

// Iterate over them
for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {
    System.out.println(entry.getKey() + " =&gt; " + entry.getValue());
}
******************************
Normalized:
******************************
Original:
Map&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();

// Add Items to the TreeMap
map.put(1, "One");
map.put(2, "Two");
map.put(3, "Three");

// Iterate over them
for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {
    System.out.println(entry.getKey() + " =&gt; " + entry.getValue());
}
******************************
Normalized:
Map&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();

// Add Items to the TreeMap
map.put(1, "One");
map.put(2, "Two");
map.put(3, "Three");

// Iterate over them
for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {
    System.out.println(entry.getKey() + " =&gt; " + entry.getValue());
}
******************************
Original:
EnumSet largeSize
******************************
Normalized:
******************************
Original:
EnumSet largeSize
******************************
Normalized:
EnumSet largeSize
******************************
Original:
@OneToMany
@JoinColumn(name="TXTHEAD_CODE")
private Set&lt;Text&gt; text;
******************************
Normalized:
******************************
Original:
@OneToMany
@JoinColumn(name="TXTHEAD_CODE")
private Set&lt;Text&gt; text;
******************************
Normalized:
@OneToMany
@JoinColumn(name="TXTHEAD_CODE")
private Set&lt;Text&gt; text;
******************************
Original:
&lt;mvc:resources mapping="/static/**" location="/static/" /&gt;
******************************
Normalized:
******************************
Original:
&lt;mvc:resources mapping="/static/**" location="/static/" /&gt;
******************************
Normalized:
&lt;mvc:resources mapping="/static/**" location="/static/" /&gt;
******************************
Original:
IntStream.iterate(0, i -&gt; i + 2);
******************************
Normalized:
******************************
Original:
IntStream.iterate(0, i -&gt; i + 2);
******************************
Normalized:
IntStream.iterate(0, i -&gt; i + 2);
******************************
Original:
gcc -I/usr/lib/jvm/jdk1.7.0_07/include
******************************
Normalized:
******************************
Original:
gcc -I/usr/lib/jvm/jdk1.7.0_07/include
******************************
Normalized:
gcc -I/usr/lib/jvm/jdk1.7.0_07/include
******************************
Original:
// parent entity has simple primary key

@Entity
public class Employee {
   @Id long empId;
   String name;
   ...
} 

// dependent entity uses EmbeddedId for composite key

@Embeddable
public class DependentId {
   String name;
   long empid;   // corresponds to primary key type of Employee
}

@Entity
public class Dependent {
   @EmbeddedId DependentId id;
    ...
   @MapsId("empid")  //  maps the empid attribute of embedded id
   @ManyToOne Employee emp;
}
******************************
Normalized:
******************************
Original:
// parent entity has simple primary key

@Entity
public class Employee {
   @Id long empId;
   String name;
   ...
} 

// dependent entity uses EmbeddedId for composite key

@Embeddable
public class DependentId {
   String name;
   long empid;   // corresponds to primary key type of Employee
}

@Entity
public class Dependent {
   @EmbeddedId DependentId id;
    ...
   @MapsId("empid")  //  maps the empid attribute of embedded id
   @ManyToOne Employee emp;
}
******************************
Normalized:
// parent entity has simple primary key

@Entity
public class Employee {
   @Id long empId;
   String name;
   ...
} 

// dependent entity uses EmbeddedId for composite key

@Embeddable
public class DependentId {
   String name;
   long empid;   // corresponds to primary key type of Employee
}

@Entity
public class Dependent {
   @EmbeddedId DependentId id;
    ...
   @MapsId("empid")  //  maps the empid attribute of embedded id
   @ManyToOne Employee emp;
}
******************************
Original:
//Import all needed packages
package general;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipUtils {

    private List &lt;String&gt; fileList;
    private static final String OUTPUT_ZIP_FILE = "Folder.zip";
    private static final String SOURCE_FOLDER = "D:\\Reports"; // SourceFolder path

    public ZipUtils() {
        fileList = new ArrayList &lt; String &gt; ();
    }

    public static void main(String[] args) {
        ZipUtils appZip = new ZipUtils();
        appZip.generateFileList(new File(SOURCE_FOLDER));
        appZip.zipIt(OUTPUT_ZIP_FILE);
    }

    public void zipIt(String zipFile) {
        byte[] buffer = new byte[1024];
        String source = new File(SOURCE_FOLDER).getName();
        FileOutputStream fos = null;
        ZipOutputStream zos = null;
        try {
            fos = new FileOutputStream(zipFile);
            zos = new ZipOutputStream(fos);

            System.out.println("Output to Zip : " + zipFile);
            FileInputStream in = null;

            for (String file: this.fileList) {
                System.out.println("File Added : " + file);
                ZipEntry ze = new ZipEntry(source + File.separator + file);
                zos.putNextEntry(ze);
                try {
                    in = new FileInputStream(SOURCE_FOLDER + File.separator + file);
                    int len;
                    while ((len = in .read(buffer)) &gt; 0) {
                        zos.write(buffer, 0, len);
                    }
                } finally {
                    in.close();
                }
            }

            zos.closeEntry();
            System.out.println("Folder successfully compressed");

        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            try {
                zos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public void generateFileList(File node) {
        // add file only
        if (node.isFile()) {
            fileList.add(generateZipEntry(node.toString()));
        }

        if (node.isDirectory()) {
            String[] subNote = node.list();
            for (String filename: subNote) {
                generateFileList(new File(node, filename));
            }
        }
    }

    private String generateZipEntry(String file) {
        return file.substring(SOURCE_FOLDER.length() + 1, file.length());
    }
}
******************************
Normalized:
******************************
Original:
//Import all needed packages
package general;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipUtils {

    private List &lt;String&gt; fileList;
    private static final String OUTPUT_ZIP_FILE = "Folder.zip";
    private static final String SOURCE_FOLDER = "D:\\Reports"; // SourceFolder path

    public ZipUtils() {
        fileList = new ArrayList &lt; String &gt; ();
    }

    public static void main(String[] args) {
        ZipUtils appZip = new ZipUtils();
        appZip.generateFileList(new File(SOURCE_FOLDER));
        appZip.zipIt(OUTPUT_ZIP_FILE);
    }

    public void zipIt(String zipFile) {
        byte[] buffer = new byte[1024];
        String source = new File(SOURCE_FOLDER).getName();
        FileOutputStream fos = null;
        ZipOutputStream zos = null;
        try {
            fos = new FileOutputStream(zipFile);
            zos = new ZipOutputStream(fos);

            System.out.println("Output to Zip : " + zipFile);
            FileInputStream in = null;

            for (String file: this.fileList) {
                System.out.println("File Added : " + file);
                ZipEntry ze = new ZipEntry(source + File.separator + file);
                zos.putNextEntry(ze);
                try {
                    in = new FileInputStream(SOURCE_FOLDER + File.separator + file);
                    int len;
                    while ((len = in .read(buffer)) &gt; 0) {
                        zos.write(buffer, 0, len);
                    }
                } finally {
                    in.close();
                }
            }

            zos.closeEntry();
            System.out.println("Folder successfully compressed");

        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            try {
                zos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public void generateFileList(File node) {
        // add file only
        if (node.isFile()) {
            fileList.add(generateZipEntry(node.toString()));
        }

        if (node.isDirectory()) {
            String[] subNote = node.list();
            for (String filename: subNote) {
                generateFileList(new File(node, filename));
            }
        }
    }

    private String generateZipEntry(String file) {
        return file.substring(SOURCE_FOLDER.length() + 1, file.length());
    }
}
******************************
Normalized:
//Import all needed packages
package general;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipUtils {

    private List &lt;String&gt; fileList;
    private static final String OUTPUT_ZIP_FILE = "Folder.zip";
    private static final String SOURCE_FOLDER = "D:\\Reports"; // SourceFolder path

    public ZipUtils() {
        fileList = new ArrayList &lt; String &gt; ();
    }

    public static void main(String[] args) {
        ZipUtils appZip = new ZipUtils();
        appZip.generateFileList(new File(SOURCE_FOLDER));
        appZip.zipIt(OUTPUT_ZIP_FILE);
    }

    public void zipIt(String zipFile) {
        byte[] buffer = new byte[1024];
        String source = new File(SOURCE_FOLDER).getName();
        FileOutputStream fos = null;
        ZipOutputStream zos = null;
        try {
            fos = new FileOutputStream(zipFile);
            zos = new ZipOutputStream(fos);

            System.out.println("Output to Zip : " + zipFile);
            FileInputStream in = null;

            for (String file: this.fileList) {
                System.out.println("File Added : " + file);
                ZipEntry ze = new ZipEntry(source + File.separator + file);
                zos.putNextEntry(ze);
                try {
                    in = new FileInputStream(SOURCE_FOLDER + File.separator + file);
                    int len;
                    while ((len = in .read(buffer)) &gt; 0) {
                        zos.write(buffer, 0, len);
                    }
                } finally {
                    in.close();
                }
            }

            zos.closeEntry();
            System.out.println("Folder successfully compressed");

        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            try {
                zos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public void generateFileList(File node) {
        // add file only
        if (node.isFile()) {
            fileList.add(generateZipEntry(node.toString()));
        }

        if (node.isDirectory()) {
            String[] subNote = node.list();
            for (String filename: subNote) {
                generateFileList(new File(node, filename));
            }
        }
    }

    private String generateZipEntry(String file) {
        return file.substring(SOURCE_FOLDER.length() + 1, file.length());
    }
}
******************************
Original:
public enum Month {
    JANUARY, FEBRUARY, ...
}
******************************
Normalized:
******************************
Original:
public enum Month {
    JANUARY, FEBRUARY, ...
}
******************************
Normalized:
public enum Month {
    JANUARY, FEBRUARY, ...
}
******************************
Original:
ext {
    ver = [
        guava: '14.0.1'
    ]
}
******************************
Normalized:
******************************
Original:
ext {
    ver = [
        guava: '14.0.1'
    ]
}
******************************
Normalized:
ext {
    ver = [
        guava: '14.0.1'
    ]
}
******************************
Original:
private static long gcd(long a, long b)
{
    while (b &gt; 0)
    {
        long temp = b;
        b = a % b; // % is remainder
        a = temp;
    }
    return a;
}

private static long gcd(long[] input)
{
    long result = input[0];
    for(int i = 1; i &lt; input.length; i++) result = gcd(result, input[i]);
    return result;
}
******************************
Normalized:
******************************
Original:
private static long gcd(long a, long b)
{
    while (b &gt; 0)
    {
        long temp = b;
        b = a % b; // % is remainder
        a = temp;
    }
    return a;
}

private static long gcd(long[] input)
{
    long result = input[0];
    for(int i = 1; i &lt; input.length; i++) result = gcd(result, input[i]);
    return result;
}
******************************
Normalized:
private static long gcd(long a, long b)
{
    while (b &gt; 0)
    {
        long temp = b;
        b = a % b; // % is remainder
        a = temp;
    }
    return a;
}

private static long gcd(long[] input)
{
    long result = input[0];
    for(int i = 1; i &lt; input.length; i++) result = gcd(result, input[i]);
    return result;
}
******************************
Original:
$ sudo apt-get install libxtst6:i386
******************************
Normalized:
******************************
Original:
$ sudo apt-get install libxtst6:i386
******************************
Normalized:
$ sudo apt-get install libxtst6:i386
******************************
Original:
public class Helper {

        public static boolean isAppRunning(final Context context, final String packageName) {
            final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            final List&lt;ActivityManager.RunningAppProcessInfo&gt; procInfos = activityManager.getRunningAppProcesses();
            if (procInfos != null)
            {
                for (final ActivityManager.RunningAppProcessInfo processInfo : procInfos) {
                    if (processInfo.processName.equals(packageName)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
******************************
Normalized:
******************************
Original:
public class Helper {

        public static boolean isAppRunning(final Context context, final String packageName) {
            final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            final List&lt;ActivityManager.RunningAppProcessInfo&gt; procInfos = activityManager.getRunningAppProcesses();
            if (procInfos != null)
            {
                for (final ActivityManager.RunningAppProcessInfo processInfo : procInfos) {
                    if (processInfo.processName.equals(packageName)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
******************************
Normalized:
public class Helper {

        public static boolean isAppRunning(final Context context, final String packageName) {
            final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            final List&lt;ActivityManager.RunningAppProcessInfo&gt; procInfos = activityManager.getRunningAppProcesses();
            if (procInfos != null)
            {
                for (final ActivityManager.RunningAppProcessInfo processInfo : procInfos) {
                    if (processInfo.processName.equals(packageName)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
******************************
Original:
# Set root logger level to DEBUG and its only appender to A1.
log4j.rootLogger=DEBUG, A1

# A1 is set to be a ConsoleAppender.
log4j.appender.A1=org.apache.log4j.ConsoleAppender

# A1 uses PatternLayout.
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n

# An alternative logging format:
# log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1} - %m%n
******************************
Normalized:
******************************
Original:
# Set root logger level to DEBUG and its only appender to A1.
log4j.rootLogger=DEBUG, A1

# A1 is set to be a ConsoleAppender.
log4j.appender.A1=org.apache.log4j.ConsoleAppender

# A1 uses PatternLayout.
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n

# An alternative logging format:
# log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1} - %m%n
******************************
Normalized:
# Set root logger level to DEBUG and its only appender to A1.
log4j.rootLogger=DEBUG, A1

# A1 is set to be a ConsoleAppender.
log4j.appender.A1=org.apache.log4j.ConsoleAppender

# A1 uses PatternLayout.
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n

# An alternative logging format:
# log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1} - %m%n
******************************
Original:
public class MyComparator implements Comparator&lt;Integer&gt; {
   public int compare(Integer a, Integer b) {
      //
   }
}
******************************
Normalized:
******************************
Original:
public class MyComparator implements Comparator&lt;Integer&gt; {
   public int compare(Integer a, Integer b) {
      //
   }
}
******************************
Normalized:
public class MyComparator implements Comparator&lt;Integer&gt; {
   public int compare(Integer a, Integer b) {
      //
   }
}
******************************
Original:
public InputField(String labelText, Class&lt;W&gt; clazz)
{
    super(new String[] {labelText}, clazz);
}
******************************
Normalized:
******************************
Original:
public InputField(String labelText, Class&lt;W&gt; clazz)
{
    super(new String[] {labelText}, clazz);
}
******************************
Normalized:
public InputField(String labelText, Class&lt;W&gt; clazz)
{
    super(new String[] {labelText}, clazz);
}
******************************
Original:
private Object actuallyT;

public &lt;T&gt; List&lt;T&gt; magicalListGetter(Class&lt;T&gt; klazz) {
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    list.add(klazz.cast(actuallyT));
    try {
        list.add(klazz.getConstructor().newInstance()); // If default constructor
    } ...
    return list;
}
******************************
Normalized:
******************************
Original:
private Object actuallyT;

public &lt;T&gt; List&lt;T&gt; magicalListGetter(Class&lt;T&gt; klazz) {
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    list.add(klazz.cast(actuallyT));
    try {
        list.add(klazz.getConstructor().newInstance()); // If default constructor
    } ...
    return list;
}
******************************
Normalized:
private Object actuallyT;

public &lt;T&gt; List&lt;T&gt; magicalListGetter(Class&lt;T&gt; klazz) {
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    list.add(klazz.cast(actuallyT));
    try {
        list.add(klazz.getConstructor().newInstance()); // If default constructor
    } ...
    return list;
}
******************************
Original:
@Component
public class ImagesPurgeJob implements Job {

    private Logger logger = Logger.getLogger(this.getClass());

    @Value("${jobs.mediafiles.imagesPurgeJob.enable}")
    private boolean imagesPurgeJobEnable;

    @Override
    @Transactional(readOnly=true)
    @Scheduled(cron = "${jobs.mediafiles.imagesPurgeJob.schedule}")
    public void execute() {

         //Do something
        //can use DAO or other autowired beans here
        if(imagesPurgeJobEnable){

            Do your conditional job here...

        }
    }
}
******************************
Normalized:
******************************
Original:
@Component
public class ImagesPurgeJob implements Job {

    private Logger logger = Logger.getLogger(this.getClass());

    @Value("${jobs.mediafiles.imagesPurgeJob.enable}")
    private boolean imagesPurgeJobEnable;

    @Override
    @Transactional(readOnly=true)
    @Scheduled(cron = "${jobs.mediafiles.imagesPurgeJob.schedule}")
    public void execute() {

         //Do something
        //can use DAO or other autowired beans here
        if(imagesPurgeJobEnable){

            Do your conditional job here...

        }
    }
}
******************************
Normalized:
@Component
public class ImagesPurgeJob implements Job {

    private Logger logger = Logger.getLogger(this.getClass());

    @Value("${jobs.mediafiles.imagesPurgeJob.enable}")
    private boolean imagesPurgeJobEnable;

    @Override
    @Transactional(readOnly=true)
    @Scheduled(cron = "${jobs.mediafiles.imagesPurgeJob.schedule}")
    public void execute() {

         //Do something
        //can use DAO or other autowired beans here
        if(imagesPurgeJobEnable){

            Do your conditional job here...

        }
    }
}
******************************
Original:
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
******************************
Normalized:
******************************
Original:
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
******************************
Normalized:
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
******************************
Original:
@RunWith(Parameterized.class)
 @ContextConfiguration(classes = {ApplicationConfigTest.class})
 public class ServiceTest {

     private TestContextManager testContextManager;

     @Before
     public void setUpContext() throws Exception {
         //this is where the magic happens, we actually do "by hand" what the spring runner would do for us,
        // read the JavaDoc for the class bellow to know exactly what it does, the method names are quite accurate though
       this.testContextManager = new TestContextManager(getClass());
       this.testContextManager.prepareTestInstance(this);
     }
     ...
 }
******************************
Normalized:
******************************
Original:
@RunWith(Parameterized.class)
 @ContextConfiguration(classes = {ApplicationConfigTest.class})
 public class ServiceTest {

     private TestContextManager testContextManager;

     @Before
     public void setUpContext() throws Exception {
         //this is where the magic happens, we actually do "by hand" what the spring runner would do for us,
        // read the JavaDoc for the class bellow to know exactly what it does, the method names are quite accurate though
       this.testContextManager = new TestContextManager(getClass());
       this.testContextManager.prepareTestInstance(this);
     }
     ...
 }
******************************
Normalized:
@RunWith(Parameterized.class)
 @ContextConfiguration(classes = {ApplicationConfigTest.class})
 public class ServiceTest {

     private TestContextManager testContextManager;

     @Before
     public void setUpContext() throws Exception {
         //this is where the magic happens, we actually do "by hand" what the spring runner would do for us,
        // read the JavaDoc for the class bellow to know exactly what it does, the method names are quite accurate though
       this.testContextManager = new TestContextManager(getClass());
       this.testContextManager.prepareTestInstance(this);
     }
     ...
 }
******************************
Original:
@SuppressWarnings("WeakerAccess")
******************************
Normalized:
******************************
Original:
@SuppressWarnings("WeakerAccess")
******************************
Normalized:
@SuppressWarnings("WeakerAccess")
******************************
Original:
-vm
C:\Program Files\Java\jdk1.6.0_07\bin\
******************************
Normalized:
******************************
Original:
-vm
C:\Program Files\Java\jdk1.6.0_07\bin\
******************************
Normalized:
-vm
C:\Program Files\Java\jdk1.6.0_07\bin\
******************************
Original:
final List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
list = new ArrayList&lt;Integer&gt;(); // Since `list' is final, this won't compile
******************************
Normalized:
******************************
Original:
final List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
list = new ArrayList&lt;Integer&gt;(); // Since `list' is final, this won't compile
******************************
Normalized:
final List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
list = new ArrayList&lt;Integer&gt;(); // Since `list' is final, this won't compile
******************************
Original:
JarFile jarFile = new JarFile(pathToJar);
Enumeration&lt;JarEntry&gt; e = jarFile.entries();

URL[] urls = { new URL("jar:file:" + pathToJar+"!/") };
URLClassLoader cl = URLClassLoader.newInstance(urls);

while (e.hasMoreElements()) {
    JarEntry je = e.nextElement();
    if(je.isDirectory() || !je.getName().endsWith(".class")){
        continue;
    }
    // -6 because of .class
    String className = je.getName().substring(0,je.getName().length()-6);
    className = className.replace('/', '.');
    Class c = cl.loadClass(className);

}
******************************
Normalized:
******************************
Original:
JarFile jarFile = new JarFile(pathToJar);
Enumeration&lt;JarEntry&gt; e = jarFile.entries();

URL[] urls = { new URL("jar:file:" + pathToJar+"!/") };
URLClassLoader cl = URLClassLoader.newInstance(urls);

while (e.hasMoreElements()) {
    JarEntry je = e.nextElement();
    if(je.isDirectory() || !je.getName().endsWith(".class")){
        continue;
    }
    // -6 because of .class
    String className = je.getName().substring(0,je.getName().length()-6);
    className = className.replace('/', '.');
    Class c = cl.loadClass(className);

}
******************************
Normalized:
JarFile jarFile = new JarFile(pathToJar);
Enumeration&lt;JarEntry&gt; e = jarFile.entries();

URL[] urls = { new URL("jar:file:" + pathToJar+"!/") };
URLClassLoader cl = URLClassLoader.newInstance(urls);

while (e.hasMoreElements()) {
    JarEntry je = e.nextElement();
    if(je.isDirectory() || !je.getName().endsWith(".class")){
        continue;
    }
    // -6 because of .class
    String className = je.getName().substring(0,je.getName().length()-6);
    className = className.replace('/', '.');
    Class c = cl.loadClass(className);

}
******************************
Original:
// All exception handling omitted!
Class&lt;?&gt; enclosingClass = Class.forName("com.mycompany.Mother");
Object enclosingInstance = enclosingClass.newInstance();

Class&lt;?&gt; innerClass = Class.forName("com.mycompany.Mother$Child");
Constructor&lt;?&gt; ctor = innerClass.getDeclaredConstructor(enclosingClass);

Object innerInstance = ctor.newInstance(enclosingInstance);
******************************
Normalized:
******************************
Original:
// All exception handling omitted!
Class&lt;?&gt; enclosingClass = Class.forName("com.mycompany.Mother");
Object enclosingInstance = enclosingClass.newInstance();

Class&lt;?&gt; innerClass = Class.forName("com.mycompany.Mother$Child");
Constructor&lt;?&gt; ctor = innerClass.getDeclaredConstructor(enclosingClass);

Object innerInstance = ctor.newInstance(enclosingInstance);
******************************
Normalized:
// All exception handling omitted!
Class&lt;?&gt; enclosingClass = Class.forName("com.mycompany.Mother");
Object enclosingInstance = enclosingClass.newInstance();

Class&lt;?&gt; innerClass = Class.forName("com.mycompany.Mother$Child");
Constructor&lt;?&gt; ctor = innerClass.getDeclaredConstructor(enclosingClass);

Object innerInstance = ctor.newInstance(enclosingInstance);
******************************
Original:
private static final Consumer&lt;Object&gt; NOOP = whatever -&gt; {};
******************************
Normalized:
******************************
Original:
private static final Consumer&lt;Object&gt; NOOP = whatever -&gt; {};
******************************
Normalized:
private static final Consumer&lt;Object&gt; NOOP = whatever -&gt; {};
******************************
Original:
&lt;bean id="transactionManager1"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory1" /&gt;
    &lt;qualifier value="account"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionManager2"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory2" /&gt;
    &lt;qualifier value="businessData"/&gt;
&lt;/bean&gt;
******************************
Normalized:
******************************
Original:
&lt;bean id="transactionManager1"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory1" /&gt;
    &lt;qualifier value="account"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionManager2"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory2" /&gt;
    &lt;qualifier value="businessData"/&gt;
&lt;/bean&gt;
******************************
Normalized:
&lt;bean id="transactionManager1"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory1" /&gt;
    &lt;qualifier value="account"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionManager2"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory2" /&gt;
    &lt;qualifier value="businessData"/&gt;
&lt;/bean&gt;
******************************
Original:
// Get file from file name
File file = new File("U:\intranet_root\intranet\R1112B2.zip");

// Get length of file in bytes
long fileSizeInBytes = file.length();
// Convert the bytes to Kilobytes (1 KB = 1024 Bytes)
long fileSizeInKB = fileSizeInBytes / 1024;
// Convert the KB to MegaBytes (1 MB = 1024 KBytes)
long fileSizeInMB = fileSizeInKB / 1024;

if (fileSizeInMB &gt; 27) {
  ...
}
******************************
Normalized:
******************************
Original:
// Get file from file name
File file = new File("U:\intranet_root\intranet\R1112B2.zip");

// Get length of file in bytes
long fileSizeInBytes = file.length();
// Convert the bytes to Kilobytes (1 KB = 1024 Bytes)
long fileSizeInKB = fileSizeInBytes / 1024;
// Convert the KB to MegaBytes (1 MB = 1024 KBytes)
long fileSizeInMB = fileSizeInKB / 1024;

if (fileSizeInMB &gt; 27) {
  ...
}
******************************
Normalized:
// Get file from file name
File file = new File("U:\intranet_root\intranet\R1112B2.zip");

// Get length of file in bytes
long fileSizeInBytes = file.length();
// Convert the bytes to Kilobytes (1 KB = 1024 Bytes)
long fileSizeInKB = fileSizeInBytes / 1024;
// Convert the KB to MegaBytes (1 MB = 1024 KBytes)
long fileSizeInMB = fileSizeInKB / 1024;

if (fileSizeInMB &gt; 27) {
  ...
}
******************************
Original:
[{A,1},{B,1},{C,2}]
******************************
Normalized:
******************************
Original:
[{A,1},{B,1},{C,2}]
******************************
Normalized:
[{A,1},{B,1},{C,2}]
******************************
Original:
grammar Math;

compileUnit
    :   expr EOF
    ;

expr
    :   '(' expr ')'                         # parensExpr
    |   op=('+'|'-') expr                    # unaryExpr
    |   left=expr op=('*'|'/') right=expr    # infixExpr
    |   left=expr op=('+'|'-') right=expr    # infixExpr
    |   func=ID '(' expr ')'                 # funcExpr
    |   value=NUM                            # numberExpr
    ;

OP_ADD: '+';
OP_SUB: '-';
OP_MUL: '*';
OP_DIV: '/';

NUM :   [0-9]+ ('.' [0-9]+)? ([eE] [+-]? [0-9]+)?;
ID  :   [a-zA-Z]+;
WS  :   [ \t\r\n] -&gt; channel(HIDDEN);
******************************
Normalized:
******************************
Original:
grammar Math;

compileUnit
    :   expr EOF
    ;

expr
    :   '(' expr ')'                         # parensExpr
    |   op=('+'|'-') expr                    # unaryExpr
    |   left=expr op=('*'|'/') right=expr    # infixExpr
    |   left=expr op=('+'|'-') right=expr    # infixExpr
    |   func=ID '(' expr ')'                 # funcExpr
    |   value=NUM                            # numberExpr
    ;

OP_ADD: '+';
OP_SUB: '-';
OP_MUL: '*';
OP_DIV: '/';

NUM :   [0-9]+ ('.' [0-9]+)? ([eE] [+-]? [0-9]+)?;
ID  :   [a-zA-Z]+;
WS  :   [ \t\r\n] -&gt; channel(HIDDEN);
******************************
Normalized:
grammar Math;

compileUnit
    :   expr EOF
    ;

expr
    :   '(' expr ')'                         # parensExpr
    |   op=('+'|'-') expr                    # unaryExpr
    |   left=expr op=('*'|'/') right=expr    # infixExpr
    |   left=expr op=('+'|'-') right=expr    # infixExpr
    |   func=ID '(' expr ')'                 # funcExpr
    |   value=NUM                            # numberExpr
    ;

OP_ADD: '+';
OP_SUB: '-';
OP_MUL: '*';
OP_DIV: '/';

NUM :   [0-9]+ ('.' [0-9]+)? ([eE] [+-]? [0-9]+)?;
ID  :   [a-zA-Z]+;
WS  :   [ \t\r\n] -&gt; channel(HIDDEN);
******************************
Original:
byte[] one = getBytesForOne();
byte[] two = getBytesForTwo();
byte[] combined = new byte[one.length + two.length];

for (int i = 0; i &lt; combined.length; ++i)
{
    combined[i] = i &lt; one.length ? one[i] : two[i - one.length];
}
******************************
Normalized:
******************************
Original:
byte[] one = getBytesForOne();
byte[] two = getBytesForTwo();
byte[] combined = new byte[one.length + two.length];

for (int i = 0; i &lt; combined.length; ++i)
{
    combined[i] = i &lt; one.length ? one[i] : two[i - one.length];
}
******************************
Normalized:
byte[] one = getBytesForOne();
byte[] two = getBytesForTwo();
byte[] combined = new byte[one.length + two.length];

for (int i = 0; i &lt; combined.length; ++i)
{
    combined[i] = i &lt; one.length ? one[i] : two[i - one.length];
}
******************************
Original:
&lt;string name="meatShootingMessage"&gt;You shot %1$d pounds of meat!&lt;/string&gt;  


int numPoundsMeat = 123;
String strMeatFormat = getResources().getString(R.string.meatShootingMessage, numPoundsMeat);
******************************
Normalized:
******************************
Original:
&lt;string name="meatShootingMessage"&gt;You shot %1$d pounds of meat!&lt;/string&gt;  


int numPoundsMeat = 123;
String strMeatFormat = getResources().getString(R.string.meatShootingMessage, numPoundsMeat);
******************************
Normalized:
&lt;string name="meatShootingMessage"&gt;You shot %1$d pounds of meat!&lt;/string&gt;  


int numPoundsMeat = 123;
String strMeatFormat = getResources().getString(R.string.meatShootingMessage, numPoundsMeat);
******************************
Original:
class MyClass {
    companion object {
        public const val FOO = 1

    }
}
******************************
Normalized:
******************************
Original:
class MyClass {
    companion object {
        public const val FOO = 1

    }
}
******************************
Normalized:
class MyClass {
    companion object {
        public const val FOO = 1

    }
}
******************************
Original:
Set&lt;String&gt; users = new HashSet&lt;&gt;(Arrays.asList("Alice", "Bob"));

System.out.println(users.contains("Alice"));
// -&gt; prints true

System.out.println(users.contains("Jack"));
// -&gt; prints false
******************************
Normalized:
******************************
Original:
Set&lt;String&gt; users = new HashSet&lt;&gt;(Arrays.asList("Alice", "Bob"));

System.out.println(users.contains("Alice"));
// -&gt; prints true

System.out.println(users.contains("Jack"));
// -&gt; prints false
******************************
Normalized:
Set&lt;String&gt; users = new HashSet&lt;&gt;(Arrays.asList("Alice", "Bob"));

System.out.println(users.contains("Alice"));
// -&gt; prints true

System.out.println(users.contains("Jack"));
// -&gt; prints false
******************************
Original:
@TestPropertySource(properties=
{"spring.autoconfigure.exclude=comma.seperated.ClassNames,com.example.FooAutoConfiguration"})
@SpringBootTest
public class MySpringTest {...}
******************************
Normalized:
******************************
Original:
@TestPropertySource(properties=
{"spring.autoconfigure.exclude=comma.seperated.ClassNames,com.example.FooAutoConfiguration"})
@SpringBootTest
public class MySpringTest {...}
******************************
Normalized:
@TestPropertySource(properties=
{"spring.autoconfigure.exclude=comma.seperated.ClassNames,com.example.FooAutoConfiguration"})
@SpringBootTest
public class MySpringTest {...}
******************************
Original:
// use '..' in the args expression if you have zero or more parameters at that point
@Before("execution(* com.mkyong.customer.bo.CustomerBo.addCustomer(..)) &amp;&amp; args(yourString,..)")
******************************
Normalized:
******************************
Original:
// use '..' in the args expression if you have zero or more parameters at that point
@Before("execution(* com.mkyong.customer.bo.CustomerBo.addCustomer(..)) &amp;&amp; args(yourString,..)")
******************************
Normalized:
// use '..' in the args expression if you have zero or more parameters at that point
@Before("execution(* com.mkyong.customer.bo.CustomerBo.addCustomer(..)) &amp;&amp; args(yourString,..)")
******************************
Original:
mvn eclipse:eclipse
******************************
Normalized:
******************************
Original:
mvn eclipse:eclipse
******************************
Normalized:
mvn eclipse:eclipse
******************************
Original:
java -cp "$LIB/*"
******************************
Normalized:
******************************
Original:
java -cp "$LIB/*"
******************************
Normalized:
java -cp "$LIB/*"
******************************
Original:
&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd" &gt;
&lt;log4j:configuration debug="false"&gt;

    &lt;appender name="default.console" class="org.apache.log4j.ConsoleAppender"&gt;
        &lt;param name="target" value="System.out" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="default.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/mylogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="another.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/anotherlogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;logger name="com.yourcompany.SomeClass" additivity="false"&gt;
        &lt;level value="debug" /&gt;
        &lt;appender-ref ref="another.file" /&gt;
    &lt;/logger&gt;

    &lt;root&gt;
        &lt;priority value="info" /&gt;
        &lt;appender-ref ref="default.console" /&gt;
        &lt;appender-ref ref="default.file" /&gt;
    &lt;/root&gt;
&lt;/log4j:configuration&gt;
******************************
Normalized:
******************************
Original:
&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd" &gt;
&lt;log4j:configuration debug="false"&gt;

    &lt;appender name="default.console" class="org.apache.log4j.ConsoleAppender"&gt;
        &lt;param name="target" value="System.out" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="default.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/mylogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="another.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/anotherlogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;logger name="com.yourcompany.SomeClass" additivity="false"&gt;
        &lt;level value="debug" /&gt;
        &lt;appender-ref ref="another.file" /&gt;
    &lt;/logger&gt;

    &lt;root&gt;
        &lt;priority value="info" /&gt;
        &lt;appender-ref ref="default.console" /&gt;
        &lt;appender-ref ref="default.file" /&gt;
    &lt;/root&gt;
&lt;/log4j:configuration&gt;
******************************
Normalized:
&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd" &gt;
&lt;log4j:configuration debug="false"&gt;

    &lt;appender name="default.console" class="org.apache.log4j.ConsoleAppender"&gt;
        &lt;param name="target" value="System.out" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="default.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/mylogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="another.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/anotherlogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;logger name="com.yourcompany.SomeClass" additivity="false"&gt;
        &lt;level value="debug" /&gt;
        &lt;appender-ref ref="another.file" /&gt;
    &lt;/logger&gt;

    &lt;root&gt;
        &lt;priority value="info" /&gt;
        &lt;appender-ref ref="default.console" /&gt;
        &lt;appender-ref ref="default.file" /&gt;
    &lt;/root&gt;
&lt;/log4j:configuration&gt;
******************************
Original:
Supplier&lt;List&lt;Shape&gt;&gt; supplier = () -&gt; new LinkedList&lt;Shape&gt;();

List&lt;Shape&gt; blue = shapes.stream()
            .filter(s -&gt; s.getColor() == BLUE)
            .collect(Collectors.toCollection(supplier));
******************************
Normalized:
******************************
Original:
Supplier&lt;List&lt;Shape&gt;&gt; supplier = () -&gt; new LinkedList&lt;Shape&gt;();

List&lt;Shape&gt; blue = shapes.stream()
            .filter(s -&gt; s.getColor() == BLUE)
            .collect(Collectors.toCollection(supplier));
******************************
Normalized:
Supplier&lt;List&lt;Shape&gt;&gt; supplier = () -&gt; new LinkedList&lt;Shape&gt;();

List&lt;Shape&gt; blue = shapes.stream()
            .filter(s -&gt; s.getColor() == BLUE)
            .collect(Collectors.toCollection(supplier));
******************************
Original:
Criterion topPercentFromRange(Comparator&lt;Widget&gt; cmp, double from, double to) {
    return stream -&gt; {
        List&lt;Widget&gt; temp =
            stream.sorted(cmp).collect(toList());
        return temp.stream()
                   .skip((long)(temp.size() * from))
                   .limit((long)(temp.size() * (to - from)));
    };
}
******************************
Normalized:
******************************
Original:
Criterion topPercentFromRange(Comparator&lt;Widget&gt; cmp, double from, double to) {
    return stream -&gt; {
        List&lt;Widget&gt; temp =
            stream.sorted(cmp).collect(toList());
        return temp.stream()
                   .skip((long)(temp.size() * from))
                   .limit((long)(temp.size() * (to - from)));
    };
}
******************************
Normalized:
Criterion topPercentFromRange(Comparator&lt;Widget&gt; cmp, double from, double to) {
    return stream -&gt; {
        List&lt;Widget&gt; temp =
            stream.sorted(cmp).collect(toList());
        return temp.stream()
                   .skip((long)(temp.size() * from))
                   .limit((long)(temp.size() * (to - from)));
    };
}
******************************
Original:
Scanner s = new Scanner(new File("filepath"));
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
while (s.hasNext()){
    list.add(s.next());
}
s.close();
******************************
Normalized:
******************************
Original:
Scanner s = new Scanner(new File("filepath"));
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
while (s.hasNext()){
    list.add(s.next());
}
s.close();
******************************
Normalized:
Scanner s = new Scanner(new File("filepath"));
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
while (s.hasNext()){
    list.add(s.next());
}
s.close();
******************************
Original:
Stream&lt;String&gt; texts = optional.stream();
******************************
Normalized:
******************************
Original:
Stream&lt;String&gt; texts = optional.stream();
******************************
Normalized:
Stream&lt;String&gt; texts = optional.stream();
******************************
Original:
ObjectListing listing = s3.listObjects( bucketName, prefix );
List&lt;S3ObjectSummary&gt; summaries = listing.getObjectSummaries();

while (listing.isTruncated()) {
   listing = s3.listNextBatchOfObjects (listing);
   summaries.addAll (listing.getObjectSummaries());
}
******************************
Normalized:
******************************
Original:
ObjectListing listing = s3.listObjects( bucketName, prefix );
List&lt;S3ObjectSummary&gt; summaries = listing.getObjectSummaries();

while (listing.isTruncated()) {
   listing = s3.listNextBatchOfObjects (listing);
   summaries.addAll (listing.getObjectSummaries());
}
******************************
Normalized:
ObjectListing listing = s3.listObjects( bucketName, prefix );
List&lt;S3ObjectSummary&gt; summaries = listing.getObjectSummaries();

while (listing.isTruncated()) {
   listing = s3.listNextBatchOfObjects (listing);
   summaries.addAll (listing.getObjectSummaries());
}
******************************
Original:
/*[local-name()='workbook'
    and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheets'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheet'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main'][1]
******************************
Normalized:
******************************
Original:
/*[local-name()='workbook'
    and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheets'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheet'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main'][1]
******************************
Normalized:
/*[local-name()='workbook'
    and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheets'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheet'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main'][1]
******************************
Original:
/**
 * Stateful filter. T is type of stream element, K is type of extracted key.
 */
static class DistinctByKey&lt;T,K&gt; {
    Map&lt;K,Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;();
    Function&lt;T,K&gt; keyExtractor;
    public DistinctByKey(Function&lt;T,K&gt; ke) {
        this.keyExtractor = ke;
    }
    public boolean filter(T t) {
        return seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
    }
}
******************************
Normalized:
******************************
Original:
/**
 * Stateful filter. T is type of stream element, K is type of extracted key.
 */
static class DistinctByKey&lt;T,K&gt; {
    Map&lt;K,Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;();
    Function&lt;T,K&gt; keyExtractor;
    public DistinctByKey(Function&lt;T,K&gt; ke) {
        this.keyExtractor = ke;
    }
    public boolean filter(T t) {
        return seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
    }
}
******************************
Normalized:
/**
 * Stateful filter. T is type of stream element, K is type of extracted key.
 */
static class DistinctByKey&lt;T,K&gt; {
    Map&lt;K,Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;();
    Function&lt;T,K&gt; keyExtractor;
    public DistinctByKey(Function&lt;T,K&gt; ke) {
        this.keyExtractor = ke;
    }
    public boolean filter(T t) {
        return seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
    }
}
******************************
Original:
List&lt;String&gt; species = Arrays.asList(speciesArr);
******************************
Normalized:
******************************
Original:
List&lt;String&gt; species = Arrays.asList(speciesArr);
******************************
Normalized:
List&lt;String&gt; species = Arrays.asList(speciesArr);
******************************
Original:
ObjectMapper mapper = new ObjectMapper();
Map&lt;String,Object&gt; map = mapper.readValue(json, Map.class);
******************************
Normalized:
******************************
Original:
ObjectMapper mapper = new ObjectMapper();
Map&lt;String,Object&gt; map = mapper.readValue(json, Map.class);
******************************
Normalized:
ObjectMapper mapper = new ObjectMapper();
Map&lt;String,Object&gt; map = mapper.readValue(json, Map.class);
******************************
Original:
for (initialization statement; condition check; update)
    loop body;
******************************
Normalized:
******************************
Original:
for (initialization statement; condition check; update)
    loop body;
******************************
Normalized:
for (initialization statement; condition check; update)
    loop body;
******************************
Original:
public class ArrayIndexComparator implements Comparator&lt;Integer&gt;
{
    private final String[] array;

    public ArrayIndexComparator(String[] array)
    {
        this.array = array;
    }

    public Integer[] createIndexArray()
    {
        Integer[] indexes = new Integer[array.length];
        for (int i = 0; i &lt; array.length; i++)
        {
            indexes[i] = i; // Autoboxing
        }
        return indexes;
    }

    @Override
    public int compare(Integer index1, Integer index2)
    {
         // Autounbox from Integer to int to use as array indexes
        return array[index1].compareTo(array[index2]);
    }
}
******************************
Normalized:
******************************
Original:
public class ArrayIndexComparator implements Comparator&lt;Integer&gt;
{
    private final String[] array;

    public ArrayIndexComparator(String[] array)
    {
        this.array = array;
    }

    public Integer[] createIndexArray()
    {
        Integer[] indexes = new Integer[array.length];
        for (int i = 0; i &lt; array.length; i++)
        {
            indexes[i] = i; // Autoboxing
        }
        return indexes;
    }

    @Override
    public int compare(Integer index1, Integer index2)
    {
         // Autounbox from Integer to int to use as array indexes
        return array[index1].compareTo(array[index2]);
    }
}
******************************
Normalized:
public class ArrayIndexComparator implements Comparator&lt;Integer&gt;
{
    private final String[] array;

    public ArrayIndexComparator(String[] array)
    {
        this.array = array;
    }

    public Integer[] createIndexArray()
    {
        Integer[] indexes = new Integer[array.length];
        for (int i = 0; i &lt; array.length; i++)
        {
            indexes[i] = i; // Autoboxing
        }
        return indexes;
    }

    @Override
    public int compare(Integer index1, Integer index2)
    {
         // Autounbox from Integer to int to use as array indexes
        return array[index1].compareTo(array[index2]);
    }
}
******************************
Original:
android {
    ....
    ....

    sourceSets {
        main.java.srcDirs += 'src/main/&lt;YOUR DIRECTORY&gt;'
    }

}
******************************
Normalized:
******************************
Original:
android {
    ....
    ....

    sourceSets {
        main.java.srcDirs += 'src/main/&lt;YOUR DIRECTORY&gt;'
    }

}
******************************
Normalized:
android {
    ....
    ....

    sourceSets {
        main.java.srcDirs += 'src/main/&lt;YOUR DIRECTORY&gt;'
    }

}
******************************
Original:
import org.mockito.internal.util.MockUtil;

new MockUtil().isMock(obj)
******************************
Normalized:
******************************
Original:
import org.mockito.internal.util.MockUtil;

new MockUtil().isMock(obj)
******************************
Normalized:
import org.mockito.internal.util.MockUtil;

new MockUtil().isMock(obj)
******************************
Original:
[A-Za-z0-9.,-:]*
******************************
Normalized:
******************************
Original:
[A-Za-z0-9.,-:]*
******************************
Normalized:
[A-Za-z0-9.,-:]*
******************************
Original:
Consumer&lt;String&gt; p = ""::equals;
******************************
Normalized:
******************************
Original:
Consumer&lt;String&gt; p = ""::equals;
******************************
Normalized:
Consumer&lt;String&gt; p = ""::equals;
******************************
Original:
# cat Athrow.j 
.source Athrow.j
.class public Athrow
.super java/lang/Object

.method public &lt;init&gt;()V
    aload_0
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    return
.end method

.method public static main([Ljava/lang/String;)V
    .limit stack 2

    new java/lang/Object
    dup
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    athrow

    return
.end method

# java -jar jasmin.jar Athrow.j 
Generated: Athrow.class

# java Athrow
Exception in thread "main" java.lang.VerifyError: (class: Athrow, method: main signature: ([Ljava/lang/String;)V) Can only throw Throwable objects
******************************
Normalized:
******************************
Original:
# cat Athrow.j 
.source Athrow.j
.class public Athrow
.super java/lang/Object

.method public &lt;init&gt;()V
    aload_0
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    return
.end method

.method public static main([Ljava/lang/String;)V
    .limit stack 2

    new java/lang/Object
    dup
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    athrow

    return
.end method

# java -jar jasmin.jar Athrow.j 
Generated: Athrow.class

# java Athrow
Exception in thread "main" java.lang.VerifyError: (class: Athrow, method: main signature: ([Ljava/lang/String;)V) Can only throw Throwable objects
******************************
Normalized:
# cat Athrow.j 
.source Athrow.j
.class public Athrow
.super java/lang/Object

.method public &lt;init&gt;()V
    aload_0
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    return
.end method

.method public static main([Ljava/lang/String;)V
    .limit stack 2

    new java/lang/Object
    dup
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    athrow

    return
.end method

# java -jar jasmin.jar Athrow.j 
Generated: Athrow.class

# java Athrow
Exception in thread "main" java.lang.VerifyError: (class: Athrow, method: main signature: ([Ljava/lang/String;)V) Can only throw Throwable objects
******************************
Original:
&lt;manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:sharedUserId="android.uid.shared"
    android:sharedUserLabel="@string/sharedUserLabel"
    ...&gt;
******************************
Normalized:
******************************
Original:
&lt;manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:sharedUserId="android.uid.shared"
    android:sharedUserLabel="@string/sharedUserLabel"
    ...&gt;
******************************
Normalized:
&lt;manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:sharedUserId="android.uid.shared"
    android:sharedUserLabel="@string/sharedUserLabel"
    ...&gt;
******************************
Original:
ExecutorService executor = Executors.newSingleThreadExecutor();

    // LAMBDA COMPILED INTO A 'Callable&lt;?&gt;'
    executor.submit(() -&gt; {
        while (true)
            throw new Exception();
    });

    // LAMBDA COMPILED INTO A 'Runnable': EXCEPTIONS MUST BE HANDLED BY LAMBDA ITSELF!
    executor.submit(() -&gt; {
        boolean value = true;
        while (value)
            throw new Exception();
    });
******************************
Normalized:
******************************
Original:
ExecutorService executor = Executors.newSingleThreadExecutor();

    // LAMBDA COMPILED INTO A 'Callable&lt;?&gt;'
    executor.submit(() -&gt; {
        while (true)
            throw new Exception();
    });

    // LAMBDA COMPILED INTO A 'Runnable': EXCEPTIONS MUST BE HANDLED BY LAMBDA ITSELF!
    executor.submit(() -&gt; {
        boolean value = true;
        while (value)
            throw new Exception();
    });
******************************
Normalized:
ExecutorService executor = Executors.newSingleThreadExecutor();

    // LAMBDA COMPILED INTO A 'Callable&lt;?&gt;'
    executor.submit(() -&gt; {
        while (true)
            throw new Exception();
    });

    // LAMBDA COMPILED INTO A 'Runnable': EXCEPTIONS MUST BE HANDLED BY LAMBDA ITSELF!
    executor.submit(() -&gt; {
        boolean value = true;
        while (value)
            throw new Exception();
    });
******************************
Original:
public void webmethod(@RequestParam("date") String strDate) {
    Date date = ... // manually parse the date
 }
******************************
Normalized:
******************************
Original:
public void webmethod(@RequestParam("date") String strDate) {
    Date date = ... // manually parse the date
 }
******************************
Normalized:
public void webmethod(@RequestParam("date") String strDate) {
    Date date = ... // manually parse the date
 }
******************************
Original:
(throws IOException)

Image image = null;
try {
    URL url = new URL("http://www.yahoo.com/image_to_read.jpg");
    image = ImageIO.read(url);
} catch (IOException e) {
}
******************************
Normalized:
******************************
Original:
(throws IOException)

Image image = null;
try {
    URL url = new URL("http://www.yahoo.com/image_to_read.jpg");
    image = ImageIO.read(url);
} catch (IOException e) {
}
******************************
Normalized:
(throws IOException)

Image image = null;
try {
    URL url = new URL("http://www.yahoo.com/image_to_read.jpg");
    image = ImageIO.read(url);
} catch (IOException e) {
}
******************************
Original:
&lt;style name="MyTheme" parent="android:Theme.Holo.Light"&gt;
    &lt;item name="actionButtonStyle"&gt;@style/MyActionButtonStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="MyActionButtonStyle" parent="Widget.ActionButton"&gt;
    &lt;item name="android:minWidth"&gt;28dip&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
******************************
Original:
&lt;style name="MyTheme" parent="android:Theme.Holo.Light"&gt;
    &lt;item name="actionButtonStyle"&gt;@style/MyActionButtonStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="MyActionButtonStyle" parent="Widget.ActionButton"&gt;
    &lt;item name="android:minWidth"&gt;28dip&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
&lt;style name="MyTheme" parent="android:Theme.Holo.Light"&gt;
    &lt;item name="actionButtonStyle"&gt;@style/MyActionButtonStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="MyActionButtonStyle" parent="Widget.ActionButton"&gt;
    &lt;item name="android:minWidth"&gt;28dip&lt;/item&gt;
&lt;/style&gt;
******************************
Original:
Months.values()[index]
******************************
Normalized:
******************************
Original:
Months.values()[index]
******************************
Normalized:
Months.values()[index]
******************************
Original:
Object
     /      \
    /        \
String     Integer
******************************
Normalized:
******************************
Original:
Object
     /      \
    /        \
String     Integer
******************************
Normalized:
Object
     /      \
    /        \
String     Integer
******************************
Original:
public void restartApplication()
{
  final String javaBin = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
  final File currentJar = new File(MyClassInTheJar.class.getProtectionDomain().getCodeSource().getLocation().toURI());

  /* is it a jar file? */
  if(!currentJar.getName().endsWith(".jar"))
    return;

  /* Build command: java -jar application.jar */
  final ArrayList&lt;String&gt; command = new ArrayList&lt;String&gt;();
  command.add(javaBin);
  command.add("-jar");
  command.add(currentJar.getPath());

  final ProcessBuilder builder = new ProcessBuilder(command);
  builder.start();
  System.exit(0);
}
******************************
Normalized:
******************************
Original:
public void restartApplication()
{
  final String javaBin = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
  final File currentJar = new File(MyClassInTheJar.class.getProtectionDomain().getCodeSource().getLocation().toURI());

  /* is it a jar file? */
  if(!currentJar.getName().endsWith(".jar"))
    return;

  /* Build command: java -jar application.jar */
  final ArrayList&lt;String&gt; command = new ArrayList&lt;String&gt;();
  command.add(javaBin);
  command.add("-jar");
  command.add(currentJar.getPath());

  final ProcessBuilder builder = new ProcessBuilder(command);
  builder.start();
  System.exit(0);
}
******************************
Normalized:
public void restartApplication()
{
  final String javaBin = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
  final File currentJar = new File(MyClassInTheJar.class.getProtectionDomain().getCodeSource().getLocation().toURI());

  /* is it a jar file? */
  if(!currentJar.getName().endsWith(".jar"))
    return;

  /* Build command: java -jar application.jar */
  final ArrayList&lt;String&gt; command = new ArrayList&lt;String&gt;();
  command.add(javaBin);
  command.add("-jar");
  command.add(currentJar.getPath());

  final ProcessBuilder builder = new ProcessBuilder(command);
  builder.start();
  System.exit(0);
}
******************************
Original:
&lt;A&gt; List&lt;A&gt; flatten(List&lt;List&lt;A&gt;&gt; nestedLists);
******************************
Normalized:
******************************
Original:
&lt;A&gt; List&lt;A&gt; flatten(List&lt;List&lt;A&gt;&gt; nestedLists);
******************************
Normalized:
&lt;A&gt; List&lt;A&gt; flatten(List&lt;List&lt;A&gt;&gt; nestedLists);
******************************
Original:
import java.nio.FloatBuffer;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

@Platform(include = "Dot.h", compiler = "fastfpu")
public class Dot {
    static { Loader.load(); }

    static float[] a = new float[50], b = new float[50];
    static float dot() {
        float sum = 0;
        for (int i = 0; i &lt; 50; i++) {
            sum += a[i]*b[i];
        }
        return sum;
    }
    static native @MemberGetter FloatPointer ac();
    static native @MemberGetter FloatPointer bc();
    static native @NoException float dotc();

    public static void main(String[] args) {
        FloatBuffer ab = ac().capacity(50).asBuffer();
        FloatBuffer bb = bc().capacity(50).asBuffer();

        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t1 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
        }
        long t2 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t3 = System.nanoTime();
        System.out.println("dot(): " + (t2 - t1)/10000000 + " ns");
        System.out.println("dotc(): "  + (t3 - t2)/10000000 + " ns");
    }
}
******************************
Normalized:
******************************
Original:
import java.nio.FloatBuffer;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

@Platform(include = "Dot.h", compiler = "fastfpu")
public class Dot {
    static { Loader.load(); }

    static float[] a = new float[50], b = new float[50];
    static float dot() {
        float sum = 0;
        for (int i = 0; i &lt; 50; i++) {
            sum += a[i]*b[i];
        }
        return sum;
    }
    static native @MemberGetter FloatPointer ac();
    static native @MemberGetter FloatPointer bc();
    static native @NoException float dotc();

    public static void main(String[] args) {
        FloatBuffer ab = ac().capacity(50).asBuffer();
        FloatBuffer bb = bc().capacity(50).asBuffer();

        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t1 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
        }
        long t2 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t3 = System.nanoTime();
        System.out.println("dot(): " + (t2 - t1)/10000000 + " ns");
        System.out.println("dotc(): "  + (t3 - t2)/10000000 + " ns");
    }
}
******************************
Normalized:
import java.nio.FloatBuffer;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

@Platform(include = "Dot.h", compiler = "fastfpu")
public class Dot {
    static { Loader.load(); }

    static float[] a = new float[50], b = new float[50];
    static float dot() {
        float sum = 0;
        for (int i = 0; i &lt; 50; i++) {
            sum += a[i]*b[i];
        }
        return sum;
    }
    static native @MemberGetter FloatPointer ac();
    static native @MemberGetter FloatPointer bc();
    static native @NoException float dotc();

    public static void main(String[] args) {
        FloatBuffer ab = ac().capacity(50).asBuffer();
        FloatBuffer bb = bc().capacity(50).asBuffer();

        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t1 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            a[i%50] = b[i%50] = dot();
        }
        long t2 = System.nanoTime();
        for (int i = 0; i &lt; 10000000; i++) {
            float sum = dotc();
            ab.put(i%50, sum);
            bb.put(i%50, sum);
        }
        long t3 = System.nanoTime();
        System.out.println("dot(): " + (t2 - t1)/10000000 + " ns");
        System.out.println("dotc(): "  + (t3 - t2)/10000000 + " ns");
    }
}
******************************
Original:
&lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;!-- config the location(s) of the properties file(s) here --&gt;
    &lt;property name="nullValue" value="@null" /&gt;
&lt;/bean&gt;
******************************
Normalized:
******************************
Original:
&lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;!-- config the location(s) of the properties file(s) here --&gt;
    &lt;property name="nullValue" value="@null" /&gt;
&lt;/bean&gt;
******************************
Normalized:
&lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;!-- config the location(s) of the properties file(s) here --&gt;
    &lt;property name="nullValue" value="@null" /&gt;
&lt;/bean&gt;
******************************
Original:
File[] files = XMLDirectory.listFiles(filter_xml_files);
Arrays.sort(files);
for(File _xml_file : files) {
    ...
}
******************************
Normalized:
******************************
Original:
File[] files = XMLDirectory.listFiles(filter_xml_files);
Arrays.sort(files);
for(File _xml_file : files) {
    ...
}
******************************
Normalized:
File[] files = XMLDirectory.listFiles(filter_xml_files);
Arrays.sort(files);
for(File _xml_file : files) {
    ...
}
******************************
Original:
configurations {
  runtime.exclude group: "org.slf4j", module: "slf4j-log4j12"
}
******************************
Normalized:
******************************
Original:
configurations {
  runtime.exclude group: "org.slf4j", module: "slf4j-log4j12"
}
******************************
Normalized:
configurations {
  runtime.exclude group: "org.slf4j", module: "slf4j-log4j12"
}
******************************
Original:
ObjectMapper mapper = new ObjectMapper();
mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
// do various things, perhaps:
String someJsonString = mapper.writeValueAsString(someClassInstance);
SomeClass someClassInstance = mapper.readValue(someJsonString, SomeClass.class)
******************************
Normalized:
******************************
Original:
ObjectMapper mapper = new ObjectMapper();
mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
// do various things, perhaps:
String someJsonString = mapper.writeValueAsString(someClassInstance);
SomeClass someClassInstance = mapper.readValue(someJsonString, SomeClass.class)
******************************
Normalized:
ObjectMapper mapper = new ObjectMapper();
mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
// do various things, perhaps:
String someJsonString = mapper.writeValueAsString(someClassInstance);
SomeClass someClassInstance = mapper.readValue(someJsonString, SomeClass.class)
******************************
Original:
bootRun {
   jvmArgs = "-Dhttp.proxyHost=xxxxxx", "-Dhttp.proxyPort=xxxxxx"
}
******************************
Normalized:
******************************
Original:
bootRun {
   jvmArgs = "-Dhttp.proxyHost=xxxxxx", "-Dhttp.proxyPort=xxxxxx"
}
******************************
Normalized:
bootRun {
   jvmArgs = "-Dhttp.proxyHost=xxxxxx", "-Dhttp.proxyPort=xxxxxx"
}
******************************
Original:
apply plugin: "java"

sourceSets {
    // Note that just declaring this sourceset creates two configurations.
    intTest {
        java {
            compileClasspath += main.output
            runtimeClasspath += main.output
        }
    }
}

configurations {
    intTestCompile.extendsFrom testCompile
    intTestRuntime.extendsFrom testRuntime
}

task intTest(type:Test){
    description = "Run integration tests (located in src/intTest/...)."
    testClassesDir = project.sourceSets.intTest.output.classesDir
    classpath = project.sourceSets.intTest.runtimeClasspath
}
******************************
Normalized:
******************************
Original:
apply plugin: "java"

sourceSets {
    // Note that just declaring this sourceset creates two configurations.
    intTest {
        java {
            compileClasspath += main.output
            runtimeClasspath += main.output
        }
    }
}

configurations {
    intTestCompile.extendsFrom testCompile
    intTestRuntime.extendsFrom testRuntime
}

task intTest(type:Test){
    description = "Run integration tests (located in src/intTest/...)."
    testClassesDir = project.sourceSets.intTest.output.classesDir
    classpath = project.sourceSets.intTest.runtimeClasspath
}
******************************
Normalized:
apply plugin: "java"

sourceSets {
    // Note that just declaring this sourceset creates two configurations.
    intTest {
        java {
            compileClasspath += main.output
            runtimeClasspath += main.output
        }
    }
}

configurations {
    intTestCompile.extendsFrom testCompile
    intTestRuntime.extendsFrom testRuntime
}

task intTest(type:Test){
    description = "Run integration tests (located in src/intTest/...)."
    testClassesDir = project.sourceSets.intTest.output.classesDir
    classpath = project.sourceSets.intTest.runtimeClasspath
}
******************************
Original:
Runnable r = new Runnable() {
   public void run() { ... }
};
******************************
Normalized:
******************************
Original:
Runnable r = new Runnable() {
   public void run() { ... }
};
******************************
Normalized:
Runnable r = new Runnable() {
   public void run() { ... }
};
******************************
Original:
String getMonthForInt(int num) {
        String month = "wrong";
        DateFormatSymbols dfs = new DateFormatSymbols();
        String[] months = dfs.getMonths();
        if (num &gt;= 0 &amp;&amp; num &lt;= 11 ) {
            month = months[num];
        }
        return month;
    }
******************************
Normalized:
******************************
Original:
String getMonthForInt(int num) {
        String month = "wrong";
        DateFormatSymbols dfs = new DateFormatSymbols();
        String[] months = dfs.getMonths();
        if (num &gt;= 0 &amp;&amp; num &lt;= 11 ) {
            month = months[num];
        }
        return month;
    }
******************************
Normalized:
String getMonthForInt(int num) {
        String month = "wrong";
        DateFormatSymbols dfs = new DateFormatSymbols();
        String[] months = dfs.getMonths();
        if (num &gt;= 0 &amp;&amp; num &lt;= 11 ) {
            month = months[num];
        }
        return month;
    }
******************************
Original:
@Entity
class Employee {
     :
    @OneToOne(cascade=CascadeType.REMOVE)
    private Address address;
     :
}
******************************
Normalized:
******************************
Original:
@Entity
class Employee {
     :
    @OneToOne(cascade=CascadeType.REMOVE)
    private Address address;
     :
}
******************************
Normalized:
@Entity
class Employee {
     :
    @OneToOne(cascade=CascadeType.REMOVE)
    private Address address;
     :
}
******************************
Original:
spring.jackson.serialization-inclusion=non_null
******************************
Normalized:
******************************
Original:
spring.jackson.serialization-inclusion=non_null
******************************
Normalized:
spring.jackson.serialization-inclusion=non_null
******************************
Original:
List&lt;String&gt; strings = list.stream()
   .map(object -&gt; Objects.toString(object, null))
   .collect(Collectors.toList());
******************************
Normalized:
******************************
Original:
List&lt;String&gt; strings = list.stream()
   .map(object -&gt; Objects.toString(object, null))
   .collect(Collectors.toList());
******************************
Normalized:
List&lt;String&gt; strings = list.stream()
   .map(object -&gt; Objects.toString(object, null))
   .collect(Collectors.toList());
******************************
Original:
&lt;build&gt;
  &lt;plugins&gt; 
    &lt;plugin&gt;
      &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;id&gt;attach-sources&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar-no-fork&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;attach-javadocs&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;!-- explicitly define maven-deploy-plugin after other to force exec order --&gt;
      &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;deploy&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;deploy&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
  &lt;/plugins&gt; 
&lt;/build&gt;
******************************
Normalized:
******************************
Original:
&lt;build&gt;
  &lt;plugins&gt; 
    &lt;plugin&gt;
      &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;id&gt;attach-sources&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar-no-fork&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;attach-javadocs&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;!-- explicitly define maven-deploy-plugin after other to force exec order --&gt;
      &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;deploy&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;deploy&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
  &lt;/plugins&gt; 
&lt;/build&gt;
******************************
Normalized:
&lt;build&gt;
  &lt;plugins&gt; 
    &lt;plugin&gt;
      &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;id&gt;attach-sources&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar-no-fork&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;attach-javadocs&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;jar&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
    &lt;plugin&gt; 
      &lt;!-- explicitly define maven-deploy-plugin after other to force exec order --&gt;
      &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; 
      &lt;executions&gt; 
        &lt;execution&gt; 
          &lt;id&gt;deploy&lt;/id&gt;
          &lt;phase&gt;deploy&lt;/phase&gt;
          &lt;goals&gt;&lt;goal&gt;deploy&lt;/goal&gt;&lt;/goals&gt; 
        &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt;
  &lt;/plugins&gt; 
&lt;/build&gt;
******************************
Original:
dependencies {
    ...
    testCompile "junit:junit:4.11"  // Or whatever version
}
******************************
Normalized:
******************************
Original:
dependencies {
    ...
    testCompile "junit:junit:4.11"  // Or whatever version
}
******************************
Normalized:
dependencies {
    ...
    testCompile "junit:junit:4.11"  // Or whatever version
}
******************************
Original:
public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(
    Collection&lt;? extends T&gt; coll
)
******************************
Normalized:
******************************
Original:
public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(
    Collection&lt;? extends T&gt; coll
)
******************************
Normalized:
public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(
    Collection&lt;? extends T&gt; coll
)
******************************
Original:
public static boolean isBetween(int x, int lower, int upper) {
  return lower &lt;= x &amp;&amp; x &lt;= upper;
}

if (isBetween(num, 1, 5)) {
  System.out.println("testing case 1 to 5");
} else if (isBetween(num, 6, 10)) {
  System.out.println("testing case 6 to 10");
}
******************************
Normalized:
******************************
Original:
public static boolean isBetween(int x, int lower, int upper) {
  return lower &lt;= x &amp;&amp; x &lt;= upper;
}

if (isBetween(num, 1, 5)) {
  System.out.println("testing case 1 to 5");
} else if (isBetween(num, 6, 10)) {
  System.out.println("testing case 6 to 10");
}
******************************
Normalized:
public static boolean isBetween(int x, int lower, int upper) {
  return lower &lt;= x &amp;&amp; x &lt;= upper;
}

if (isBetween(num, 1, 5)) {
  System.out.println("testing case 1 to 5");
} else if (isBetween(num, 6, 10)) {
  System.out.println("testing case 6 to 10");
}
******************************
Original:
ObjectMapper objectMapper = new ObjectMapper();
TypeFactory typeFactory = objectMapper.getTypeFactory();
List&lt;SomeClass&gt; someClassList = objectMapper.readValue(jsonString, typeFactory.constructCollectionType(List.class, SomeClass.class));
******************************
Normalized:
******************************
Original:
ObjectMapper objectMapper = new ObjectMapper();
TypeFactory typeFactory = objectMapper.getTypeFactory();
List&lt;SomeClass&gt; someClassList = objectMapper.readValue(jsonString, typeFactory.constructCollectionType(List.class, SomeClass.class));
******************************
Normalized:
ObjectMapper objectMapper = new ObjectMapper();
TypeFactory typeFactory = objectMapper.getTypeFactory();
List&lt;SomeClass&gt; someClassList = objectMapper.readValue(jsonString, typeFactory.constructCollectionType(List.class, SomeClass.class));
******************************
Original:
packagingOptions {
   pickFirst  'META-INF/license.txt'
}
******************************
Normalized:
******************************
Original:
packagingOptions {
   pickFirst  'META-INF/license.txt'
}
******************************
Normalized:
packagingOptions {
   pickFirst  'META-INF/license.txt'
}
******************************
Original:
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
******************************
Normalized:
******************************
Original:
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
******************************
Normalized:
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
******************************
Original:
object ScannerTest {
  def main(args: Array[String]) {
    var ok = true
    while (ok) {
      val ln = readLine()
      ok = ln != null
      if (ok) println(ln)
    }
  }
}
******************************
Normalized:
******************************
Original:
object ScannerTest {
  def main(args: Array[String]) {
    var ok = true
    while (ok) {
      val ln = readLine()
      ok = ln != null
      if (ok) println(ln)
    }
  }
}
******************************
Normalized:
object ScannerTest {
  def main(args: Array[String]) {
    var ok = true
    while (ok) {
      val ln = readLine()
      ok = ln != null
      if (ok) println(ln)
    }
  }
}
******************************
Original:
&lt;global-method-security&gt;
  &lt;expression-handler ref="myMethodSecurityExpressionHandler"/&gt;
&lt;/global-method-security&gt;
******************************
Normalized:
******************************
Original:
&lt;global-method-security&gt;
  &lt;expression-handler ref="myMethodSecurityExpressionHandler"/&gt;
&lt;/global-method-security&gt;
******************************
Normalized:
&lt;global-method-security&gt;
  &lt;expression-handler ref="myMethodSecurityExpressionHandler"/&gt;
&lt;/global-method-security&gt;
******************************
Original:
int r = x % n;
if (r &gt; 0 &amp;&amp; x &lt; 0)
{
    r -= n;
}
******************************
Normalized:
******************************
Original:
int r = x % n;
if (r &gt; 0 &amp;&amp; x &lt; 0)
{
    r -= n;
}
******************************
Normalized:
int r = x % n;
if (r &gt; 0 &amp;&amp; x &lt; 0)
{
    r -= n;
}
******************************
Original:
mvn eclipse:eclipse -DdownloadSources=true
******************************
Normalized:
******************************
Original:
mvn eclipse:eclipse -DdownloadSources=true
******************************
Normalized:
mvn eclipse:eclipse -DdownloadSources=true
******************************
Original:
@POST
public Response postSomething(@QueryParam("name") String name, @Context UriInfo uriInfo, String content) {
     MultivaluedMap&lt;String, String&gt; queryParams = uriInfo.getQueryParameters(); 
     String nameParam = queryParams.getFirst("name");
}
******************************
Normalized:
******************************
Original:
@POST
public Response postSomething(@QueryParam("name") String name, @Context UriInfo uriInfo, String content) {
     MultivaluedMap&lt;String, String&gt; queryParams = uriInfo.getQueryParameters(); 
     String nameParam = queryParams.getFirst("name");
}
******************************
Normalized:
@POST
public Response postSomething(@QueryParam("name") String name, @Context UriInfo uriInfo, String content) {
     MultivaluedMap&lt;String, String&gt; queryParams = uriInfo.getQueryParameters(); 
     String nameParam = queryParams.getFirst("name");
}
******************************
Original:
interface CustomUserRepository {

  List&lt;User&gt; yourCustomMethod();
}
******************************
Normalized:
******************************
Original:
interface CustomUserRepository {

  List&lt;User&gt; yourCustomMethod();
}
******************************
Normalized:
interface CustomUserRepository {

  List&lt;User&gt; yourCustomMethod();
}
******************************
Original:
1372060916 = Mon, 24 Jun 2013 08:01:56 GMT
******************************
Normalized:
******************************
Original:
1372060916 = Mon, 24 Jun 2013 08:01:56 GMT
******************************
Normalized:
1372060916 = Mon, 24 Jun 2013 08:01:56 GMT
******************************
Original:
0x00007fdd859dbb80: test   %eax,0x5f7847a(%rip)  /* fun JVM hack */
0x00007fdd859dbb86: dec    %r11                  /* i-- */
0x00007fdd859dbb89: mov    %r11,0x258(%r10)      /* store i to memory */
0x00007fdd859dbb90: test   %r11,%r11             /* unnecessary test */
0x00007fdd859dbb93: jge    0x00007fdd859dbb80    /* go back to the loop top */
******************************
Normalized:
******************************
Original:
0x00007fdd859dbb80: test   %eax,0x5f7847a(%rip)  /* fun JVM hack */
0x00007fdd859dbb86: dec    %r11                  /* i-- */
0x00007fdd859dbb89: mov    %r11,0x258(%r10)      /* store i to memory */
0x00007fdd859dbb90: test   %r11,%r11             /* unnecessary test */
0x00007fdd859dbb93: jge    0x00007fdd859dbb80    /* go back to the loop top */
******************************
Normalized:
0x00007fdd859dbb80: test   %eax,0x5f7847a(%rip)  /* fun JVM hack */
0x00007fdd859dbb86: dec    %r11                  /* i-- */
0x00007fdd859dbb89: mov    %r11,0x258(%r10)      /* store i to memory */
0x00007fdd859dbb90: test   %r11,%r11             /* unnecessary test */
0x00007fdd859dbb93: jge    0x00007fdd859dbb80    /* go back to the loop top */
******************************
Original:
Class&lt;?&gt; driverClass = Class.forName("oracle.jdbc.driver.OracleDriver");
// and
Class&lt;?&gt; stringClass = Class.forName("java.lang.String");
******************************
Normalized:
******************************
Original:
Class&lt;?&gt; driverClass = Class.forName("oracle.jdbc.driver.OracleDriver");
// and
Class&lt;?&gt; stringClass = Class.forName("java.lang.String");
******************************
Normalized:
Class&lt;?&gt; driverClass = Class.forName("oracle.jdbc.driver.OracleDriver");
// and
Class&lt;?&gt; stringClass = Class.forName("java.lang.String");
******************************
Original:
byte b1 = (byte) 129;
String s1 = String.format("%8s", Integer.toBinaryString(b1 &amp; 0xFF)).replace(' ', '0');
System.out.println(s1); // 10000001

byte b2 = (byte) 2;
String s2 = String.format("%8s", Integer.toBinaryString(b2 &amp; 0xFF)).replace(' ', '0');
System.out.println(s2); // 00000010
******************************
Normalized:
******************************
Original:
byte b1 = (byte) 129;
String s1 = String.format("%8s", Integer.toBinaryString(b1 &amp; 0xFF)).replace(' ', '0');
System.out.println(s1); // 10000001

byte b2 = (byte) 2;
String s2 = String.format("%8s", Integer.toBinaryString(b2 &amp; 0xFF)).replace(' ', '0');
System.out.println(s2); // 00000010
******************************
Normalized:
byte b1 = (byte) 129;
String s1 = String.format("%8s", Integer.toBinaryString(b1 &amp; 0xFF)).replace(' ', '0');
System.out.println(s1); // 10000001

byte b2 = (byte) 2;
String s2 = String.format("%8s", Integer.toBinaryString(b2 &amp; 0xFF)).replace(' ', '0');
System.out.println(s2); // 00000010
******************************
Original:
keytool -genkey -noprompt \
 -alias alias1 \
 -dname "CN=mqttserver.ibm.com, OU=ID, O=IBM, L=Hursley, S=Hants, C=GB" \
 -keystore keystore \
 -storepass password \
 -keypass password
******************************
Normalized:
******************************
Original:
keytool -genkey -noprompt \
 -alias alias1 \
 -dname "CN=mqttserver.ibm.com, OU=ID, O=IBM, L=Hursley, S=Hants, C=GB" \
 -keystore keystore \
 -storepass password \
 -keypass password
******************************
Normalized:
keytool -genkey -noprompt \
 -alias alias1 \
 -dname "CN=mqttserver.ibm.com, OU=ID, O=IBM, L=Hursley, S=Hants, C=GB" \
 -keystore keystore \
 -storepass password \
 -keypass password
******************************
Original:
&lt;c:if test="${not theBooleanVariable}"&gt;It's false!&lt;/c:if&gt;
******************************
Normalized:
******************************
Original:
&lt;c:if test="${not theBooleanVariable}"&gt;It's false!&lt;/c:if&gt;
******************************
Normalized:
&lt;c:if test="${not theBooleanVariable}"&gt;It's false!&lt;/c:if&gt;
******************************
Original:
while (condition) { 
  ... 
}
******************************
Normalized:
******************************
Original:
while (condition) { 
  ... 
}
******************************
Normalized:
while (condition) { 
  ... 
}
******************************
Original:
&lt;build&gt;
  &lt;finalName&gt;bird&lt;/finalName&gt;
 . . .
&lt;/build&gt;
******************************
Normalized:
******************************
Original:
&lt;build&gt;
  &lt;finalName&gt;bird&lt;/finalName&gt;
 . . .
&lt;/build&gt;
******************************
Normalized:
&lt;build&gt;
  &lt;finalName&gt;bird&lt;/finalName&gt;
 . . .
&lt;/build&gt;
******************************
Original:
git init
******************************
Normalized:
******************************
Original:
git init
******************************
Normalized:
git init
******************************
Original:
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST"
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST\\;" + 
                  "SET SCHEMA TEST";
String url = "jdbc:h2:mem;" + 
             "INIT=RUNSCRIPT FROM '~/create.sql'\\;" + 
                  "RUNSCRIPT FROM '~/populate.sql'";
******************************
Normalized:
******************************
Original:
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST"
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST\\;" + 
                  "SET SCHEMA TEST";
String url = "jdbc:h2:mem;" + 
             "INIT=RUNSCRIPT FROM '~/create.sql'\\;" + 
                  "RUNSCRIPT FROM '~/populate.sql'";
******************************
Normalized:
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST"
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST\\;" + 
                  "SET SCHEMA TEST";
String url = "jdbc:h2:mem;" + 
             "INIT=RUNSCRIPT FROM '~/create.sql'\\;" + 
                  "RUNSCRIPT FROM '~/populate.sql'";
******************************
Original:
public void testHardCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    for(int i = 0; i &lt; out.length; i++)
    {
        out[i] = bytes[i];
    }
}

public void testArrayCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    System.arraycopy(bytes, 0, out, 0, out.length);
}
******************************
Normalized:
******************************
Original:
public void testHardCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    for(int i = 0; i &lt; out.length; i++)
    {
        out[i] = bytes[i];
    }
}

public void testArrayCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    System.arraycopy(bytes, 0, out, 0, out.length);
}
******************************
Normalized:
public void testHardCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    for(int i = 0; i &lt; out.length; i++)
    {
        out[i] = bytes[i];
    }
}

public void testArrayCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    System.arraycopy(bytes, 0, out, 0, out.length);
}
******************************
Original:
String commaSeparatedNumbers = Arrays.stream(numbers)
    .mapToObj(i -&gt; ((Integer) i).toString()) //i is an int, not an Integer
    .collect(Collectors.joining(", "));
******************************
Normalized:
******************************
Original:
String commaSeparatedNumbers = Arrays.stream(numbers)
    .mapToObj(i -&gt; ((Integer) i).toString()) //i is an int, not an Integer
    .collect(Collectors.joining(", "));
******************************
Normalized:
String commaSeparatedNumbers = Arrays.stream(numbers)
    .mapToObj(i -&gt; ((Integer) i).toString()) //i is an int, not an Integer
    .collect(Collectors.joining(", "));
******************************
Original:
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;



class FloodIsolation {
public:
  FloodIsolation() :
      numberOfCells(20000),
      data(numberOfCells)
  {
  }
  ~FloodIsolation(){
  }

  void isUpdateNeeded() {
    for (int i = 0; i &lt; numberOfCells; ++i) {
       data[i].h = data[i].h + 1;
       data[i].floodedCells = !data[i].floodedCells;
       data[i].floodedCellsTimeInterval = !data[i].floodedCellsTimeInterval;
       data[i].qInflow = data[i].qInflow + 1;
       data[i].qStartTime = data[i].qStartTime + 1;
       data[i].qEndTime = data[i].qEndTime + 1;
       data[i].lowerFloorCells = data[i].lowerFloorCells + 1;
       data[i].cellLocationX = data[i].cellLocationX + 1;
       data[i].cellLocationY = data[i].cellLocationY + 1;
       data[i].cellLocationZ = data[i].cellLocationZ + 1;
       data[i].levelOfCell = data[i].levelOfCell + 1;
       data[i].valueOfCellIds = data[i].valueOfCellIds + 1;
       data[i].h0 = data[i].h0 + 1;
       data[i].vU = data[i].vU + 1;
       data[i].vV = data[i].vV + 1;
       data[i].vUh = data[i].vUh + 1;
       data[i].vVh = data[i].vVh + 1;
       data[i].vUh0 = data[i].vUh0 + 1;
       data[i].vVh0 = data[i].vVh0 + 1;
       data[i].ghh = data[i].ghh + 1;
       data[i].sfx = data[i].sfx + 1;
       data[i].sfy = data[i].sfy + 1;
       data[i].qIn = data[i].qIn + 1;


      for(int j = 0; j &lt; nEdges; ++j) {
        data[i].flagInterface[j] = !data[i].flagInterface[j];
        data[i].typeInterface[j] = data[i].typeInterface[j] + 1;
        data[i].neighborIds[j] = data[i].neighborIds[j] + 1;
      }
    }

  }

private:

  const int numberOfCells;
  static const int nEdges = 6;
  struct data_t {
    bool floodedCells = 0;
    bool floodedCellsTimeInterval = 0;

    double valueOfCellIds = 0;
    double h = 0;

    double h0 = 0;
    double vU = 0;
    double vV = 0;
    double vUh = 0;
    double vVh = 0;
    double vUh0 = 0;
    double vVh0 = 0;
    double ghh = 0;
    double sfx = 0;
    double sfy = 0;
    double qInflow = 0;
    double qStartTime = 0;
    double qEndTime = 0;
    double qIn = 0;
    double nx = 0;
    double ny = 0;
    double floorLevels = 0;
    int lowerFloorCells = 0;
    bool floorCompleteleyFilled = 0;
    double cellLocationX = 0;
    double cellLocationY = 0;
    double cellLocationZ = 0;
    int levelOfCell = 0;
    bool flagInterface[nEdges] = {};
    int typeInterface[nEdges] = {};
    int neighborIds[nEdges] = {};
  };
  std::vector&lt;data_t&gt; data;

};

int main() {
  std::ios_base::sync_with_stdio(false);
  FloodIsolation isolation;
  clock_t start = clock();
  for (int i = 0; i &lt; 400; ++i) {
    if(i % 100 == 0) {
      std::cout &lt;&lt; i &lt;&lt; "\n";
    }
    isolation.isUpdateNeeded();
  }
  clock_t stop = clock();
  std::cout &lt;&lt; "Time: " &lt;&lt; difftime(stop, start) / 1000 &lt;&lt; "\n";
}
******************************
Normalized:
******************************
Original:
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;



class FloodIsolation {
public:
  FloodIsolation() :
      numberOfCells(20000),
      data(numberOfCells)
  {
  }
  ~FloodIsolation(){
  }

  void isUpdateNeeded() {
    for (int i = 0; i &lt; numberOfCells; ++i) {
       data[i].h = data[i].h + 1;
       data[i].floodedCells = !data[i].floodedCells;
       data[i].floodedCellsTimeInterval = !data[i].floodedCellsTimeInterval;
       data[i].qInflow = data[i].qInflow + 1;
       data[i].qStartTime = data[i].qStartTime + 1;
       data[i].qEndTime = data[i].qEndTime + 1;
       data[i].lowerFloorCells = data[i].lowerFloorCells + 1;
       data[i].cellLocationX = data[i].cellLocationX + 1;
       data[i].cellLocationY = data[i].cellLocationY + 1;
       data[i].cellLocationZ = data[i].cellLocationZ + 1;
       data[i].levelOfCell = data[i].levelOfCell + 1;
       data[i].valueOfCellIds = data[i].valueOfCellIds + 1;
       data[i].h0 = data[i].h0 + 1;
       data[i].vU = data[i].vU + 1;
       data[i].vV = data[i].vV + 1;
       data[i].vUh = data[i].vUh + 1;
       data[i].vVh = data[i].vVh + 1;
       data[i].vUh0 = data[i].vUh0 + 1;
       data[i].vVh0 = data[i].vVh0 + 1;
       data[i].ghh = data[i].ghh + 1;
       data[i].sfx = data[i].sfx + 1;
       data[i].sfy = data[i].sfy + 1;
       data[i].qIn = data[i].qIn + 1;


      for(int j = 0; j &lt; nEdges; ++j) {
        data[i].flagInterface[j] = !data[i].flagInterface[j];
        data[i].typeInterface[j] = data[i].typeInterface[j] + 1;
        data[i].neighborIds[j] = data[i].neighborIds[j] + 1;
      }
    }

  }

private:

  const int numberOfCells;
  static const int nEdges = 6;
  struct data_t {
    bool floodedCells = 0;
    bool floodedCellsTimeInterval = 0;

    double valueOfCellIds = 0;
    double h = 0;

    double h0 = 0;
    double vU = 0;
    double vV = 0;
    double vUh = 0;
    double vVh = 0;
    double vUh0 = 0;
    double vVh0 = 0;
    double ghh = 0;
    double sfx = 0;
    double sfy = 0;
    double qInflow = 0;
    double qStartTime = 0;
    double qEndTime = 0;
    double qIn = 0;
    double nx = 0;
    double ny = 0;
    double floorLevels = 0;
    int lowerFloorCells = 0;
    bool floorCompleteleyFilled = 0;
    double cellLocationX = 0;
    double cellLocationY = 0;
    double cellLocationZ = 0;
    int levelOfCell = 0;
    bool flagInterface[nEdges] = {};
    int typeInterface[nEdges] = {};
    int neighborIds[nEdges] = {};
  };
  std::vector&lt;data_t&gt; data;

};

int main() {
  std::ios_base::sync_with_stdio(false);
  FloodIsolation isolation;
  clock_t start = clock();
  for (int i = 0; i &lt; 400; ++i) {
    if(i % 100 == 0) {
      std::cout &lt;&lt; i &lt;&lt; "\n";
    }
    isolation.isUpdateNeeded();
  }
  clock_t stop = clock();
  std::cout &lt;&lt; "Time: " &lt;&lt; difftime(stop, start) / 1000 &lt;&lt; "\n";
}
******************************
Normalized:
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;



class FloodIsolation {
public:
  FloodIsolation() :
      numberOfCells(20000),
      data(numberOfCells)
  {
  }
  ~FloodIsolation(){
  }

  void isUpdateNeeded() {
    for (int i = 0; i &lt; numberOfCells; ++i) {
       data[i].h = data[i].h + 1;
       data[i].floodedCells = !data[i].floodedCells;
       data[i].floodedCellsTimeInterval = !data[i].floodedCellsTimeInterval;
       data[i].qInflow = data[i].qInflow + 1;
       data[i].qStartTime = data[i].qStartTime + 1;
       data[i].qEndTime = data[i].qEndTime + 1;
       data[i].lowerFloorCells = data[i].lowerFloorCells + 1;
       data[i].cellLocationX = data[i].cellLocationX + 1;
       data[i].cellLocationY = data[i].cellLocationY + 1;
       data[i].cellLocationZ = data[i].cellLocationZ + 1;
       data[i].levelOfCell = data[i].levelOfCell + 1;
       data[i].valueOfCellIds = data[i].valueOfCellIds + 1;
       data[i].h0 = data[i].h0 + 1;
       data[i].vU = data[i].vU + 1;
       data[i].vV = data[i].vV + 1;
       data[i].vUh = data[i].vUh + 1;
       data[i].vVh = data[i].vVh + 1;
       data[i].vUh0 = data[i].vUh0 + 1;
       data[i].vVh0 = data[i].vVh0 + 1;
       data[i].ghh = data[i].ghh + 1;
       data[i].sfx = data[i].sfx + 1;
       data[i].sfy = data[i].sfy + 1;
       data[i].qIn = data[i].qIn + 1;


      for(int j = 0; j &lt; nEdges; ++j) {
        data[i].flagInterface[j] = !data[i].flagInterface[j];
        data[i].typeInterface[j] = data[i].typeInterface[j] + 1;
        data[i].neighborIds[j] = data[i].neighborIds[j] + 1;
      }
    }

  }

private:

  const int numberOfCells;
  static const int nEdges = 6;
  struct data_t {
    bool floodedCells = 0;
    bool floodedCellsTimeInterval = 0;

    double valueOfCellIds = 0;
    double h = 0;

    double h0 = 0;
    double vU = 0;
    double vV = 0;
    double vUh = 0;
    double vVh = 0;
    double vUh0 = 0;
    double vVh0 = 0;
    double ghh = 0;
    double sfx = 0;
    double sfy = 0;
    double qInflow = 0;
    double qStartTime = 0;
    double qEndTime = 0;
    double qIn = 0;
    double nx = 0;
    double ny = 0;
    double floorLevels = 0;
    int lowerFloorCells = 0;
    bool floorCompleteleyFilled = 0;
    double cellLocationX = 0;
    double cellLocationY = 0;
    double cellLocationZ = 0;
    int levelOfCell = 0;
    bool flagInterface[nEdges] = {};
    int typeInterface[nEdges] = {};
    int neighborIds[nEdges] = {};
  };
  std::vector&lt;data_t&gt; data;

};

int main() {
  std::ios_base::sync_with_stdio(false);
  FloodIsolation isolation;
  clock_t start = clock();
  for (int i = 0; i &lt; 400; ++i) {
    if(i % 100 == 0) {
      std::cout &lt;&lt; i &lt;&lt; "\n";
    }
    isolation.isUpdateNeeded();
  }
  clock_t stop = clock();
  std::cout &lt;&lt; "Time: " &lt;&lt; difftime(stop, start) / 1000 &lt;&lt; "\n";
}
******************************
Original:
private static &lt;T&gt; Stream&lt;T&gt; nonEmptyStream(
    Stream&lt;T&gt; stream, Supplier&lt;RuntimeException&gt; e) {

    Spliterator&lt;T&gt; it=stream.spliterator();
    return StreamSupport.stream(new Spliterator&lt;T&gt;() {
        boolean seen;
        public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
            boolean r=it.tryAdvance(action);
            if(!seen &amp;&amp; !r) throw e.get();
            seen=true;
            return r;
        }
        public Spliterator&lt;T&gt; trySplit() { return null; }
        public long estimateSize() { return it.estimateSize(); }
        public int characteristics() { return it.characteristics(); }
    }, false);
}
******************************
Normalized:
******************************
Original:
private static &lt;T&gt; Stream&lt;T&gt; nonEmptyStream(
    Stream&lt;T&gt; stream, Supplier&lt;RuntimeException&gt; e) {

    Spliterator&lt;T&gt; it=stream.spliterator();
    return StreamSupport.stream(new Spliterator&lt;T&gt;() {
        boolean seen;
        public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
            boolean r=it.tryAdvance(action);
            if(!seen &amp;&amp; !r) throw e.get();
            seen=true;
            return r;
        }
        public Spliterator&lt;T&gt; trySplit() { return null; }
        public long estimateSize() { return it.estimateSize(); }
        public int characteristics() { return it.characteristics(); }
    }, false);
}
******************************
Normalized:
private static &lt;T&gt; Stream&lt;T&gt; nonEmptyStream(
    Stream&lt;T&gt; stream, Supplier&lt;RuntimeException&gt; e) {

    Spliterator&lt;T&gt; it=stream.spliterator();
    return StreamSupport.stream(new Spliterator&lt;T&gt;() {
        boolean seen;
        public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
            boolean r=it.tryAdvance(action);
            if(!seen &amp;&amp; !r) throw e.get();
            seen=true;
            return r;
        }
        public Spliterator&lt;T&gt; trySplit() { return null; }
        public long estimateSize() { return it.estimateSize(); }
        public int characteristics() { return it.characteristics(); }
    }, false);
}
******************************
Original:
^[1-9]\d*$
******************************
Normalized:
******************************
Original:
^[1-9]\d*$
******************************
Normalized:
^[1-9]\d*$
******************************
Original:
&lt;Button
        android:id="@+id/header"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="@string/test"
        android:textColor="@color/black"
        android:minHeight="40dip"/&gt;


&lt;style name="Widget.Holo.Button" parent="Widget.Button"&gt;
    &lt;item name="android:background"&gt;@android:drawable/btn_default_holo_dark&lt;/item&gt;
    &lt;item name="android:textAppearance"&gt;?android:attr/textAppearanceMedium&lt;/item&gt;
    &lt;item name="android:textColor"&gt;@android:color/primary_text_holo_dark&lt;/item&gt;
    &lt;item name="android:minHeight"&gt;48dip&lt;/item&gt;
    &lt;item name="android:minWidth"&gt;64dip&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
******************************
Original:
&lt;Button
        android:id="@+id/header"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="@string/test"
        android:textColor="@color/black"
        android:minHeight="40dip"/&gt;


&lt;style name="Widget.Holo.Button" parent="Widget.Button"&gt;
    &lt;item name="android:background"&gt;@android:drawable/btn_default_holo_dark&lt;/item&gt;
    &lt;item name="android:textAppearance"&gt;?android:attr/textAppearanceMedium&lt;/item&gt;
    &lt;item name="android:textColor"&gt;@android:color/primary_text_holo_dark&lt;/item&gt;
    &lt;item name="android:minHeight"&gt;48dip&lt;/item&gt;
    &lt;item name="android:minWidth"&gt;64dip&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
&lt;Button
        android:id="@+id/header"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="@string/test"
        android:textColor="@color/black"
        android:minHeight="40dip"/&gt;


&lt;style name="Widget.Holo.Button" parent="Widget.Button"&gt;
    &lt;item name="android:background"&gt;@android:drawable/btn_default_holo_dark&lt;/item&gt;
    &lt;item name="android:textAppearance"&gt;?android:attr/textAppearanceMedium&lt;/item&gt;
    &lt;item name="android:textColor"&gt;@android:color/primary_text_holo_dark&lt;/item&gt;
    &lt;item name="android:minHeight"&gt;48dip&lt;/item&gt;
    &lt;item name="android:minWidth"&gt;64dip&lt;/item&gt;
&lt;/style&gt;
******************************
Original:
private ArrayList&lt;String&gt; _categories; // Initialize all this stuff

private int getCategoryPos(String category) {
  return _categories.indexOf(category);
}
******************************
Normalized:
******************************
Original:
private ArrayList&lt;String&gt; _categories; // Initialize all this stuff

private int getCategoryPos(String category) {
  return _categories.indexOf(category);
}
******************************
Normalized:
private ArrayList&lt;String&gt; _categories; // Initialize all this stuff

private int getCategoryPos(String category) {
  return _categories.indexOf(category);
}
******************************
Original:
@RequestMapping(value="/orders", method=RequestMethod.GET)
@ResponseBody
public List&lt;Account&gt; accountSummary() {
    return accountManager.getAllAccounts();
}
******************************
Normalized:
******************************
Original:
@RequestMapping(value="/orders", method=RequestMethod.GET)
@ResponseBody
public List&lt;Account&gt; accountSummary() {
    return accountManager.getAllAccounts();
}
******************************
Normalized:
@RequestMapping(value="/orders", method=RequestMethod.GET)
@ResponseBody
public List&lt;Account&gt; accountSummary() {
    return accountManager.getAllAccounts();
}
******************************
Original:
JSONArray jsonarray = new JSONArray(jsonStr);
for (int i = 0; i &lt; jsonarray.length(); i++) {
    JSONObject jsonobject = jsonarray.getJSONObject(i);
    String name = jsonobject.getString("name");
    String url = jsonobject.getString("url");
}
******************************
Normalized:
******************************
Original:
JSONArray jsonarray = new JSONArray(jsonStr);
for (int i = 0; i &lt; jsonarray.length(); i++) {
    JSONObject jsonobject = jsonarray.getJSONObject(i);
    String name = jsonobject.getString("name");
    String url = jsonobject.getString("url");
}
******************************
Normalized:
JSONArray jsonarray = new JSONArray(jsonStr);
for (int i = 0; i &lt; jsonarray.length(); i++) {
    JSONObject jsonobject = jsonarray.getJSONObject(i);
    String name = jsonobject.getString("name");
    String url = jsonobject.getString("url");
}
******************************
Original:
@Entity
@NamedEntityGraph(name = "GroupInfo.detail",
  attributeNodes = @NamedAttributeNode("members"))
public class GroupInfo {

  // default fetch mode is lazy.
  @ManyToMany
  List&lt;GroupMember&gt; members = new ArrayList&lt;GroupMember&gt;();

  …
}

@Repository
public interface GroupRepository extends CrudRepository&lt;GroupInfo, String&gt; {

  @EntityGraph(value = "GroupInfo.detail", type = EntityGraphType.LOAD)
  GroupInfo getByGroupName(String name);

}
******************************
Normalized:
******************************
Original:
@Entity
@NamedEntityGraph(name = "GroupInfo.detail",
  attributeNodes = @NamedAttributeNode("members"))
public class GroupInfo {

  // default fetch mode is lazy.
  @ManyToMany
  List&lt;GroupMember&gt; members = new ArrayList&lt;GroupMember&gt;();

  …
}

@Repository
public interface GroupRepository extends CrudRepository&lt;GroupInfo, String&gt; {

  @EntityGraph(value = "GroupInfo.detail", type = EntityGraphType.LOAD)
  GroupInfo getByGroupName(String name);

}
******************************
Normalized:
@Entity
@NamedEntityGraph(name = "GroupInfo.detail",
  attributeNodes = @NamedAttributeNode("members"))
public class GroupInfo {

  // default fetch mode is lazy.
  @ManyToMany
  List&lt;GroupMember&gt; members = new ArrayList&lt;GroupMember&gt;();

  …
}

@Repository
public interface GroupRepository extends CrudRepository&lt;GroupInfo, String&gt; {

  @EntityGraph(value = "GroupInfo.detail", type = EntityGraphType.LOAD)
  GroupInfo getByGroupName(String name);

}
******************************
Original:
open -a /Applications/IntelliJ\ IDEA\ 12.app/
******************************
Normalized:
******************************
Original:
open -a /Applications/IntelliJ\ IDEA\ 12.app/
******************************
Normalized:
open -a /Applications/IntelliJ\ IDEA\ 12.app/
******************************
Original:
String brandName;

@JsonProperty("brand")
private void unpackNameFromNestedObject(Map&lt;String, String&gt; brand) {
    brandName = brand.get("name");
}
******************************
Normalized:
******************************
Original:
String brandName;

@JsonProperty("brand")
private void unpackNameFromNestedObject(Map&lt;String, String&gt; brand) {
    brandName = brand.get("name");
}
******************************
Normalized:
String brandName;

@JsonProperty("brand")
private void unpackNameFromNestedObject(Map&lt;String, String&gt; brand) {
    brandName = brand.get("name");
}
******************************
Original:
d = D()          // these four computations can happen in any order
b = B()
c = C()
a = A()
sum = a + b      // these two computations can happen in any order
product = c * d
result = sum + product // this has to happen last
******************************
Normalized:
******************************
Original:
d = D()          // these four computations can happen in any order
b = B()
c = C()
a = A()
sum = a + b      // these two computations can happen in any order
product = c * d
result = sum + product // this has to happen last
******************************
Normalized:
d = D()          // these four computations can happen in any order
b = B()
c = C()
a = A()
sum = a + b      // these two computations can happen in any order
product = c * d
result = sum + product // this has to happen last
******************************
Original:
List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
******************************
Normalized:
******************************
Original:
List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
******************************
Normalized:
List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
******************************
Original:
@JsonDeserialize(builder = Address.Builder.class)
******************************
Normalized:
******************************
Original:
@JsonDeserialize(builder = Address.Builder.class)
******************************
Normalized:
@JsonDeserialize(builder = Address.Builder.class)
******************************
Original:
OctalEscape:
    \ OctalDigit
    \ OctalDigit OctalDigit
    \ ZeroToThree OctalDigit OctalDigit

OctalDigit: one of
    0 1 2 3 4 5 6 7

ZeroToThree: one of
    0 1 2 3
******************************
Normalized:
******************************
Original:
OctalEscape:
    \ OctalDigit
    \ OctalDigit OctalDigit
    \ ZeroToThree OctalDigit OctalDigit

OctalDigit: one of
    0 1 2 3 4 5 6 7

ZeroToThree: one of
    0 1 2 3
******************************
Normalized:
OctalEscape:
    \ OctalDigit
    \ OctalDigit OctalDigit
    \ ZeroToThree OctalDigit OctalDigit

OctalDigit: one of
    0 1 2 3 4 5 6 7

ZeroToThree: one of
    0 1 2 3
******************************
Original:
Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full. Compiler has been disabled.
Java HotSpot(TM) 64-Bit Server VM warning: Try increasing the code cache size using -XX:ReservedCodeCacheSize=
Code Cache  [0x000000010958f000, 0x000000010c52f000, 0x000000010c58f000)
 total_blobs=15406 nmethods=14989 adapters=362 free_code_cache=835Kb largest_free_block=449792
******************************
Normalized:
******************************
Original:
Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full. Compiler has been disabled.
Java HotSpot(TM) 64-Bit Server VM warning: Try increasing the code cache size using -XX:ReservedCodeCacheSize=
Code Cache  [0x000000010958f000, 0x000000010c52f000, 0x000000010c58f000)
 total_blobs=15406 nmethods=14989 adapters=362 free_code_cache=835Kb largest_free_block=449792
******************************
Normalized:
Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full. Compiler has been disabled.
Java HotSpot(TM) 64-Bit Server VM warning: Try increasing the code cache size using -XX:ReservedCodeCacheSize=
Code Cache  [0x000000010958f000, 0x000000010c52f000, 0x000000010c58f000)
 total_blobs=15406 nmethods=14989 adapters=362 free_code_cache=835Kb largest_free_block=449792
******************************
Original:
import static java.lang.Math.abs;

public static long roundUp(long num, long divisor) {
    int sign = (num &gt; 0 ? 1 : -1) * (divisor &gt; 0 ? 1 : -1);
    return sign * (abs(num) + abs(divisor) - 1) / abs(divisor);
}
******************************
Normalized:
******************************
Original:
import static java.lang.Math.abs;

public static long roundUp(long num, long divisor) {
    int sign = (num &gt; 0 ? 1 : -1) * (divisor &gt; 0 ? 1 : -1);
    return sign * (abs(num) + abs(divisor) - 1) / abs(divisor);
}
******************************
Normalized:
import static java.lang.Math.abs;

public static long roundUp(long num, long divisor) {
    int sign = (num &gt; 0 ? 1 : -1) * (divisor &gt; 0 ? 1 : -1);
    return sign * (abs(num) + abs(divisor) - 1) / abs(divisor);
}
******************************
Original:
&lt;http&gt;    
    &lt;headers&gt;
        &lt;frame-options policy="SAMEORIGIN"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;
******************************
Normalized:
******************************
Original:
&lt;http&gt;    
    &lt;headers&gt;
        &lt;frame-options policy="SAMEORIGIN"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;
******************************
Normalized:
&lt;http&gt;    
    &lt;headers&gt;
        &lt;frame-options policy="SAMEORIGIN"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;
******************************
Original:
n      0000100...000
-n      1111100...000
 n &amp; -n 0000100...000
******************************
Normalized:
******************************
Original:
n      0000100...000
-n      1111100...000
 n &amp; -n 0000100...000
******************************
Normalized:
n      0000100...000
-n      1111100...000
 n &amp; -n 0000100...000
******************************
Original:
FileOutputStream(File file, boolean append)
******************************
Normalized:
******************************
Original:
FileOutputStream(File file, boolean append)
******************************
Normalized:
FileOutputStream(File file, boolean append)
******************************
Original:
List&lt;Integer&gt; x = new ArrayList&lt;Integer&gt;();
x.add(1);
x.add(2);
******************************
Normalized:
******************************
Original:
List&lt;Integer&gt; x = new ArrayList&lt;Integer&gt;();
x.add(1);
x.add(2);
******************************
Normalized:
List&lt;Integer&gt; x = new ArrayList&lt;Integer&gt;();
x.add(1);
x.add(2);
******************************
Original:
import javax.swing.JOptionPane;
import javax.swing.JFrame;

/*Some piece of code*/
frame.addWindowListener(new java.awt.event.WindowAdapter() {
    @Override
    public void windowClosing(java.awt.event.WindowEvent windowEvent) {
        if (JOptionPane.showConfirmDialog(frame, 
            "Are you sure you want to close this window?", "Close Window?", 
            JOptionPane.YES_NO_OPTION,
            JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION){
            System.exit(0);
        }
    }
});
******************************
Normalized:
******************************
Original:
import javax.swing.JOptionPane;
import javax.swing.JFrame;

/*Some piece of code*/
frame.addWindowListener(new java.awt.event.WindowAdapter() {
    @Override
    public void windowClosing(java.awt.event.WindowEvent windowEvent) {
        if (JOptionPane.showConfirmDialog(frame, 
            "Are you sure you want to close this window?", "Close Window?", 
            JOptionPane.YES_NO_OPTION,
            JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION){
            System.exit(0);
        }
    }
});
******************************
Normalized:
import javax.swing.JOptionPane;
import javax.swing.JFrame;

/*Some piece of code*/
frame.addWindowListener(new java.awt.event.WindowAdapter() {
    @Override
    public void windowClosing(java.awt.event.WindowEvent windowEvent) {
        if (JOptionPane.showConfirmDialog(frame, 
            "Are you sure you want to close this window?", "Close Window?", 
            JOptionPane.YES_NO_OPTION,
            JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION){
            System.exit(0);
        }
    }
});
******************************
Original:
public class RealPayment implements Payment {
   @Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      @Assisted Date startDate,
      @Assisted Money amount) {
     ...
   }
 }
******************************
Normalized:
******************************
Original:
public class RealPayment implements Payment {
   @Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      @Assisted Date startDate,
      @Assisted Money amount) {
     ...
   }
 }
******************************
Normalized:
public class RealPayment implements Payment {
   @Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      @Assisted Date startDate,
      @Assisted Money amount) {
     ...
   }
 }
******************************
Original:
public class Test {
    public static void main(String[] args) {
        int x;
        if (args.length &gt; 0) {
            x = 1;
        } else {
            x = 2;
        }
    }

    public static void main2(String[] args) {
        int x = (args.length &gt; 0) ? 1 : 2;
    }
}
******************************
Normalized:
******************************
Original:
public class Test {
    public static void main(String[] args) {
        int x;
        if (args.length &gt; 0) {
            x = 1;
        } else {
            x = 2;
        }
    }

    public static void main2(String[] args) {
        int x = (args.length &gt; 0) ? 1 : 2;
    }
}
******************************
Normalized:
public class Test {
    public static void main(String[] args) {
        int x;
        if (args.length &gt; 0) {
            x = 1;
        } else {
            x = 2;
        }
    }

    public static void main2(String[] args) {
        int x = (args.length &gt; 0) ? 1 : 2;
    }
}
******************************
Original:
@ComponentScan({"com.my.package.first","com.my.package.second"})
******************************
Normalized:
******************************
Original:
@ComponentScan({"com.my.package.first","com.my.package.second"})
******************************
Normalized:
@ComponentScan({"com.my.package.first","com.my.package.second"})
******************************
Original:
public class Foo&lt;T&gt; 
{
    private Class&lt;T&gt; type;

    public Foo(Class&lt;T&gt; type) { this.type = type; } 
}
******************************
Normalized:
******************************
Original:
public class Foo&lt;T&gt; 
{
    private Class&lt;T&gt; type;

    public Foo(Class&lt;T&gt; type) { this.type = type; } 
}
******************************
Normalized:
public class Foo&lt;T&gt; 
{
    private Class&lt;T&gt; type;

    public Foo(Class&lt;T&gt; type) { this.type = type; } 
}
******************************
Original:
while (true) {
    ....
    if (obj == null) {
        break;
    }
    ....
}
******************************
Normalized:
******************************
Original:
while (true) {
    ....
    if (obj == null) {
        break;
    }
    ....
}
******************************
Normalized:
while (true) {
    ....
    if (obj == null) {
        break;
    }
    ....
}
******************************
Original:
javac dir1/*.java dir2/*.java dir3/dir4/*.java dir3/dir5/*.java dir6/*src/*.java
******************************
Normalized:
******************************
Original:
javac dir1/*.java dir2/*.java dir3/dir4/*.java dir3/dir5/*.java dir6/*src/*.java
******************************
Normalized:
javac dir1/*.java dir2/*.java dir3/dir4/*.java dir3/dir5/*.java dir6/*src/*.java
******************************
Original:
public class Demo {
  private int num = 0;
  /**
  * Access field {@link Demo#num} / {@link #num}  ...
  */
  private void foo() { ... }
...
******************************
Normalized:
******************************
Original:
public class Demo {
  private int num = 0;
  /**
  * Access field {@link Demo#num} / {@link #num}  ...
  */
  private void foo() { ... }
...
******************************
Normalized:
public class Demo {
  private int num = 0;
  /**
  * Access field {@link Demo#num} / {@link #num}  ...
  */
  private void foo() { ... }
...
******************************
Original:
java -XshowSettings:properties -version
******************************
Normalized:
******************************
Original:
java -XshowSettings:properties -version
******************************
Normalized:
java -XshowSettings:properties -version
******************************
Original:
public static &lt;T&gt; T isNull(Class&lt;T&gt; clazz)
******************************
Normalized:
******************************
Original:
public static &lt;T&gt; T isNull(Class&lt;T&gt; clazz)
******************************
Normalized:
public static &lt;T&gt; T isNull(Class&lt;T&gt; clazz)
******************************
Original:
1011 = -3
0011 = +3
******************************
Normalized:
******************************
Original:
1011 = -3
0011 = +3
******************************
Normalized:
1011 = -3
0011 = +3
******************************
Original:
final List&lt;MyObject&gt; list = query.list();
******************************
Normalized:
******************************
Original:
final List&lt;MyObject&gt; list = query.list();
******************************
Normalized:
final List&lt;MyObject&gt; list = query.list();
******************************
Original:
val handler = Handler&lt;String&gt; { println("Hello: $it")}
******************************
Normalized:
******************************
Original:
val handler = Handler&lt;String&gt; { println("Hello: $it")}
******************************
Normalized:
val handler = Handler&lt;String&gt; { println("Hello: $it")}
******************************
Original:
&lt;style name="MyMaterialTheme" parent="MyMaterialTheme.Base"&gt;

&lt;/style&gt;

&lt;style name="MyMaterialTheme.Base" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;
    &lt;item name="windowActionBar"&gt;false&lt;/item&gt;
    &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name="drawerArrowStyle"&gt;@style/DrawerArrowStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="DrawerArrowStyle" parent="@style/Widget.AppCompat.DrawerArrowToggle"&gt;
    &lt;item name="spinBars"&gt;true&lt;/item&gt;
    &lt;item name="color"&gt;@android:color/black&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
******************************
Original:
&lt;style name="MyMaterialTheme" parent="MyMaterialTheme.Base"&gt;

&lt;/style&gt;

&lt;style name="MyMaterialTheme.Base" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;
    &lt;item name="windowActionBar"&gt;false&lt;/item&gt;
    &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name="drawerArrowStyle"&gt;@style/DrawerArrowStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="DrawerArrowStyle" parent="@style/Widget.AppCompat.DrawerArrowToggle"&gt;
    &lt;item name="spinBars"&gt;true&lt;/item&gt;
    &lt;item name="color"&gt;@android:color/black&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
&lt;style name="MyMaterialTheme" parent="MyMaterialTheme.Base"&gt;

&lt;/style&gt;

&lt;style name="MyMaterialTheme.Base" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;
    &lt;item name="windowActionBar"&gt;false&lt;/item&gt;
    &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name="drawerArrowStyle"&gt;@style/DrawerArrowStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="DrawerArrowStyle" parent="@style/Widget.AppCompat.DrawerArrowToggle"&gt;
    &lt;item name="spinBars"&gt;true&lt;/item&gt;
    &lt;item name="color"&gt;@android:color/black&lt;/item&gt;
&lt;/style&gt;
******************************
Original:
Gson gson = new Gson();
String jsonOutput = "Your JSON String";
Type listType = new TypeToken&lt;List&lt;Post&gt;&gt;(){}.getType();
List&lt;Post&gt; posts = gson.fromJson(jsonOutput, listType);
******************************
Normalized:
******************************
Original:
Gson gson = new Gson();
String jsonOutput = "Your JSON String";
Type listType = new TypeToken&lt;List&lt;Post&gt;&gt;(){}.getType();
List&lt;Post&gt; posts = gson.fromJson(jsonOutput, listType);
******************************
Normalized:
Gson gson = new Gson();
String jsonOutput = "Your JSON String";
Type listType = new TypeToken&lt;List&lt;Post&gt;&gt;(){}.getType();
List&lt;Post&gt; posts = gson.fromJson(jsonOutput, listType);
******************************
Original:
&lt;%@ page pageEncoding="UTF-8" %&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;
&lt;c:set var="language" value="${not empty param.language ? param.language : not empty language ? language : pageContext.request.locale}" scope="session" /&gt;
&lt;fmt:setLocale value="${language}" /&gt;
&lt;fmt:setBundle basename="com.example.i18n.text" /&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="${language}"&gt;
    &lt;head&gt;
        &lt;title&gt;JSP/JSTL i18n demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form&gt;
            &lt;select id="language" name="language" onchange="submit()"&gt;
                &lt;option value="en" ${language == 'en' ? 'selected' : ''}&gt;English&lt;/option&gt;
                &lt;option value="nl" ${language == 'nl' ? 'selected' : ''}&gt;Nederlands&lt;/option&gt;
                &lt;option value="es" ${language == 'es' ? 'selected' : ''}&gt;Español&lt;/option&gt;
            &lt;/select&gt;
        &lt;/form&gt;
        &lt;form method="post"&gt;
            &lt;label for="username"&gt;&lt;fmt:message key="login.label.username" /&gt;:&lt;/label&gt;
            &lt;input type="text" id="username" name="username"&gt;
            &lt;br&gt;
            &lt;label for="password"&gt;&lt;fmt:message key="login.label.password" /&gt;:&lt;/label&gt;
            &lt;input type="password" id="password" name="password"&gt;
            &lt;br&gt;
            &lt;fmt:message key="login.button.submit" var="buttonValue" /&gt;
            &lt;input type="submit" name="submit" value="${buttonValue}"&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
******************************
Normalized:
******************************
Original:
&lt;%@ page pageEncoding="UTF-8" %&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;
&lt;c:set var="language" value="${not empty param.language ? param.language : not empty language ? language : pageContext.request.locale}" scope="session" /&gt;
&lt;fmt:setLocale value="${language}" /&gt;
&lt;fmt:setBundle basename="com.example.i18n.text" /&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="${language}"&gt;
    &lt;head&gt;
        &lt;title&gt;JSP/JSTL i18n demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form&gt;
            &lt;select id="language" name="language" onchange="submit()"&gt;
                &lt;option value="en" ${language == 'en' ? 'selected' : ''}&gt;English&lt;/option&gt;
                &lt;option value="nl" ${language == 'nl' ? 'selected' : ''}&gt;Nederlands&lt;/option&gt;
                &lt;option value="es" ${language == 'es' ? 'selected' : ''}&gt;Español&lt;/option&gt;
            &lt;/select&gt;
        &lt;/form&gt;
        &lt;form method="post"&gt;
            &lt;label for="username"&gt;&lt;fmt:message key="login.label.username" /&gt;:&lt;/label&gt;
            &lt;input type="text" id="username" name="username"&gt;
            &lt;br&gt;
            &lt;label for="password"&gt;&lt;fmt:message key="login.label.password" /&gt;:&lt;/label&gt;
            &lt;input type="password" id="password" name="password"&gt;
            &lt;br&gt;
            &lt;fmt:message key="login.button.submit" var="buttonValue" /&gt;
            &lt;input type="submit" name="submit" value="${buttonValue}"&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
******************************
Normalized:
&lt;%@ page pageEncoding="UTF-8" %&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;
&lt;c:set var="language" value="${not empty param.language ? param.language : not empty language ? language : pageContext.request.locale}" scope="session" /&gt;
&lt;fmt:setLocale value="${language}" /&gt;
&lt;fmt:setBundle basename="com.example.i18n.text" /&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="${language}"&gt;
    &lt;head&gt;
        &lt;title&gt;JSP/JSTL i18n demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form&gt;
            &lt;select id="language" name="language" onchange="submit()"&gt;
                &lt;option value="en" ${language == 'en' ? 'selected' : ''}&gt;English&lt;/option&gt;
                &lt;option value="nl" ${language == 'nl' ? 'selected' : ''}&gt;Nederlands&lt;/option&gt;
                &lt;option value="es" ${language == 'es' ? 'selected' : ''}&gt;Español&lt;/option&gt;
            &lt;/select&gt;
        &lt;/form&gt;
        &lt;form method="post"&gt;
            &lt;label for="username"&gt;&lt;fmt:message key="login.label.username" /&gt;:&lt;/label&gt;
            &lt;input type="text" id="username" name="username"&gt;
            &lt;br&gt;
            &lt;label for="password"&gt;&lt;fmt:message key="login.label.password" /&gt;:&lt;/label&gt;
            &lt;input type="password" id="password" name="password"&gt;
            &lt;br&gt;
            &lt;fmt:message key="login.button.submit" var="buttonValue" /&gt;
            &lt;input type="submit" name="submit" value="${buttonValue}"&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
******************************
Original:
for (int i = 0; i &lt; size; i++)
   a += b;
   System.out.println("foo");
******************************
Normalized:
******************************
Original:
for (int i = 0; i &lt; size; i++)
   a += b;
   System.out.println("foo");
******************************
Normalized:
for (int i = 0; i &lt; size; i++)
   a += b;
   System.out.println("foo");
******************************
Original:
myObject = new ArrayList&lt;Object&gt;(myTempObject);
******************************
Normalized:
******************************
Original:
myObject = new ArrayList&lt;Object&gt;(myTempObject);
******************************
Normalized:
myObject = new ArrayList&lt;Object&gt;(myTempObject);
******************************
Original:
public class Utilities {

    private class SolarCalendar {

        public String strWeekDay = "";
        public String strMonth = "";

        int date;
        int month;
        int year;

        public SolarCalendar()
        {
            Date MiladiDate = new Date();
            calcSolarCalendar(MiladiDate);
        }

        public SolarCalendar(Date MiladiDate)
        {
            calcSolarCalendar(MiladiDate);
        }

        private void calcSolarCalendar(Date MiladiDate) {

            int ld;

            int miladiYear = MiladiDate.getYear() + 1900;
            int miladiMonth = MiladiDate.getMonth() + 1;
            int miladiDate = MiladiDate.getDate();
            int WeekDay = MiladiDate.getDay();

            int[] buf1 = new int[12];
            int[] buf2 = new int[12];

            buf1[0] = 0;
            buf1[1] = 31;
            buf1[2] = 59;
            buf1[3] = 90;
            buf1[4] = 120;
            buf1[5] = 151;
            buf1[6] = 181;
            buf1[7] = 212;
            buf1[8] = 243;
            buf1[9] = 273;
            buf1[10] = 304;
            buf1[11] = 334;

            buf2[0] = 0;
            buf2[1] = 31;
            buf2[2] = 60;
            buf2[3] = 91;
            buf2[4] = 121;
            buf2[5] = 152;
            buf2[6] = 182;
            buf2[7] = 213;
            buf2[8] = 244;
            buf2[9] = 274;
            buf2[10] = 305;
            buf2[11] = 335;

            if ((miladiYear % 4) != 0) {
                date = buf1[miladiMonth - 1] + miladiDate;

                if (date &gt; 79) {
                    date = date - 79;
                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = date / 31;
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                } else {
                    if ((miladiYear &gt; 1996) &amp;&amp; (miladiYear % 4) == 1) {
                        ld = 11;
                    } else {
                        ld = 10;
                    }
                    date = date + ld;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }
            } else {
                date = buf2[miladiMonth - 1] + miladiDate;

                if (miladiYear &gt;= 1996) {
                    ld = 79;
                } else {
                    ld = 80;
                }
                if (date &gt; ld) {
                    date = date - ld;

                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = (date / 31);
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                }

                else {
                    date = date + 10;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }

            }

            switch (month) {
            case 1:
                strMonth = "فروردين";
                break;
            case 2:
                strMonth = "ارديبهشت";
                break;
            case 3:
                strMonth = "خرداد";
                break;
            case 4:
                strMonth = "تير";
                break;
            case 5:
                strMonth = "مرداد";
                break;
            case 6:
                strMonth = "شهريور";
                break;
            case 7:
                strMonth = "مهر";
                break;
            case 8:
                strMonth = "آبان";
                break;
            case 9:
                strMonth = "آذر";
                break;
            case 10:
                strMonth = "دي";
                break;
            case 11:
                strMonth = "بهمن";
                break;
            case 12:
                strMonth = "اسفند";
                break;
            }

            switch (WeekDay) {

            case 0:
                strWeekDay = "يکشنبه";
                break;
            case 1:
                strWeekDay = "دوشنبه";
                break;
            case 2:
                strWeekDay = "سه شنبه";
                break;
            case 3:
                strWeekDay = "چهارشنبه";
                break;
            case 4:
                strWeekDay = "پنج شنبه";
                break;
            case 5:
                strWeekDay = "جمعه";
                break;
            case 6:
                strWeekDay = "شنبه";
                break;
            }

        }

    }

    public static String getCurrentShamsidate() {
        Locale loc = new Locale("en_US");
        Utilities util = new Utilities();
        SolarCalendar sc = util.new SolarCalendar();
        return String.valueOf(sc.year) + "/" + String.format(loc, "%02d",
                sc.month) + "/" + String.format(loc, "%02d", sc.date);
    }
}
******************************
Normalized:
******************************
Original:
public class Utilities {

    private class SolarCalendar {

        public String strWeekDay = "";
        public String strMonth = "";

        int date;
        int month;
        int year;

        public SolarCalendar()
        {
            Date MiladiDate = new Date();
            calcSolarCalendar(MiladiDate);
        }

        public SolarCalendar(Date MiladiDate)
        {
            calcSolarCalendar(MiladiDate);
        }

        private void calcSolarCalendar(Date MiladiDate) {

            int ld;

            int miladiYear = MiladiDate.getYear() + 1900;
            int miladiMonth = MiladiDate.getMonth() + 1;
            int miladiDate = MiladiDate.getDate();
            int WeekDay = MiladiDate.getDay();

            int[] buf1 = new int[12];
            int[] buf2 = new int[12];

            buf1[0] = 0;
            buf1[1] = 31;
            buf1[2] = 59;
            buf1[3] = 90;
            buf1[4] = 120;
            buf1[5] = 151;
            buf1[6] = 181;
            buf1[7] = 212;
            buf1[8] = 243;
            buf1[9] = 273;
            buf1[10] = 304;
            buf1[11] = 334;

            buf2[0] = 0;
            buf2[1] = 31;
            buf2[2] = 60;
            buf2[3] = 91;
            buf2[4] = 121;
            buf2[5] = 152;
            buf2[6] = 182;
            buf2[7] = 213;
            buf2[8] = 244;
            buf2[9] = 274;
            buf2[10] = 305;
            buf2[11] = 335;

            if ((miladiYear % 4) != 0) {
                date = buf1[miladiMonth - 1] + miladiDate;

                if (date &gt; 79) {
                    date = date - 79;
                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = date / 31;
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                } else {
                    if ((miladiYear &gt; 1996) &amp;&amp; (miladiYear % 4) == 1) {
                        ld = 11;
                    } else {
                        ld = 10;
                    }
                    date = date + ld;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }
            } else {
                date = buf2[miladiMonth - 1] + miladiDate;

                if (miladiYear &gt;= 1996) {
                    ld = 79;
                } else {
                    ld = 80;
                }
                if (date &gt; ld) {
                    date = date - ld;

                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = (date / 31);
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                }

                else {
                    date = date + 10;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }

            }

            switch (month) {
            case 1:
                strMonth = "فروردين";
                break;
            case 2:
                strMonth = "ارديبهشت";
                break;
            case 3:
                strMonth = "خرداد";
                break;
            case 4:
                strMonth = "تير";
                break;
            case 5:
                strMonth = "مرداد";
                break;
            case 6:
                strMonth = "شهريور";
                break;
            case 7:
                strMonth = "مهر";
                break;
            case 8:
                strMonth = "آبان";
                break;
            case 9:
                strMonth = "آذر";
                break;
            case 10:
                strMonth = "دي";
                break;
            case 11:
                strMonth = "بهمن";
                break;
            case 12:
                strMonth = "اسفند";
                break;
            }

            switch (WeekDay) {

            case 0:
                strWeekDay = "يکشنبه";
                break;
            case 1:
                strWeekDay = "دوشنبه";
                break;
            case 2:
                strWeekDay = "سه شنبه";
                break;
            case 3:
                strWeekDay = "چهارشنبه";
                break;
            case 4:
                strWeekDay = "پنج شنبه";
                break;
            case 5:
                strWeekDay = "جمعه";
                break;
            case 6:
                strWeekDay = "شنبه";
                break;
            }

        }

    }

    public static String getCurrentShamsidate() {
        Locale loc = new Locale("en_US");
        Utilities util = new Utilities();
        SolarCalendar sc = util.new SolarCalendar();
        return String.valueOf(sc.year) + "/" + String.format(loc, "%02d",
                sc.month) + "/" + String.format(loc, "%02d", sc.date);
    }
}
******************************
Normalized:
public class Utilities {

    private class SolarCalendar {

        public String strWeekDay = "";
        public String strMonth = "";

        int date;
        int month;
        int year;

        public SolarCalendar()
        {
            Date MiladiDate = new Date();
            calcSolarCalendar(MiladiDate);
        }

        public SolarCalendar(Date MiladiDate)
        {
            calcSolarCalendar(MiladiDate);
        }

        private void calcSolarCalendar(Date MiladiDate) {

            int ld;

            int miladiYear = MiladiDate.getYear() + 1900;
            int miladiMonth = MiladiDate.getMonth() + 1;
            int miladiDate = MiladiDate.getDate();
            int WeekDay = MiladiDate.getDay();

            int[] buf1 = new int[12];
            int[] buf2 = new int[12];

            buf1[0] = 0;
            buf1[1] = 31;
            buf1[2] = 59;
            buf1[3] = 90;
            buf1[4] = 120;
            buf1[5] = 151;
            buf1[6] = 181;
            buf1[7] = 212;
            buf1[8] = 243;
            buf1[9] = 273;
            buf1[10] = 304;
            buf1[11] = 334;

            buf2[0] = 0;
            buf2[1] = 31;
            buf2[2] = 60;
            buf2[3] = 91;
            buf2[4] = 121;
            buf2[5] = 152;
            buf2[6] = 182;
            buf2[7] = 213;
            buf2[8] = 244;
            buf2[9] = 274;
            buf2[10] = 305;
            buf2[11] = 335;

            if ((miladiYear % 4) != 0) {
                date = buf1[miladiMonth - 1] + miladiDate;

                if (date &gt; 79) {
                    date = date - 79;
                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = date / 31;
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                } else {
                    if ((miladiYear &gt; 1996) &amp;&amp; (miladiYear % 4) == 1) {
                        ld = 11;
                    } else {
                        ld = 10;
                    }
                    date = date + ld;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }
            } else {
                date = buf2[miladiMonth - 1] + miladiDate;

                if (miladiYear &gt;= 1996) {
                    ld = 79;
                } else {
                    ld = 80;
                }
                if (date &gt; ld) {
                    date = date - ld;

                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = (date / 31);
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                }

                else {
                    date = date + 10;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }

            }

            switch (month) {
            case 1:
                strMonth = "فروردين";
                break;
            case 2:
                strMonth = "ارديبهشت";
                break;
            case 3:
                strMonth = "خرداد";
                break;
            case 4:
                strMonth = "تير";
                break;
            case 5:
                strMonth = "مرداد";
                break;
            case 6:
                strMonth = "شهريور";
                break;
            case 7:
                strMonth = "مهر";
                break;
            case 8:
                strMonth = "آبان";
                break;
            case 9:
                strMonth = "آذر";
                break;
            case 10:
                strMonth = "دي";
                break;
            case 11:
                strMonth = "بهمن";
                break;
            case 12:
                strMonth = "اسفند";
                break;
            }

            switch (WeekDay) {

            case 0:
                strWeekDay = "يکشنبه";
                break;
            case 1:
                strWeekDay = "دوشنبه";
                break;
            case 2:
                strWeekDay = "سه شنبه";
                break;
            case 3:
                strWeekDay = "چهارشنبه";
                break;
            case 4:
                strWeekDay = "پنج شنبه";
                break;
            case 5:
                strWeekDay = "جمعه";
                break;
            case 6:
                strWeekDay = "شنبه";
                break;
            }

        }

    }

    public static String getCurrentShamsidate() {
        Locale loc = new Locale("en_US");
        Utilities util = new Utilities();
        SolarCalendar sc = util.new SolarCalendar();
        return String.valueOf(sc.year) + "/" + String.format(loc, "%02d",
                sc.month) + "/" + String.format(loc, "%02d", sc.date);
    }
}
******************************
Original:
public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription
******************************
Normalized:
******************************
Original:
public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription
******************************
Normalized:
public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription
******************************
Original:
void method1() {
    synchronized (this) {
        method2()
    }
}

void method2() {
    synchronized (this) {
    }
}
******************************
Normalized:
******************************
Original:
void method1() {
    synchronized (this) {
        method2()
    }
}

void method2() {
    synchronized (this) {
    }
}
******************************
Normalized:
void method1() {
    synchronized (this) {
        method2()
    }
}

void method2() {
    synchronized (this) {
    }
}
******************************
Original:
AnotherClass anotherObjSpy = Mockito.spy(new AnotherClass());
// do stuff -- e.g. anotherObjSpy.foo(...);
verify(anotherObjSpy).codePath1(...);
******************************
Normalized:
******************************
Original:
AnotherClass anotherObjSpy = Mockito.spy(new AnotherClass());
// do stuff -- e.g. anotherObjSpy.foo(...);
verify(anotherObjSpy).codePath1(...);
******************************
Normalized:
AnotherClass anotherObjSpy = Mockito.spy(new AnotherClass());
// do stuff -- e.g. anotherObjSpy.foo(...);
verify(anotherObjSpy).codePath1(...);
******************************
Original:
public class GenericList &lt;T&gt; extends ArrayList&lt;T&gt;
{
     private Class&lt;T&gt; genericType;

     public GenericList(Class&lt;T&gt; c)
     {
          this.genericType = c;
     }

     public Class&lt;T&gt; getGenericType()
     {
          return genericType;
     }
}
******************************
Normalized:
******************************
Original:
public class GenericList &lt;T&gt; extends ArrayList&lt;T&gt;
{
     private Class&lt;T&gt; genericType;

     public GenericList(Class&lt;T&gt; c)
     {
          this.genericType = c;
     }

     public Class&lt;T&gt; getGenericType()
     {
          return genericType;
     }
}
******************************
Normalized:
public class GenericList &lt;T&gt; extends ArrayList&lt;T&gt;
{
     private Class&lt;T&gt; genericType;

     public GenericList(Class&lt;T&gt; c)
     {
          this.genericType = c;
     }

     public Class&lt;T&gt; getGenericType()
     {
          return genericType;
     }
}
******************************
Original:
package hashmaptest;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

public class HashMapTest {

    private static final List&lt;Result&gt; results = new ArrayList&lt;Result&gt;();

    public static void main(String[] args) throws IOException {

        //First entry of each array is the sample collection size, subsequent entries
        //are the hash limits
        final int[][] sampleSizesAndHashLimits = new int[][] {
            {100, 50, 90, 100},
            {1000, 500, 900, 990, 1000},
            {100000, 10000, 90000, 99000, 100000}
        };
        final double[] initialCapacityFactors = new double[] {0.5, 0.75, 1.0, 1.25, 1.5, 2.0};
        final float[] loadFactors = new float[] {0.5f, 0.75f, 1.0f, 1.25f};

        //Doing a warmup run to eliminate JIT influence
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        results.clear();

        //Now for the real thing...
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        Collections.sort(results);

        for(final Result result : results) {
            result.printSummary();
        }

//      ResultVisualizer.visualizeResults(results);

    }

    private static void runTest(final int hashLimit, final int sampleSize,
            final double initCapacityFactor, final float loadFactor) {

        final int initialCapacity = (int)(sampleSize * initCapacityFactor);

        System.out.println("Running test for a sample collection of size " + sampleSize 
            + ", an initial capacity of " + initialCapacity + ", a load factor of "
            + loadFactor + " and keys with a hash code limited to " + hashLimit);
        System.out.println("====================");

        double hashOverload = (((double)sampleSize/hashLimit) - 1.0) * 100.0;

        System.out.println("Hash code overload: " + hashOverload + "%");

        //Generating our sample key collection.
        final List&lt;Key&gt; keys = generateSamples(hashLimit, sampleSize);

        //Generating our value collection
        final List&lt;Object&gt; values = generateValues(sampleSize);

        final HashMap&lt;Key, Object&gt; map = new HashMap&lt;Key, Object&gt;(initialCapacity, loadFactor);

        final long startPut = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.put(keys.get(i), values.get(i));
        }

        final long endPut = System.nanoTime();

        final long putTime = endPut - startPut;
        final long averagePutTime = putTime/(sampleSize/10);

        System.out.println("Time to map all keys to their values: " + putTime + " ns");
        System.out.println("Average put time per 10 entries: " + averagePutTime + " ns");

        final long startGet = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.get(keys.get(i));
        }

        final long endGet = System.nanoTime();

        final long getTime = endGet - startGet;
        final long averageGetTime = getTime/(sampleSize/10);

        System.out.println("Time to get the value for every key: " + getTime + " ns");
        System.out.println("Average get time per 10 entries: " + averageGetTime + " ns");

        System.out.println("");

        final Result result = 
            new Result(sampleSize, initialCapacity, loadFactor, hashOverload, averagePutTime, averageGetTime, hashLimit);

        results.add(result);

        //Haha, what kind of noob explicitly calls for garbage collection?
        System.gc();

        try {
            Thread.sleep(200);
        } catch(final InterruptedException e) {}

    }

    private static List&lt;Key&gt; generateSamples(final int hashLimit, final int sampleSize) {

        final ArrayList&lt;Key&gt; result = new ArrayList&lt;Key&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Key(i, hashLimit));
        }

        return result;

    }

    private static List&lt;Object&gt; generateValues(final int sampleSize) {

        final ArrayList&lt;Object&gt; result = new ArrayList&lt;Object&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Object());
        }

        return result;

    }

    private static class Key {

        private final int hashCode;
        private final int id;

        Key(final int id, final int hashLimit) {

            //Equals implies same hashCode if limit is the same
            //Same hashCode doesn't necessarily implies equals

            this.id = id;
            this.hashCode = id % hashLimit;

        }

        @Override
        public int hashCode() {
            return hashCode;
        }

        @Override
        public boolean equals(final Object o) {
            return ((Key)o).id == this.id;
        }

    }

    static class Result implements Comparable&lt;Result&gt; {

        final int sampleSize;
        final int initialCapacity;
        final float loadFactor;
        final double hashOverloadPercentage;
        final long averagePutTime;
        final long averageGetTime;
        final int hashLimit;

        Result(final int sampleSize, final int initialCapacity, final float loadFactor, 
                final double hashOverloadPercentage, final long averagePutTime, 
                final long averageGetTime, final int hashLimit) {

            this.sampleSize = sampleSize;
            this.initialCapacity = initialCapacity;
            this.loadFactor = loadFactor;
            this.hashOverloadPercentage = hashOverloadPercentage;
            this.averagePutTime = averagePutTime;
            this.averageGetTime = averageGetTime;
            this.hashLimit = hashLimit;

        }

        @Override
        public int compareTo(final Result o) {

            final long putDiff = o.averagePutTime - this.averagePutTime;
            final long getDiff = o.averageGetTime - this.averageGetTime;

            return (int)(putDiff + getDiff);
        }

        void printSummary() {

            System.out.println("" + averagePutTime + " ns per 10 puts, "
                + averageGetTime + " ns per 10 gets, for a load factor of "
                + loadFactor + ", initial capacity of " + initialCapacity
                + " for " + sampleSize + " mappings and " + hashOverloadPercentage 
                + "% hash code overload.");

        }

    }

}
******************************
Normalized:
******************************
Original:
package hashmaptest;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

public class HashMapTest {

    private static final List&lt;Result&gt; results = new ArrayList&lt;Result&gt;();

    public static void main(String[] args) throws IOException {

        //First entry of each array is the sample collection size, subsequent entries
        //are the hash limits
        final int[][] sampleSizesAndHashLimits = new int[][] {
            {100, 50, 90, 100},
            {1000, 500, 900, 990, 1000},
            {100000, 10000, 90000, 99000, 100000}
        };
        final double[] initialCapacityFactors = new double[] {0.5, 0.75, 1.0, 1.25, 1.5, 2.0};
        final float[] loadFactors = new float[] {0.5f, 0.75f, 1.0f, 1.25f};

        //Doing a warmup run to eliminate JIT influence
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        results.clear();

        //Now for the real thing...
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        Collections.sort(results);

        for(final Result result : results) {
            result.printSummary();
        }

//      ResultVisualizer.visualizeResults(results);

    }

    private static void runTest(final int hashLimit, final int sampleSize,
            final double initCapacityFactor, final float loadFactor) {

        final int initialCapacity = (int)(sampleSize * initCapacityFactor);

        System.out.println("Running test for a sample collection of size " + sampleSize 
            + ", an initial capacity of " + initialCapacity + ", a load factor of "
            + loadFactor + " and keys with a hash code limited to " + hashLimit);
        System.out.println("====================");

        double hashOverload = (((double)sampleSize/hashLimit) - 1.0) * 100.0;

        System.out.println("Hash code overload: " + hashOverload + "%");

        //Generating our sample key collection.
        final List&lt;Key&gt; keys = generateSamples(hashLimit, sampleSize);

        //Generating our value collection
        final List&lt;Object&gt; values = generateValues(sampleSize);

        final HashMap&lt;Key, Object&gt; map = new HashMap&lt;Key, Object&gt;(initialCapacity, loadFactor);

        final long startPut = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.put(keys.get(i), values.get(i));
        }

        final long endPut = System.nanoTime();

        final long putTime = endPut - startPut;
        final long averagePutTime = putTime/(sampleSize/10);

        System.out.println("Time to map all keys to their values: " + putTime + " ns");
        System.out.println("Average put time per 10 entries: " + averagePutTime + " ns");

        final long startGet = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.get(keys.get(i));
        }

        final long endGet = System.nanoTime();

        final long getTime = endGet - startGet;
        final long averageGetTime = getTime/(sampleSize/10);

        System.out.println("Time to get the value for every key: " + getTime + " ns");
        System.out.println("Average get time per 10 entries: " + averageGetTime + " ns");

        System.out.println("");

        final Result result = 
            new Result(sampleSize, initialCapacity, loadFactor, hashOverload, averagePutTime, averageGetTime, hashLimit);

        results.add(result);

        //Haha, what kind of noob explicitly calls for garbage collection?
        System.gc();

        try {
            Thread.sleep(200);
        } catch(final InterruptedException e) {}

    }

    private static List&lt;Key&gt; generateSamples(final int hashLimit, final int sampleSize) {

        final ArrayList&lt;Key&gt; result = new ArrayList&lt;Key&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Key(i, hashLimit));
        }

        return result;

    }

    private static List&lt;Object&gt; generateValues(final int sampleSize) {

        final ArrayList&lt;Object&gt; result = new ArrayList&lt;Object&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Object());
        }

        return result;

    }

    private static class Key {

        private final int hashCode;
        private final int id;

        Key(final int id, final int hashLimit) {

            //Equals implies same hashCode if limit is the same
            //Same hashCode doesn't necessarily implies equals

            this.id = id;
            this.hashCode = id % hashLimit;

        }

        @Override
        public int hashCode() {
            return hashCode;
        }

        @Override
        public boolean equals(final Object o) {
            return ((Key)o).id == this.id;
        }

    }

    static class Result implements Comparable&lt;Result&gt; {

        final int sampleSize;
        final int initialCapacity;
        final float loadFactor;
        final double hashOverloadPercentage;
        final long averagePutTime;
        final long averageGetTime;
        final int hashLimit;

        Result(final int sampleSize, final int initialCapacity, final float loadFactor, 
                final double hashOverloadPercentage, final long averagePutTime, 
                final long averageGetTime, final int hashLimit) {

            this.sampleSize = sampleSize;
            this.initialCapacity = initialCapacity;
            this.loadFactor = loadFactor;
            this.hashOverloadPercentage = hashOverloadPercentage;
            this.averagePutTime = averagePutTime;
            this.averageGetTime = averageGetTime;
            this.hashLimit = hashLimit;

        }

        @Override
        public int compareTo(final Result o) {

            final long putDiff = o.averagePutTime - this.averagePutTime;
            final long getDiff = o.averageGetTime - this.averageGetTime;

            return (int)(putDiff + getDiff);
        }

        void printSummary() {

            System.out.println("" + averagePutTime + " ns per 10 puts, "
                + averageGetTime + " ns per 10 gets, for a load factor of "
                + loadFactor + ", initial capacity of " + initialCapacity
                + " for " + sampleSize + " mappings and " + hashOverloadPercentage 
                + "% hash code overload.");

        }

    }

}
******************************
Normalized:
package hashmaptest;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

public class HashMapTest {

    private static final List&lt;Result&gt; results = new ArrayList&lt;Result&gt;();

    public static void main(String[] args) throws IOException {

        //First entry of each array is the sample collection size, subsequent entries
        //are the hash limits
        final int[][] sampleSizesAndHashLimits = new int[][] {
            {100, 50, 90, 100},
            {1000, 500, 900, 990, 1000},
            {100000, 10000, 90000, 99000, 100000}
        };
        final double[] initialCapacityFactors = new double[] {0.5, 0.75, 1.0, 1.25, 1.5, 2.0};
        final float[] loadFactors = new float[] {0.5f, 0.75f, 1.0f, 1.25f};

        //Doing a warmup run to eliminate JIT influence
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        results.clear();

        //Now for the real thing...
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        Collections.sort(results);

        for(final Result result : results) {
            result.printSummary();
        }

//      ResultVisualizer.visualizeResults(results);

    }

    private static void runTest(final int hashLimit, final int sampleSize,
            final double initCapacityFactor, final float loadFactor) {

        final int initialCapacity = (int)(sampleSize * initCapacityFactor);

        System.out.println("Running test for a sample collection of size " + sampleSize 
            + ", an initial capacity of " + initialCapacity + ", a load factor of "
            + loadFactor + " and keys with a hash code limited to " + hashLimit);
        System.out.println("====================");

        double hashOverload = (((double)sampleSize/hashLimit) - 1.0) * 100.0;

        System.out.println("Hash code overload: " + hashOverload + "%");

        //Generating our sample key collection.
        final List&lt;Key&gt; keys = generateSamples(hashLimit, sampleSize);

        //Generating our value collection
        final List&lt;Object&gt; values = generateValues(sampleSize);

        final HashMap&lt;Key, Object&gt; map = new HashMap&lt;Key, Object&gt;(initialCapacity, loadFactor);

        final long startPut = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.put(keys.get(i), values.get(i));
        }

        final long endPut = System.nanoTime();

        final long putTime = endPut - startPut;
        final long averagePutTime = putTime/(sampleSize/10);

        System.out.println("Time to map all keys to their values: " + putTime + " ns");
        System.out.println("Average put time per 10 entries: " + averagePutTime + " ns");

        final long startGet = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.get(keys.get(i));
        }

        final long endGet = System.nanoTime();

        final long getTime = endGet - startGet;
        final long averageGetTime = getTime/(sampleSize/10);

        System.out.println("Time to get the value for every key: " + getTime + " ns");
        System.out.println("Average get time per 10 entries: " + averageGetTime + " ns");

        System.out.println("");

        final Result result = 
            new Result(sampleSize, initialCapacity, loadFactor, hashOverload, averagePutTime, averageGetTime, hashLimit);

        results.add(result);

        //Haha, what kind of noob explicitly calls for garbage collection?
        System.gc();

        try {
            Thread.sleep(200);
        } catch(final InterruptedException e) {}

    }

    private static List&lt;Key&gt; generateSamples(final int hashLimit, final int sampleSize) {

        final ArrayList&lt;Key&gt; result = new ArrayList&lt;Key&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Key(i, hashLimit));
        }

        return result;

    }

    private static List&lt;Object&gt; generateValues(final int sampleSize) {

        final ArrayList&lt;Object&gt; result = new ArrayList&lt;Object&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Object());
        }

        return result;

    }

    private static class Key {

        private final int hashCode;
        private final int id;

        Key(final int id, final int hashLimit) {

            //Equals implies same hashCode if limit is the same
            //Same hashCode doesn't necessarily implies equals

            this.id = id;
            this.hashCode = id % hashLimit;

        }

        @Override
        public int hashCode() {
            return hashCode;
        }

        @Override
        public boolean equals(final Object o) {
            return ((Key)o).id == this.id;
        }

    }

    static class Result implements Comparable&lt;Result&gt; {

        final int sampleSize;
        final int initialCapacity;
        final float loadFactor;
        final double hashOverloadPercentage;
        final long averagePutTime;
        final long averageGetTime;
        final int hashLimit;

        Result(final int sampleSize, final int initialCapacity, final float loadFactor, 
                final double hashOverloadPercentage, final long averagePutTime, 
                final long averageGetTime, final int hashLimit) {

            this.sampleSize = sampleSize;
            this.initialCapacity = initialCapacity;
            this.loadFactor = loadFactor;
            this.hashOverloadPercentage = hashOverloadPercentage;
            this.averagePutTime = averagePutTime;
            this.averageGetTime = averageGetTime;
            this.hashLimit = hashLimit;

        }

        @Override
        public int compareTo(final Result o) {

            final long putDiff = o.averagePutTime - this.averagePutTime;
            final long getDiff = o.averageGetTime - this.averageGetTime;

            return (int)(putDiff + getDiff);
        }

        void printSummary() {

            System.out.println("" + averagePutTime + " ns per 10 puts, "
                + averageGetTime + " ns per 10 gets, for a load factor of "
                + loadFactor + ", initial capacity of " + initialCapacity
                + " for " + sampleSize + " mappings and " + hashOverloadPercentage 
                + "% hash code overload.");

        }

    }

}
******************************
Original:
StringBuilder sb = new StringBuilder();
for (int i = 0; i &lt; 500; i ++) {
    sb.append(i);
}
******************************
Normalized:
******************************
Original:
StringBuilder sb = new StringBuilder();
for (int i = 0; i &lt; 500; i ++) {
    sb.append(i);
}
******************************
Normalized:
StringBuilder sb = new StringBuilder();
for (int i = 0; i &lt; 500; i ++) {
    sb.append(i);
}
******************************
Original:
arrayList.set(index i,String replaceElement);
******************************
Normalized:
******************************
Original:
arrayList.set(index i,String replaceElement);
******************************
Normalized:
arrayList.set(index i,String replaceElement);
******************************
Original:
&lt;properties&gt;
  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
******************************
Normalized:
******************************
Original:
&lt;properties&gt;
  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
******************************
Normalized:
&lt;properties&gt;
  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
******************************
Original:
public class RetryTest {
    public class Retry implements TestRule {
        private int retryCount;

        public Retry(int retryCount) {
            this.retryCount = retryCount;
        }

        public Statement apply(Statement base, Description description) {
            return statement(base, description);
        }

        private Statement statement(final Statement base, final Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    Throwable caughtThrowable = null;

                    // implement retry logic here
                    for (int i = 0; i &lt; retryCount; i++) {
                        try {
                            base.evaluate();
                            return;
                        } catch (Throwable t) {
                            caughtThrowable = t;
                            System.err.println(description.getDisplayName() + ": run " + (i+1) + " failed");
                        }
                    }
                    System.err.println(description.getDisplayName() + ": giving up after " + retryCount + " failures");
                    throw caughtThrowable;
                }
            };
        }
    }

    @Rule
    public Retry retry = new Retry(3);

    @Test
    public void test1() {
    }

    @Test
    public void test2() {
        Object o = null;
        o.equals("foo");
    }
}
******************************
Normalized:
******************************
Original:
public class RetryTest {
    public class Retry implements TestRule {
        private int retryCount;

        public Retry(int retryCount) {
            this.retryCount = retryCount;
        }

        public Statement apply(Statement base, Description description) {
            return statement(base, description);
        }

        private Statement statement(final Statement base, final Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    Throwable caughtThrowable = null;

                    // implement retry logic here
                    for (int i = 0; i &lt; retryCount; i++) {
                        try {
                            base.evaluate();
                            return;
                        } catch (Throwable t) {
                            caughtThrowable = t;
                            System.err.println(description.getDisplayName() + ": run " + (i+1) + " failed");
                        }
                    }
                    System.err.println(description.getDisplayName() + ": giving up after " + retryCount + " failures");
                    throw caughtThrowable;
                }
            };
        }
    }

    @Rule
    public Retry retry = new Retry(3);

    @Test
    public void test1() {
    }

    @Test
    public void test2() {
        Object o = null;
        o.equals("foo");
    }
}
******************************
Normalized:
public class RetryTest {
    public class Retry implements TestRule {
        private int retryCount;

        public Retry(int retryCount) {
            this.retryCount = retryCount;
        }

        public Statement apply(Statement base, Description description) {
            return statement(base, description);
        }

        private Statement statement(final Statement base, final Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    Throwable caughtThrowable = null;

                    // implement retry logic here
                    for (int i = 0; i &lt; retryCount; i++) {
                        try {
                            base.evaluate();
                            return;
                        } catch (Throwable t) {
                            caughtThrowable = t;
                            System.err.println(description.getDisplayName() + ": run " + (i+1) + " failed");
                        }
                    }
                    System.err.println(description.getDisplayName() + ": giving up after " + retryCount + " failures");
                    throw caughtThrowable;
                }
            };
        }
    }

    @Rule
    public Retry retry = new Retry(3);

    @Test
    public void test1() {
    }

    @Test
    public void test2() {
        Object o = null;
        o.equals("foo");
    }
}
******************************
Original:
Set&lt;Integer&gt; s; //contains your Integers
...
Set&lt;Integer&gt; temp = new Set&lt;Integer&gt;();
for(Integer i : s)
    temp.add(i+1);
s.clear();
s.addAll(temp);
******************************
Normalized:
******************************
Original:
Set&lt;Integer&gt; s; //contains your Integers
...
Set&lt;Integer&gt; temp = new Set&lt;Integer&gt;();
for(Integer i : s)
    temp.add(i+1);
s.clear();
s.addAll(temp);
******************************
Normalized:
Set&lt;Integer&gt; s; //contains your Integers
...
Set&lt;Integer&gt; temp = new Set&lt;Integer&gt;();
for(Integer i : s)
    temp.add(i+1);
s.clear();
s.addAll(temp);
******************************
Original:
Future&lt;T&gt; future = ConcurrentUtils.constantFuture(T myValue);
******************************
Normalized:
******************************
Original:
Future&lt;T&gt; future = ConcurrentUtils.constantFuture(T myValue);
******************************
Normalized:
Future&lt;T&gt; future = ConcurrentUtils.constantFuture(T myValue);
******************************
Original:
final EditText edittext = (EditText) findViewById(R.id.edittext);
edittext.setOnKeyListener(new View.OnKeyListener() {
    public boolean onKey(View v, int keyCode, KeyEvent event) {
        if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; keyCode == KeyEvent.KEYCODE_ENTER) {
            Toast.makeText(HelloFormStuff.this, edittext.getText(), Toast.LENGTH_SHORT).show();
            return true;
        }
        return false;
    }
});
******************************
Normalized:
******************************
Original:
final EditText edittext = (EditText) findViewById(R.id.edittext);
edittext.setOnKeyListener(new View.OnKeyListener() {
    public boolean onKey(View v, int keyCode, KeyEvent event) {
        if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; keyCode == KeyEvent.KEYCODE_ENTER) {
            Toast.makeText(HelloFormStuff.this, edittext.getText(), Toast.LENGTH_SHORT).show();
            return true;
        }
        return false;
    }
});
******************************
Normalized:
final EditText edittext = (EditText) findViewById(R.id.edittext);
edittext.setOnKeyListener(new View.OnKeyListener() {
    public boolean onKey(View v, int keyCode, KeyEvent event) {
        if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; keyCode == KeyEvent.KEYCODE_ENTER) {
            Toast.makeText(HelloFormStuff.this, edittext.getText(), Toast.LENGTH_SHORT).show();
            return true;
        }
        return false;
    }
});
******************************
Original:
&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;otherOutputDir&lt;/id&gt;
        &lt;build&gt;
            &lt;directory&gt;yourDirectory&lt;/directory&gt;
        &lt;/build&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
******************************
Normalized:
******************************
Original:
&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;otherOutputDir&lt;/id&gt;
        &lt;build&gt;
            &lt;directory&gt;yourDirectory&lt;/directory&gt;
        &lt;/build&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
******************************
Normalized:
&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;otherOutputDir&lt;/id&gt;
        &lt;build&gt;
            &lt;directory&gt;yourDirectory&lt;/directory&gt;
        &lt;/build&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
******************************
Original:
...10110110
******************************
Normalized:
******************************
Original:
...10110110
******************************
Normalized:
...10110110
******************************
Original:
@ManyToMany(fetch = FetchType.EAGER)
******************************
Normalized:
******************************
Original:
@ManyToMany(fetch = FetchType.EAGER)
******************************
Normalized:
@ManyToMany(fetch = FetchType.EAGER)
******************************
Original:
(IDLjava/lang/Thread;)Ljava/lang/Object;
******************************
Normalized:
******************************
Original:
(IDLjava/lang/Thread;)Ljava/lang/Object;
******************************
Normalized:
(IDLjava/lang/Thread;)Ljava/lang/Object;
******************************
Original:
$ mvn dependency:copy-dependencies -DoutputDirectory=OUTPUT_DIR
******************************
Normalized:
******************************
Original:
$ mvn dependency:copy-dependencies -DoutputDirectory=OUTPUT_DIR
******************************
Normalized:
$ mvn dependency:copy-dependencies -DoutputDirectory=OUTPUT_DIR
******************************
Original:
(?:\u{D A}|(?!\u{D A})[\u{A}-\u{D}\u{85}\u{2028}\u{2029}]
******************************
Normalized:
******************************
Original:
(?:\u{D A}|(?!\u{D A})[\u{A}-\u{D}\u{85}\u{2028}\u{2029}]
******************************
Normalized:
(?:\u{D A}|(?!\u{D A})[\u{A}-\u{D}\u{85}\u{2028}\u{2029}]
******************************
Original:
module org.example.foo {
    requires java.xml.bind;
}
******************************
Normalized:
******************************
Original:
module org.example.foo {
    requires java.xml.bind;
}
******************************
Normalized:
module org.example.foo {
    requires java.xml.bind;
}
******************************
Original:
public class CompletionServiceTest {

        class CalcResult {
             long result ;

             CalcResult(long l) {
                 result = l;
             }
        }

        class CallableTask implements Callable&lt;CalcResult&gt; {
            String taskName ;
            long  input1 ;
            int input2 ;

            CallableTask(String name , long v1 , int v2 ) {
                taskName = name;
                input1 = v1;
                input2 = v2 ;
            }

            public CalcResult call() throws Exception {
                System.out.println(" Task " + taskName + " Started -----");
                for(int i=0;i&lt;input2 ;i++) {
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        System.out.println(" Task " + taskName + " Interrupted !! ");
                        e.printStackTrace();
                    }
                    input1 += i;
                }
                System.out.println(" Task " + taskName + " Completed @@@@@@");
                return new CalcResult(input1) ;
            }

        }

        public void test(){
            ExecutorService taskExecutor = Executors.newFixedThreadPool(3);
            CompletionService&lt;CalcResult&gt; taskCompletionService = new ExecutorCompletionService&lt;CalcResult&gt;(taskExecutor);

            int submittedTasks = 5;
            for (int i=0;i&lt; submittedTasks;i++) {
                taskCompletionService.submit(new CallableTask (
                        String.valueOf(i), 
                            (i * 10), 
                            ((i * 10) + 10  )
                        ));
               System.out.println("Task " + String.valueOf(i) + "subitted");
            }
            for (int tasksHandled=0;tasksHandled&lt;submittedTasks;tasksHandled++) {
                try {
                    System.out.println("trying to take from Completion service");
                    Future&lt;CalcResult&gt; result = taskCompletionService.take();
                    System.out.println("result for a task availble in queue.Trying to get()");
                    // above call blocks till atleast one task is completed and results availble for it
                    // but we dont have to worry which one

                    // process the result here by doing result.get()
                    CalcResult l = result.get();
                    System.out.println("Task " + String.valueOf(tasksHandled) + "Completed - results obtained : " + String.valueOf(l.result));

                } catch (InterruptedException e) {
                    // Something went wrong with a task submitted
                    System.out.println("Error Interrupted exception");
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    // Something went wrong with the result
                    e.printStackTrace();
                    System.out.println("Error get() threw exception");
                }
            }
        }
    }
******************************
Normalized:
******************************
Original:
public class CompletionServiceTest {

        class CalcResult {
             long result ;

             CalcResult(long l) {
                 result = l;
             }
        }

        class CallableTask implements Callable&lt;CalcResult&gt; {
            String taskName ;
            long  input1 ;
            int input2 ;

            CallableTask(String name , long v1 , int v2 ) {
                taskName = name;
                input1 = v1;
                input2 = v2 ;
            }

            public CalcResult call() throws Exception {
                System.out.println(" Task " + taskName + " Started -----");
                for(int i=0;i&lt;input2 ;i++) {
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        System.out.println(" Task " + taskName + " Interrupted !! ");
                        e.printStackTrace();
                    }
                    input1 += i;
                }
                System.out.println(" Task " + taskName + " Completed @@@@@@");
                return new CalcResult(input1) ;
            }

        }

        public void test(){
            ExecutorService taskExecutor = Executors.newFixedThreadPool(3);
            CompletionService&lt;CalcResult&gt; taskCompletionService = new ExecutorCompletionService&lt;CalcResult&gt;(taskExecutor);

            int submittedTasks = 5;
            for (int i=0;i&lt; submittedTasks;i++) {
                taskCompletionService.submit(new CallableTask (
                        String.valueOf(i), 
                            (i * 10), 
                            ((i * 10) + 10  )
                        ));
               System.out.println("Task " + String.valueOf(i) + "subitted");
            }
            for (int tasksHandled=0;tasksHandled&lt;submittedTasks;tasksHandled++) {
                try {
                    System.out.println("trying to take from Completion service");
                    Future&lt;CalcResult&gt; result = taskCompletionService.take();
                    System.out.println("result for a task availble in queue.Trying to get()");
                    // above call blocks till atleast one task is completed and results availble for it
                    // but we dont have to worry which one

                    // process the result here by doing result.get()
                    CalcResult l = result.get();
                    System.out.println("Task " + String.valueOf(tasksHandled) + "Completed - results obtained : " + String.valueOf(l.result));

                } catch (InterruptedException e) {
                    // Something went wrong with a task submitted
                    System.out.println("Error Interrupted exception");
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    // Something went wrong with the result
                    e.printStackTrace();
                    System.out.println("Error get() threw exception");
                }
            }
        }
    }
******************************
Normalized:
public class CompletionServiceTest {

        class CalcResult {
             long result ;

             CalcResult(long l) {
                 result = l;
             }
        }

        class CallableTask implements Callable&lt;CalcResult&gt; {
            String taskName ;
            long  input1 ;
            int input2 ;

            CallableTask(String name , long v1 , int v2 ) {
                taskName = name;
                input1 = v1;
                input2 = v2 ;
            }

            public CalcResult call() throws Exception {
                System.out.println(" Task " + taskName + " Started -----");
                for(int i=0;i&lt;input2 ;i++) {
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        System.out.println(" Task " + taskName + " Interrupted !! ");
                        e.printStackTrace();
                    }
                    input1 += i;
                }
                System.out.println(" Task " + taskName + " Completed @@@@@@");
                return new CalcResult(input1) ;
            }

        }

        public void test(){
            ExecutorService taskExecutor = Executors.newFixedThreadPool(3);
            CompletionService&lt;CalcResult&gt; taskCompletionService = new ExecutorCompletionService&lt;CalcResult&gt;(taskExecutor);

            int submittedTasks = 5;
            for (int i=0;i&lt; submittedTasks;i++) {
                taskCompletionService.submit(new CallableTask (
                        String.valueOf(i), 
                            (i * 10), 
                            ((i * 10) + 10  )
                        ));
               System.out.println("Task " + String.valueOf(i) + "subitted");
            }
            for (int tasksHandled=0;tasksHandled&lt;submittedTasks;tasksHandled++) {
                try {
                    System.out.println("trying to take from Completion service");
                    Future&lt;CalcResult&gt; result = taskCompletionService.take();
                    System.out.println("result for a task availble in queue.Trying to get()");
                    // above call blocks till atleast one task is completed and results availble for it
                    // but we dont have to worry which one

                    // process the result here by doing result.get()
                    CalcResult l = result.get();
                    System.out.println("Task " + String.valueOf(tasksHandled) + "Completed - results obtained : " + String.valueOf(l.result));

                } catch (InterruptedException e) {
                    // Something went wrong with a task submitted
                    System.out.println("Error Interrupted exception");
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    // Something went wrong with the result
                    e.printStackTrace();
                    System.out.println("Error get() threw exception");
                }
            }
        }
    }
******************************
Original:
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/*")
public class MyApplication extends Application {
    ...
}
******************************
Normalized:
******************************
Original:
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/*")
public class MyApplication extends Application {
    ...
}
******************************
Normalized:
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/*")
public class MyApplication extends Application {
    ...
}
******************************
Original:
List&lt;Integer&gt; idList = students.stream().map(Student::getId).collect(Collectors.toList());
******************************
Normalized:
******************************
Original:
List&lt;Integer&gt; idList = students.stream().map(Student::getId).collect(Collectors.toList());
******************************
Normalized:
List&lt;Integer&gt; idList = students.stream().map(Student::getId).collect(Collectors.toList());
******************************
Original:
Collectors.toMap(p -&gt; p.getLast(), Function.identity())
******************************
Normalized:
******************************
Original:
Collectors.toMap(p -&gt; p.getLast(), Function.identity())
******************************
Normalized:
Collectors.toMap(p -&gt; p.getLast(), Function.identity())
******************************
Original:
for(int k = 0; k &lt; strings.length; k++){
   // something
}
******************************
Normalized:
******************************
Original:
for(int k = 0; k &lt; strings.length; k++){
   // something
}
******************************
Normalized:
for(int k = 0; k &lt; strings.length; k++){
   // something
}
******************************
Original:
public void writeToParcel(Parcel out, int flags) {
    out.writeString(_mac);
    out.writeString(_pan);
    out.writeInt(_band);
    out.writeSerializable(_lqis);
    out.writeTypedList(_devices);
}

private ZigBeeNetwork(Parcel in) {
    _mac = in.readString();
    _pan = in.readString();
    _band = in.readInt();
    _lqis = (ArrayList&lt;Integer&gt;) in.readSerializable();
    in.readTypedList(_devices, ZigBeeDev.CREATOR);
}
******************************
Normalized:
******************************
Original:
public void writeToParcel(Parcel out, int flags) {
    out.writeString(_mac);
    out.writeString(_pan);
    out.writeInt(_band);
    out.writeSerializable(_lqis);
    out.writeTypedList(_devices);
}

private ZigBeeNetwork(Parcel in) {
    _mac = in.readString();
    _pan = in.readString();
    _band = in.readInt();
    _lqis = (ArrayList&lt;Integer&gt;) in.readSerializable();
    in.readTypedList(_devices, ZigBeeDev.CREATOR);
}
******************************
Normalized:
public void writeToParcel(Parcel out, int flags) {
    out.writeString(_mac);
    out.writeString(_pan);
    out.writeInt(_band);
    out.writeSerializable(_lqis);
    out.writeTypedList(_devices);
}

private ZigBeeNetwork(Parcel in) {
    _mac = in.readString();
    _pan = in.readString();
    _band = in.readInt();
    _lqis = (ArrayList&lt;Integer&gt;) in.readSerializable();
    in.readTypedList(_devices, ZigBeeDev.CREATOR);
}
******************************
Original:
@Test(expected=IncorrectArgumentForSetter.class)
public void testSetterForeignWord("") throws Exception {
  card.setForeignWord("");
}
******************************
Normalized:
******************************
Original:
@Test(expected=IncorrectArgumentForSetter.class)
public void testSetterForeignWord("") throws Exception {
  card.setForeignWord("");
}
******************************
Normalized:
@Test(expected=IncorrectArgumentForSetter.class)
public void testSetterForeignWord("") throws Exception {
  card.setForeignWord("");
}
******************************
Original:
jboss-as-7
 |
 |---&gt; standalone
 |      |----&gt; lib
 |      |----&gt; configuration
 |      |----&gt; deployments
 |      
 |---&gt; domain
 |....
******************************
Normalized:
******************************
Original:
jboss-as-7
 |
 |---&gt; standalone
 |      |----&gt; lib
 |      |----&gt; configuration
 |      |----&gt; deployments
 |      
 |---&gt; domain
 |....
******************************
Normalized:
jboss-as-7
 |
 |---&gt; standalone
 |      |----&gt; lib
 |      |----&gt; configuration
 |      |----&gt; deployments
 |      
 |---&gt; domain
 |....
******************************
Original:
@ 16   org.sample.IntStr::inlineSideEffect (25 bytes)   force inline by CompilerOracle
   @ 4   java.lang.StringBuilder::&lt;init&gt; (7 bytes)   inline (hot)
   @ 18   java.lang.StringBuilder::append (8 bytes)   already compiled into a big method
   @ 21   java.lang.StringBuilder::toString (17 bytes)   inline (hot)
******************************
Normalized:
******************************
Original:
@ 16   org.sample.IntStr::inlineSideEffect (25 bytes)   force inline by CompilerOracle
   @ 4   java.lang.StringBuilder::&lt;init&gt; (7 bytes)   inline (hot)
   @ 18   java.lang.StringBuilder::append (8 bytes)   already compiled into a big method
   @ 21   java.lang.StringBuilder::toString (17 bytes)   inline (hot)
******************************
Normalized:
@ 16   org.sample.IntStr::inlineSideEffect (25 bytes)   force inline by CompilerOracle
   @ 4   java.lang.StringBuilder::&lt;init&gt; (7 bytes)   inline (hot)
   @ 18   java.lang.StringBuilder::append (8 bytes)   already compiled into a big method
   @ 21   java.lang.StringBuilder::toString (17 bytes)   inline (hot)
******************************
Original:
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
}
******************************
Normalized:
******************************
Original:
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
}
******************************
Normalized:
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
}
******************************
Original:
@Controller
@RequestMapping(value = "/adminservice")
@Secured("ROLE_ADMIN")
public class AdminServiceController {
******************************
Normalized:
******************************
Original:
@Controller
@RequestMapping(value = "/adminservice")
@Secured("ROLE_ADMIN")
public class AdminServiceController {
******************************
Normalized:
@Controller
@RequestMapping(value = "/adminservice")
@Secured("ROLE_ADMIN")
public class AdminServiceController {
******************************
Original:
public void add(int index, E element)
******************************
Normalized:
******************************
Original:
public void add(int index, E element)
******************************
Normalized:
public void add(int index, E element)
******************************
Original:
dataList = dataList.subList(30, 38 &gt; dataList.size() ? dataList.size() : 38);
******************************
Normalized:
******************************
Original:
dataList = dataList.subList(30, 38 &gt; dataList.size() ? dataList.size() : 38);
******************************
Normalized:
dataList = dataList.subList(30, 38 &gt; dataList.size() ? dataList.size() : 38);
******************************
Original:
String item;

for(int x = 0; x &lt; 10; x++)
{
    // Linear search.
    if(array[x].equals("Item I am looking for"))
    {
       //you've found the item. Let's stop.
       item = array[x];
       break; 
    }
}
******************************
Normalized:
******************************
Original:
String item;

for(int x = 0; x &lt; 10; x++)
{
    // Linear search.
    if(array[x].equals("Item I am looking for"))
    {
       //you've found the item. Let's stop.
       item = array[x];
       break; 
    }
}
******************************
Normalized:
String item;

for(int x = 0; x &lt; 10; x++)
{
    // Linear search.
    if(array[x].equals("Item I am looking for"))
    {
       //you've found the item. Let's stop.
       item = array[x];
       break; 
    }
}
******************************
Original:
public void scheduleAtFixedRate(TimerTask task,
                                long delay,
                                long period)
******************************
Normalized:
******************************
Original:
public void scheduleAtFixedRate(TimerTask task,
                                long delay,
                                long period)
******************************
Normalized:
public void scheduleAtFixedRate(TimerTask task,
                                long delay,
                                long period)
******************************
Original:
@GeneratedValue(strategy = GenerationType.IDENTITY)
******************************
Normalized:
******************************
Original:
@GeneratedValue(strategy = GenerationType.IDENTITY)
******************************
Normalized:
@GeneratedValue(strategy = GenerationType.IDENTITY)
******************************
Original:
ZonedDateTime now = ZonedDateTime.now(ZoneId.of("America/Los_Angeles"));
ZonedDateTime nextRun = now.withHour(5).withMinute(0).withSecond(0);
if(now.compareTo(nextRun) &gt; 0)
    nextRun = nextRun.plusDays(1);

Duration duration = Duration.between(now, nextRun);
long initalDelay = duration.getSeconds();

ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);            
scheduler.scheduleAtFixedRate(new MyRunnableTask(),
    initalDelay,
    TimeUnit.DAYS.toSeconds(1),
    TimeUnit.SECONDS);
******************************
Normalized:
******************************
Original:
ZonedDateTime now = ZonedDateTime.now(ZoneId.of("America/Los_Angeles"));
ZonedDateTime nextRun = now.withHour(5).withMinute(0).withSecond(0);
if(now.compareTo(nextRun) &gt; 0)
    nextRun = nextRun.plusDays(1);

Duration duration = Duration.between(now, nextRun);
long initalDelay = duration.getSeconds();

ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);            
scheduler.scheduleAtFixedRate(new MyRunnableTask(),
    initalDelay,
    TimeUnit.DAYS.toSeconds(1),
    TimeUnit.SECONDS);
******************************
Normalized:
ZonedDateTime now = ZonedDateTime.now(ZoneId.of("America/Los_Angeles"));
ZonedDateTime nextRun = now.withHour(5).withMinute(0).withSecond(0);
if(now.compareTo(nextRun) &gt; 0)
    nextRun = nextRun.plusDays(1);

Duration duration = Duration.between(now, nextRun);
long initalDelay = duration.getSeconds();

ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);            
scheduler.scheduleAtFixedRate(new MyRunnableTask(),
    initalDelay,
    TimeUnit.DAYS.toSeconds(1),
    TimeUnit.SECONDS);
******************************
Original:
\p{L}+
******************************
Normalized:
******************************
Original:
\p{L}+
******************************
Normalized:
\p{L}+
******************************
Original:
Class&lt;?&gt; beanClass = beanDefinition.getClass();
Object bean = beanClass.newInstance();
if (bean instanceof ApplicationContextAware) {
    ((ApplicationContextAware) bean).setApplicationContext(ctx);
}
******************************
Normalized:
******************************
Original:
Class&lt;?&gt; beanClass = beanDefinition.getClass();
Object bean = beanClass.newInstance();
if (bean instanceof ApplicationContextAware) {
    ((ApplicationContextAware) bean).setApplicationContext(ctx);
}
******************************
Normalized:
Class&lt;?&gt; beanClass = beanDefinition.getClass();
Object bean = beanClass.newInstance();
if (bean instanceof ApplicationContextAware) {
    ((ApplicationContextAware) bean).setApplicationContext(ctx);
}
******************************
Original:
Observable
   .from(modifications)
   .flatmap( (data1) -&gt; { 
       return op1(data1)
           ...
           .flatmap( (data2) -&gt; { 
               // I can access data1 here
               return op2(data2);
           })
   });
******************************
Normalized:
******************************
Original:
Observable
   .from(modifications)
   .flatmap( (data1) -&gt; { 
       return op1(data1)
           ...
           .flatmap( (data2) -&gt; { 
               // I can access data1 here
               return op2(data2);
           })
   });
******************************
Normalized:
Observable
   .from(modifications)
   .flatmap( (data1) -&gt; { 
       return op1(data1)
           ...
           .flatmap( (data2) -&gt; { 
               // I can access data1 here
               return op2(data2);
           })
   });
******************************
Original:
class A implements ICallback {
     MyObject o;
     B b = new B(this, someParameter);

     @Override
     public void callback(MyObject o){
           this.o = o;
     }
}

class B {
     ICallback ic;
     B(ICallback ic, someParameter){
         this.ic = ic;
     }

    new Thread(new Runnable(){
         public void run(){
             // some calculation
             ic.callback(myObject)
         }
    }).start(); 
}

interface ICallback{
    public void callback(MyObject o);
}
******************************
Normalized:
******************************
Original:
class A implements ICallback {
     MyObject o;
     B b = new B(this, someParameter);

     @Override
     public void callback(MyObject o){
           this.o = o;
     }
}

class B {
     ICallback ic;
     B(ICallback ic, someParameter){
         this.ic = ic;
     }

    new Thread(new Runnable(){
         public void run(){
             // some calculation
             ic.callback(myObject)
         }
    }).start(); 
}

interface ICallback{
    public void callback(MyObject o);
}
******************************
Normalized:
class A implements ICallback {
     MyObject o;
     B b = new B(this, someParameter);

     @Override
     public void callback(MyObject o){
           this.o = o;
     }
}

class B {
     ICallback ic;
     B(ICallback ic, someParameter){
         this.ic = ic;
     }

    new Thread(new Runnable(){
         public void run(){
             // some calculation
             ic.callback(myObject)
         }
    }).start(); 
}

interface ICallback{
    public void callback(MyObject o);
}
******************************
Original:
&lt;import resource="classpath:spring-config.xml" /&gt;
******************************
Normalized:
******************************
Original:
&lt;import resource="classpath:spring-config.xml" /&gt;
******************************
Normalized:
&lt;import resource="classpath:spring-config.xml" /&gt;
******************************
Original:
Optional&lt;&gt; opt = dao.find();

opt.ifPresentOrElse(obj -&gt; obj.setAvailable(true),
                    () -&gt; logger.error("…"));
******************************
Normalized:
******************************
Original:
Optional&lt;&gt; opt = dao.find();

opt.ifPresentOrElse(obj -&gt; obj.setAvailable(true),
                    () -&gt; logger.error("…"));
******************************
Normalized:
Optional&lt;&gt; opt = dao.find();

opt.ifPresentOrElse(obj -&gt; obj.setAvailable(true),
                    () -&gt; logger.error("…"));
******************************
Original:
PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:*.java");

Path filename = ...;
if (matcher.matches(filename)) {
    System.out.println(filename);
}
******************************
Normalized:
******************************
Original:
PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:*.java");

Path filename = ...;
if (matcher.matches(filename)) {
    System.out.println(filename);
}
******************************
Normalized:
PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:*.java");

Path filename = ...;
if (matcher.matches(filename)) {
    System.out.println(filename);
}
******************************
Original:
final class Either&lt;L,R&gt;
{
    public static &lt;L,R&gt; Either&lt;L,R&gt; left(L value) {
        return new Either&lt;&gt;(Optional.of(value), Optional.empty());
    }
    public static &lt;L,R&gt; Either&lt;L,R&gt; right(R value) {
        return new Either&lt;&gt;(Optional.empty(), Optional.of(value));
    }
    private final Optional&lt;L&gt; left;
    private final Optional&lt;R&gt; right;
    private Either(Optional&lt;L&gt; l, Optional&lt;R&gt; r) {
      left=l;
      right=r;
    }
    public &lt;T&gt; T map(
        Function&lt;? super L, ? extends T&gt; lFunc,
        Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return left.&lt;T&gt;map(lFunc).orElseGet(()-&gt;right.map(rFunc).get());
    }
    public &lt;T&gt; Either&lt;T,R&gt; mapLeft(Function&lt;? super L, ? extends T&gt; lFunc)
    {
        return new Either&lt;&gt;(left.map(lFunc),right);
    }
    public &lt;T&gt; Either&lt;L,T&gt; mapRight(Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return new Either&lt;&gt;(left, right.map(rFunc));
    }
    public void apply(Consumer&lt;? super L&gt; lFunc, Consumer&lt;? super R&gt; rFunc)
    {
        left.ifPresent(lFunc);
        right.ifPresent(rFunc);
    }
}
******************************
Normalized:
******************************
Original:
final class Either&lt;L,R&gt;
{
    public static &lt;L,R&gt; Either&lt;L,R&gt; left(L value) {
        return new Either&lt;&gt;(Optional.of(value), Optional.empty());
    }
    public static &lt;L,R&gt; Either&lt;L,R&gt; right(R value) {
        return new Either&lt;&gt;(Optional.empty(), Optional.of(value));
    }
    private final Optional&lt;L&gt; left;
    private final Optional&lt;R&gt; right;
    private Either(Optional&lt;L&gt; l, Optional&lt;R&gt; r) {
      left=l;
      right=r;
    }
    public &lt;T&gt; T map(
        Function&lt;? super L, ? extends T&gt; lFunc,
        Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return left.&lt;T&gt;map(lFunc).orElseGet(()-&gt;right.map(rFunc).get());
    }
    public &lt;T&gt; Either&lt;T,R&gt; mapLeft(Function&lt;? super L, ? extends T&gt; lFunc)
    {
        return new Either&lt;&gt;(left.map(lFunc),right);
    }
    public &lt;T&gt; Either&lt;L,T&gt; mapRight(Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return new Either&lt;&gt;(left, right.map(rFunc));
    }
    public void apply(Consumer&lt;? super L&gt; lFunc, Consumer&lt;? super R&gt; rFunc)
    {
        left.ifPresent(lFunc);
        right.ifPresent(rFunc);
    }
}
******************************
Normalized:
final class Either&lt;L,R&gt;
{
    public static &lt;L,R&gt; Either&lt;L,R&gt; left(L value) {
        return new Either&lt;&gt;(Optional.of(value), Optional.empty());
    }
    public static &lt;L,R&gt; Either&lt;L,R&gt; right(R value) {
        return new Either&lt;&gt;(Optional.empty(), Optional.of(value));
    }
    private final Optional&lt;L&gt; left;
    private final Optional&lt;R&gt; right;
    private Either(Optional&lt;L&gt; l, Optional&lt;R&gt; r) {
      left=l;
      right=r;
    }
    public &lt;T&gt; T map(
        Function&lt;? super L, ? extends T&gt; lFunc,
        Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return left.&lt;T&gt;map(lFunc).orElseGet(()-&gt;right.map(rFunc).get());
    }
    public &lt;T&gt; Either&lt;T,R&gt; mapLeft(Function&lt;? super L, ? extends T&gt; lFunc)
    {
        return new Either&lt;&gt;(left.map(lFunc),right);
    }
    public &lt;T&gt; Either&lt;L,T&gt; mapRight(Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return new Either&lt;&gt;(left, right.map(rFunc));
    }
    public void apply(Consumer&lt;? super L&gt; lFunc, Consumer&lt;? super R&gt; rFunc)
    {
        left.ifPresent(lFunc);
        right.ifPresent(rFunc);
    }
}
******************************
Original:
Foo[] array = ...;
List&lt;Foo&gt; list = new ArrayList&lt;Foo&gt;(Arrays.asList(array));
******************************
Normalized:
******************************
Original:
Foo[] array = ...;
List&lt;Foo&gt; list = new ArrayList&lt;Foo&gt;(Arrays.asList(array));
******************************
Normalized:
Foo[] array = ...;
List&lt;Foo&gt; list = new ArrayList&lt;Foo&gt;(Arrays.asList(array));
******************************
Original:
first:
for( int i = 0; i &lt; 10; i++) {
  second:
  for(int j = 0; j &lt; 5; j ++ )
  {
    break xxx;
  }
}

third:
for( int a = 0; a &lt; 10; a++) {

}
******************************
Normalized:
******************************
Original:
first:
for( int i = 0; i &lt; 10; i++) {
  second:
  for(int j = 0; j &lt; 5; j ++ )
  {
    break xxx;
  }
}

third:
for( int a = 0; a &lt; 10; a++) {

}
******************************
Normalized:
first:
for( int i = 0; i &lt; 10; i++) {
  second:
  for(int j = 0; j &lt; 5; j ++ )
  {
    break xxx;
  }
}

third:
for( int a = 0; a &lt; 10; a++) {

}
******************************
Original:
private final CompositeDisposable disposables = new CompositeDisposable();


// adding an Observable to the disposable
disposables.add(sampleObservable()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeWith(new DisposableObserver&lt;String&gt;() {
                    @Override
                    public void onComplete() {
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(String value) {
                    }
                }));

    static Observable&lt;String&gt; sampleObservable() {
        return Observable.defer(new Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() {
            @Override
            public ObservableSource&lt;? extends String&gt; call() throws Exception {
                // Do some long running operation
                SystemClock.sleep(2000);
                return Observable.just("one", "two", "three", "four", "five");
            }
        });
    }                


// Using clear will clear all, but can accept new disposable
disposables.clear(); 
// Using dispose will clear all and set isDisposed = true, so it will not accept any new disposable
disposables.dispose();
******************************
Normalized:
******************************
Original:
private final CompositeDisposable disposables = new CompositeDisposable();


// adding an Observable to the disposable
disposables.add(sampleObservable()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeWith(new DisposableObserver&lt;String&gt;() {
                    @Override
                    public void onComplete() {
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(String value) {
                    }
                }));

    static Observable&lt;String&gt; sampleObservable() {
        return Observable.defer(new Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() {
            @Override
            public ObservableSource&lt;? extends String&gt; call() throws Exception {
                // Do some long running operation
                SystemClock.sleep(2000);
                return Observable.just("one", "two", "three", "four", "five");
            }
        });
    }                


// Using clear will clear all, but can accept new disposable
disposables.clear(); 
// Using dispose will clear all and set isDisposed = true, so it will not accept any new disposable
disposables.dispose();
******************************
Normalized:
private final CompositeDisposable disposables = new CompositeDisposable();


// adding an Observable to the disposable
disposables.add(sampleObservable()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeWith(new DisposableObserver&lt;String&gt;() {
                    @Override
                    public void onComplete() {
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(String value) {
                    }
                }));

    static Observable&lt;String&gt; sampleObservable() {
        return Observable.defer(new Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() {
            @Override
            public ObservableSource&lt;? extends String&gt; call() throws Exception {
                // Do some long running operation
                SystemClock.sleep(2000);
                return Observable.just("one", "two", "three", "four", "five");
            }
        });
    }                


// Using clear will clear all, but can accept new disposable
disposables.clear(); 
// Using dispose will clear all and set isDisposed = true, so it will not accept any new disposable
disposables.dispose();
******************************
Original:
public void setShapeValue(int shapeValue){
  if(shapeValue &lt; 100){
    //do something here like throw exception.
  }
}
******************************
Normalized:
******************************
Original:
public void setShapeValue(int shapeValue){
  if(shapeValue &lt; 100){
    //do something here like throw exception.
  }
}
******************************
Normalized:
public void setShapeValue(int shapeValue){
  if(shapeValue &lt; 100){
    //do something here like throw exception.
  }
}
******************************
Original:
[req]
req_extensions = v3_req

[ v3_req ]
subjectAltName=IP:10.0.0.1
# or subjectAltName=DNS:www.example.com
******************************
Normalized:
******************************
Original:
[req]
req_extensions = v3_req

[ v3_req ]
subjectAltName=IP:10.0.0.1
# or subjectAltName=DNS:www.example.com
******************************
Normalized:
[req]
req_extensions = v3_req

[ v3_req ]
subjectAltName=IP:10.0.0.1
# or subjectAltName=DNS:www.example.com
******************************
Original:
List&lt;T&gt; list = Collections.list(enumeration);
******************************
Normalized:
******************************
Original:
List&lt;T&gt; list = Collections.list(enumeration);
******************************
Normalized:
List&lt;T&gt; list = Collections.list(enumeration);
******************************
Original:
public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {
    list.sort(null);
}
******************************
Normalized:
******************************
Original:
public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {
    list.sort(null);
}
******************************
Normalized:
public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {
    list.sort(null);
}
******************************
Original:
public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(
    Function&lt;? super T, ? extends K&gt; keyMapper, 
    Function&lt;? super T, ? extends U&gt; valueMapper) 
{
    return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new);
}
******************************
Normalized:
******************************
Original:
public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(
    Function&lt;? super T, ? extends K&gt; keyMapper, 
    Function&lt;? super T, ? extends U&gt; valueMapper) 
{
    return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new);
}
******************************
Normalized:
public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(
    Function&lt;? super T, ? extends K&gt; keyMapper, 
    Function&lt;? super T, ? extends U&gt; valueMapper) 
{
    return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new);
}
******************************
Original:
&lt;javac ...&gt;
    &lt;compilerarg value="-Xlint"/&gt;
  &lt;/javac&gt;
******************************
Normalized:
******************************
Original:
&lt;javac ...&gt;
    &lt;compilerarg value="-Xlint"/&gt;
  &lt;/javac&gt;
******************************
Normalized:
&lt;javac ...&gt;
    &lt;compilerarg value="-Xlint"/&gt;
  &lt;/javac&gt;
******************************
Original:
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE roles SYSTEM "roles.dtd"&gt;
&lt;roles&gt;
    &lt;role1&gt;User&lt;/role1&gt;
    &lt;role2&gt;Author&lt;/role2&gt;
    &lt;role3&gt;Admin&lt;/role3&gt;
    &lt;role4/&gt;
&lt;/roles&gt;
******************************
Normalized:
******************************
Original:
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE roles SYSTEM "roles.dtd"&gt;
&lt;roles&gt;
    &lt;role1&gt;User&lt;/role1&gt;
    &lt;role2&gt;Author&lt;/role2&gt;
    &lt;role3&gt;Admin&lt;/role3&gt;
    &lt;role4/&gt;
&lt;/roles&gt;
******************************
Normalized:
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE roles SYSTEM "roles.dtd"&gt;
&lt;roles&gt;
    &lt;role1&gt;User&lt;/role1&gt;
    &lt;role2&gt;Author&lt;/role2&gt;
    &lt;role3&gt;Admin&lt;/role3&gt;
    &lt;role4/&gt;
&lt;/roles&gt;
******************************
Original:
if (1 / x &gt; 0)
    // +0 here
else
    // -0 here
******************************
Normalized:
******************************
Original:
if (1 / x &gt; 0)
    // +0 here
else
    // -0 here
******************************
Normalized:
if (1 / x &gt; 0)
    // +0 here
else
    // -0 here
******************************
Original:
log4j.rootLogger=TRACE, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.debugLog=org.apache.log4j.FileAppender
log4j.appender.debugLog.File=logs/debug.log
log4j.appender.debugLog.layout=org.apache.log4j.PatternLayout
log4j.appender.debugLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.reportsLog=org.apache.log4j.FileAppender
log4j.appender.reportsLog.File=logs/reports.log
log4j.appender.reportsLog.layout=org.apache.log4j.PatternLayout
log4j.appender.reportsLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.category.debugLogger=TRACE, debugLog
log4j.additivity.debugLogger=false

log4j.category.reportsLogger=DEBUG, reportsLog
log4j.additivity.reportsLogger=false
******************************
Normalized:
******************************
Original:
log4j.rootLogger=TRACE, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.debugLog=org.apache.log4j.FileAppender
log4j.appender.debugLog.File=logs/debug.log
log4j.appender.debugLog.layout=org.apache.log4j.PatternLayout
log4j.appender.debugLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.reportsLog=org.apache.log4j.FileAppender
log4j.appender.reportsLog.File=logs/reports.log
log4j.appender.reportsLog.layout=org.apache.log4j.PatternLayout
log4j.appender.reportsLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.category.debugLogger=TRACE, debugLog
log4j.additivity.debugLogger=false

log4j.category.reportsLogger=DEBUG, reportsLog
log4j.additivity.reportsLogger=false
******************************
Normalized:
log4j.rootLogger=TRACE, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.debugLog=org.apache.log4j.FileAppender
log4j.appender.debugLog.File=logs/debug.log
log4j.appender.debugLog.layout=org.apache.log4j.PatternLayout
log4j.appender.debugLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.reportsLog=org.apache.log4j.FileAppender
log4j.appender.reportsLog.File=logs/reports.log
log4j.appender.reportsLog.layout=org.apache.log4j.PatternLayout
log4j.appender.reportsLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.category.debugLogger=TRACE, debugLog
log4j.additivity.debugLogger=false

log4j.category.reportsLogger=DEBUG, reportsLog
log4j.additivity.reportsLogger=false
******************************
Original:
@Override
final void forEachWithCancel(Spliterator&lt;P_OUT&gt; spliterator, Sink&lt;P_OUT&gt; sink) {
    do { } while (!sink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(sink));
}
******************************
Normalized:
******************************
Original:
@Override
final void forEachWithCancel(Spliterator&lt;P_OUT&gt; spliterator, Sink&lt;P_OUT&gt; sink) {
    do { } while (!sink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(sink));
}
******************************
Normalized:
@Override
final void forEachWithCancel(Spliterator&lt;P_OUT&gt; spliterator, Sink&lt;P_OUT&gt; sink) {
    do { } while (!sink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(sink));
}
******************************
Original:
IntPredicate neg = x -&gt; x &lt;- x;
System.out.println(neg.test(4));   // false
System.out.println(neg.test(0));   // false
System.out.println(neg.test(-4));  // true
******************************
Normalized:
******************************
Original:
IntPredicate neg = x -&gt; x &lt;- x;
System.out.println(neg.test(4));   // false
System.out.println(neg.test(0));   // false
System.out.println(neg.test(-4));  // true
******************************
Normalized:
IntPredicate neg = x -&gt; x &lt;- x;
System.out.println(neg.test(4));   // false
System.out.println(neg.test(0));   // false
System.out.println(neg.test(-4));  // true
******************************
Original:
Runnable r1=null;
    for(int i=0; i&lt;2; i++) {
        Runnable r2=System::gc;
        if(r1==null) r1=r2;
        else System.out.println(r1==r2? "shared": "unshared");
    }
******************************
Normalized:
******************************
Original:
Runnable r1=null;
    for(int i=0; i&lt;2; i++) {
        Runnable r2=System::gc;
        if(r1==null) r1=r2;
        else System.out.println(r1==r2? "shared": "unshared");
    }
******************************
Normalized:
Runnable r1=null;
    for(int i=0; i&lt;2; i++) {
        Runnable r2=System::gc;
        if(r1==null) r1=r2;
        else System.out.println(r1==r2? "shared": "unshared");
    }
******************************
Original:
char c = /* whatever */;

switch(c) {
    case 'a':
    case 'A':
        //get the 'A' image;
        break;
    case 'b':
    case 'B':
        //get the 'B' image;
        break;
    // (...)
    case 'z':
    case 'Z':
        //get the 'Z' image;
        break;
}
******************************
Normalized:
******************************
Original:
char c = /* whatever */;

switch(c) {
    case 'a':
    case 'A':
        //get the 'A' image;
        break;
    case 'b':
    case 'B':
        //get the 'B' image;
        break;
    // (...)
    case 'z':
    case 'Z':
        //get the 'Z' image;
        break;
}
******************************
Normalized:
char c = /* whatever */;

switch(c) {
    case 'a':
    case 'A':
        //get the 'A' image;
        break;
    case 'b':
    case 'B':
        //get the 'B' image;
        break;
    // (...)
    case 'z':
    case 'Z':
        //get the 'Z' image;
        break;
}
******************************
Original:
mvn -o install
******************************
Normalized:
******************************
Original:
mvn -o install
******************************
Normalized:
mvn -o install
******************************
Original:
InputStream is = entity.getContent();

.... process the input stream ....

is.close();       // releases all resources
******************************
Normalized:
******************************
Original:
InputStream is = entity.getContent();

.... process the input stream ....

is.close();       // releases all resources
******************************
Normalized:
InputStream is = entity.getContent();

.... process the input stream ....

is.close();       // releases all resources
******************************
Original:
public boolean retryingFindClick(By by) {
    boolean result = false;
    int attempts = 0;
    while(attempts &lt; 2) {
        try {
            driver.findElement(by).click();
            result = true;
            break;
        } catch(StaleElementException e) {
        }
        attempts++;
    }
    return result;
}
******************************
Normalized:
******************************
Original:
public boolean retryingFindClick(By by) {
    boolean result = false;
    int attempts = 0;
    while(attempts &lt; 2) {
        try {
            driver.findElement(by).click();
            result = true;
            break;
        } catch(StaleElementException e) {
        }
        attempts++;
    }
    return result;
}
******************************
Normalized:
public boolean retryingFindClick(By by) {
    boolean result = false;
    int attempts = 0;
    while(attempts &lt; 2) {
        try {
            driver.findElement(by).click();
            result = true;
            break;
        } catch(StaleElementException e) {
        }
        attempts++;
    }
    return result;
}
******************************
Original:
public static void main(String[] args) throws SAXException, IOException,
        ParserConfigurationException, TransformerException {

    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory
        .newInstance();
    DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
    Document document = docBuilder.parse(new File("document.xml"));
    doSomething(document.getDocumentElement());
}

public static void doSomething(Node node) {
    // do something with the current node instead of System.out
    System.out.println(node.getNodeName());

    NodeList nodeList = node.getChildNodes();
    for (int i = 0; i &lt; nodeList.getLength(); i++) {
        Node currentNode = nodeList.item(i);
        if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
            //calls this method for all the children which is Element
            doSomething(currentNode);
        }
    }
}
******************************
Normalized:
******************************
Original:
public static void main(String[] args) throws SAXException, IOException,
        ParserConfigurationException, TransformerException {

    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory
        .newInstance();
    DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
    Document document = docBuilder.parse(new File("document.xml"));
    doSomething(document.getDocumentElement());
}

public static void doSomething(Node node) {
    // do something with the current node instead of System.out
    System.out.println(node.getNodeName());

    NodeList nodeList = node.getChildNodes();
    for (int i = 0; i &lt; nodeList.getLength(); i++) {
        Node currentNode = nodeList.item(i);
        if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
            //calls this method for all the children which is Element
            doSomething(currentNode);
        }
    }
}
******************************
Normalized:
public static void main(String[] args) throws SAXException, IOException,
        ParserConfigurationException, TransformerException {

    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory
        .newInstance();
    DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
    Document document = docBuilder.parse(new File("document.xml"));
    doSomething(document.getDocumentElement());
}

public static void doSomething(Node node) {
    // do something with the current node instead of System.out
    System.out.println(node.getNodeName());

    NodeList nodeList = node.getChildNodes();
    for (int i = 0; i &lt; nodeList.getLength(); i++) {
        Node currentNode = nodeList.item(i);
        if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
            //calls this method for all the children which is Element
            doSomething(currentNode);
        }
    }
}
******************************
Original:
List&lt;V&gt; al = new ArrayList&lt;V&gt;(hashMapVar.values());
******************************
Normalized:
******************************
Original:
List&lt;V&gt; al = new ArrayList&lt;V&gt;(hashMapVar.values());
******************************
Normalized:
List&lt;V&gt; al = new ArrayList&lt;V&gt;(hashMapVar.values());
******************************
Original:
List&lt;Foo&gt; list = createItSomehow();
Random random = new Random();
Foo foo = list.get(random.nextInt(list.size()));
******************************
Normalized:
******************************
Original:
List&lt;Foo&gt; list = createItSomehow();
Random random = new Random();
Foo foo = list.get(random.nextInt(list.size()));
******************************
Normalized:
List&lt;Foo&gt; list = createItSomehow();
Random random = new Random();
Foo foo = list.get(random.nextInt(list.size()));
******************************
Original:
void callback(int val) {
    JNIEnv * g_env;
    // double check it's all ok
    int getEnvStat = g_vm-&gt;GetEnv((void **)&amp;g_env, JNI_VERSION_1_6);
    if (getEnvStat == JNI_EDETACHED) {
        std::cout &lt;&lt; "GetEnv: not attached" &lt;&lt; std::endl;
        if (g_vm-&gt;AttachCurrentThread((void **) &amp;g_env, NULL) != 0) {
            std::cout &lt;&lt; "Failed to attach" &lt;&lt; std::endl;
        }
    } else if (getEnvStat == JNI_OK) {
        //
    } else if (getEnvStat == JNI_EVERSION) {
        std::cout &lt;&lt; "GetEnv: version not supported" &lt;&lt; std::endl;
    }

    g_env-&gt;CallVoidMethod(g_obj, g_mid, val);

    if (g_env-&gt;ExceptionCheck()) {
        g_env-&gt;ExceptionDescribe();
    }

    g_vm-&gt;DetachCurrentThread();
}
******************************
Normalized:
******************************
Original:
void callback(int val) {
    JNIEnv * g_env;
    // double check it's all ok
    int getEnvStat = g_vm-&gt;GetEnv((void **)&amp;g_env, JNI_VERSION_1_6);
    if (getEnvStat == JNI_EDETACHED) {
        std::cout &lt;&lt; "GetEnv: not attached" &lt;&lt; std::endl;
        if (g_vm-&gt;AttachCurrentThread((void **) &amp;g_env, NULL) != 0) {
            std::cout &lt;&lt; "Failed to attach" &lt;&lt; std::endl;
        }
    } else if (getEnvStat == JNI_OK) {
        //
    } else if (getEnvStat == JNI_EVERSION) {
        std::cout &lt;&lt; "GetEnv: version not supported" &lt;&lt; std::endl;
    }

    g_env-&gt;CallVoidMethod(g_obj, g_mid, val);

    if (g_env-&gt;ExceptionCheck()) {
        g_env-&gt;ExceptionDescribe();
    }

    g_vm-&gt;DetachCurrentThread();
}
******************************
Normalized:
void callback(int val) {
    JNIEnv * g_env;
    // double check it's all ok
    int getEnvStat = g_vm-&gt;GetEnv((void **)&amp;g_env, JNI_VERSION_1_6);
    if (getEnvStat == JNI_EDETACHED) {
        std::cout &lt;&lt; "GetEnv: not attached" &lt;&lt; std::endl;
        if (g_vm-&gt;AttachCurrentThread((void **) &amp;g_env, NULL) != 0) {
            std::cout &lt;&lt; "Failed to attach" &lt;&lt; std::endl;
        }
    } else if (getEnvStat == JNI_OK) {
        //
    } else if (getEnvStat == JNI_EVERSION) {
        std::cout &lt;&lt; "GetEnv: version not supported" &lt;&lt; std::endl;
    }

    g_env-&gt;CallVoidMethod(g_obj, g_mid, val);

    if (g_env-&gt;ExceptionCheck()) {
        g_env-&gt;ExceptionDescribe();
    }

    g_vm-&gt;DetachCurrentThread();
}
******************************
Original:
&lt;dependency&gt;
    &lt;groupId&gt;postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;version&gt;VERSION&lt;/version&gt;
&lt;/dependency&gt;
******************************
Normalized:
******************************
Original:
&lt;dependency&gt;
    &lt;groupId&gt;postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;version&gt;VERSION&lt;/version&gt;
&lt;/dependency&gt;
******************************
Normalized:
&lt;dependency&gt;
    &lt;groupId&gt;postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;version&gt;VERSION&lt;/version&gt;
&lt;/dependency&gt;
******************************
Original:
byte[] bytes = new byte[10];
Byte[] byteObjects = new Byte[bytes.length];

int i=0;    
// Associating Byte array values with bytes. (byte[] to Byte[])
for(byte b: bytes)
   byteObjects[i++] = b;  // Autoboxing.

....

int j=0;
// Unboxing Byte values. (Byte[] to byte[])
for(Byte b: byteObjects)
    bytes[j++] = b.byteValue();
******************************
Normalized:
******************************
Original:
byte[] bytes = new byte[10];
Byte[] byteObjects = new Byte[bytes.length];

int i=0;    
// Associating Byte array values with bytes. (byte[] to Byte[])
for(byte b: bytes)
   byteObjects[i++] = b;  // Autoboxing.

....

int j=0;
// Unboxing Byte values. (Byte[] to byte[])
for(Byte b: byteObjects)
    bytes[j++] = b.byteValue();
******************************
Normalized:
byte[] bytes = new byte[10];
Byte[] byteObjects = new Byte[bytes.length];

int i=0;    
// Associating Byte array values with bytes. (byte[] to Byte[])
for(byte b: bytes)
   byteObjects[i++] = b;  // Autoboxing.

....

int j=0;
// Unboxing Byte values. (Byte[] to byte[])
for(Byte b: byteObjects)
    bytes[j++] = b.byteValue();
******************************
Original:
val arrayOfZeros = IntArray(size) //equivalent in Java: new int[size]
val numbersFromOne = IntArray(size) { it + 1 }
val myInts = intArrayOf(1, 1, 2, 3, 5, 8, 13, 21)
******************************
Normalized:
******************************
Original:
val arrayOfZeros = IntArray(size) //equivalent in Java: new int[size]
val numbersFromOne = IntArray(size) { it + 1 }
val myInts = intArrayOf(1, 1, 2, 3, 5, 8, 13, 21)
******************************
Normalized:
val arrayOfZeros = IntArray(size) //equivalent in Java: new int[size]
val numbersFromOne = IntArray(size) { it + 1 }
val myInts = intArrayOf(1, 1, 2, 3, 5, 8, 13, 21)
******************************
Original:
&lt;FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:id="@+id/root_view"&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText1"
        android:layout_height="fill_parent"&gt;
    &lt;/EditText&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText2"
        android:layout_height="fill_parent"&gt;
        &lt;requestFocus&gt;&lt;/requestFocus&gt;
    &lt;/EditText&gt;

&lt;/FrameLayout&gt;
******************************
Normalized:
******************************
Original:
&lt;FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:id="@+id/root_view"&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText1"
        android:layout_height="fill_parent"&gt;
    &lt;/EditText&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText2"
        android:layout_height="fill_parent"&gt;
        &lt;requestFocus&gt;&lt;/requestFocus&gt;
    &lt;/EditText&gt;

&lt;/FrameLayout&gt;
******************************
Normalized:
&lt;FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:id="@+id/root_view"&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText1"
        android:layout_height="fill_parent"&gt;
    &lt;/EditText&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText2"
        android:layout_height="fill_parent"&gt;
        &lt;requestFocus&gt;&lt;/requestFocus&gt;
    &lt;/EditText&gt;

&lt;/FrameLayout&gt;
******************************
Original:
public boolean AndSC(int x, int value, int y) {
    return value &gt;= x &amp;&amp; value &lt;= y;
}

public boolean AndNonSC(int x, int value, int y) {
    return value &gt;= x &amp; value &lt;= y;
}
******************************
Normalized:
******************************
Original:
public boolean AndSC(int x, int value, int y) {
    return value &gt;= x &amp;&amp; value &lt;= y;
}

public boolean AndNonSC(int x, int value, int y) {
    return value &gt;= x &amp; value &lt;= y;
}
******************************
Normalized:
public boolean AndSC(int x, int value, int y) {
    return value &gt;= x &amp;&amp; value &lt;= y;
}

public boolean AndNonSC(int x, int value, int y) {
    return value &gt;= x &amp; value &lt;= y;
}
******************************
Original:
&lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt;
******************************
Normalized:
******************************
Original:
&lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt;
******************************
Normalized:
&lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt;
******************************
Original:
sudo apt-get install openjdk-11-jdk
******************************
Normalized:
******************************
Original:
sudo apt-get install openjdk-11-jdk
******************************
Normalized:
sudo apt-get install openjdk-11-jdk
******************************
Original:
@Configuration
@EnableScheduling
public class SpringConfiguration {

    @Bean(destroyMethod = "shutdown")
    public Executor taskScheduler() {
        return Executors.newScheduledThreadPool(5);
    }
    ...
******************************
Normalized:
******************************
Original:
@Configuration
@EnableScheduling
public class SpringConfiguration {

    @Bean(destroyMethod = "shutdown")
    public Executor taskScheduler() {
        return Executors.newScheduledThreadPool(5);
    }
    ...
******************************
Normalized:
@Configuration
@EnableScheduling
public class SpringConfiguration {

    @Bean(destroyMethod = "shutdown")
    public Executor taskScheduler() {
        return Executors.newScheduledThreadPool(5);
    }
    ...
******************************
Original:
@Autowired
private Item&lt;String&gt; strItem; // Injects the stringItem bean

@Autowired
private Item&lt;Integer&gt; intItem; // Injects the integerItem bean
******************************
Normalized:
******************************
Original:
@Autowired
private Item&lt;String&gt; strItem; // Injects the stringItem bean

@Autowired
private Item&lt;Integer&gt; intItem; // Injects the integerItem bean
******************************
Normalized:
@Autowired
private Item&lt;String&gt; strItem; // Injects the stringItem bean

@Autowired
private Item&lt;Integer&gt; intItem; // Injects the integerItem bean
******************************
Original:
Project
| src
| | main
|   | java
|     | [your source code]
|   | resources
|     | META-INF
|       | services
|         | [your service files]
******************************
Normalized:
******************************
Original:
Project
| src
| | main
|   | java
|     | [your source code]
|   | resources
|     | META-INF
|       | services
|         | [your service files]
******************************
Normalized:
Project
| src
| | main
|   | java
|     | [your source code]
|   | resources
|     | META-INF
|       | services
|         | [your service files]
******************************
Original:
import org.springframework.batch.item.ItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("foo-reader")
@Scope("step")
public final class MyReader implements ItemReader&lt;MyData&gt; {
  @Override
  public MyData read() throws Exception {
    //...
  }

  @Value("#{jobParameters['fileName']}")
  public void setFileName(final String name) {
    //...
  }
}
******************************
Normalized:
******************************
Original:
import org.springframework.batch.item.ItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("foo-reader")
@Scope("step")
public final class MyReader implements ItemReader&lt;MyData&gt; {
  @Override
  public MyData read() throws Exception {
    //...
  }

  @Value("#{jobParameters['fileName']}")
  public void setFileName(final String name) {
    //...
  }
}
******************************
Normalized:
import org.springframework.batch.item.ItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("foo-reader")
@Scope("step")
public final class MyReader implements ItemReader&lt;MyData&gt; {
  @Override
  public MyData read() throws Exception {
    //...
  }

  @Value("#{jobParameters['fileName']}")
  public void setFileName(final String name) {
    //...
  }
}
******************************
Original:
Object[] array;
for(Object o : array) { }
Iterable&lt;Object&gt; list;
for(Object o : list) { }
Iterator&lt;Object&gt; iter;
while(iter.hasNext()) { Object o = iter.next(); }
******************************
Normalized:
******************************
Original:
Object[] array;
for(Object o : array) { }
Iterable&lt;Object&gt; list;
for(Object o : list) { }
Iterator&lt;Object&gt; iter;
while(iter.hasNext()) { Object o = iter.next(); }
******************************
Normalized:
Object[] array;
for(Object o : array) { }
Iterable&lt;Object&gt; list;
for(Object o : list) { }
Iterator&lt;Object&gt; iter;
while(iter.hasNext()) { Object o = iter.next(); }
******************************
Original:
import java.text.Normalizer;

public static String stripAccents(String s) 
{
    s = Normalizer.normalize(s, Normalizer.Form.NFD);
    s = s.replaceAll("[\\p{InCombiningDiacriticalMarks}]", "");
    return s;
}
******************************
Normalized:
******************************
Original:
import java.text.Normalizer;

public static String stripAccents(String s) 
{
    s = Normalizer.normalize(s, Normalizer.Form.NFD);
    s = s.replaceAll("[\\p{InCombiningDiacriticalMarks}]", "");
    return s;
}
******************************
Normalized:
import java.text.Normalizer;

public static String stripAccents(String s) 
{
    s = Normalizer.normalize(s, Normalizer.Form.NFD);
    s = s.replaceAll("[\\p{InCombiningDiacriticalMarks}]", "");
    return s;
}
******************************
Original:
public class CustomJsonDateDeserializer extends JsonDeserializer&lt;Date&gt;
{
    @Override
    public Date deserialize(JsonParser jsonParser,
            DeserializationContext deserializationContext) throws IOException, JsonProcessingException {

        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
        String date = jsonParser.getText();
        try {
            return format.parse(date);
        } catch (ParseException e) {
            throw new RuntimeException(e);
        }

    }

}
******************************
Normalized:
******************************
Original:
public class CustomJsonDateDeserializer extends JsonDeserializer&lt;Date&gt;
{
    @Override
    public Date deserialize(JsonParser jsonParser,
            DeserializationContext deserializationContext) throws IOException, JsonProcessingException {

        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
        String date = jsonParser.getText();
        try {
            return format.parse(date);
        } catch (ParseException e) {
            throw new RuntimeException(e);
        }

    }

}
******************************
Normalized:
public class CustomJsonDateDeserializer extends JsonDeserializer&lt;Date&gt;
{
    @Override
    public Date deserialize(JsonParser jsonParser,
            DeserializationContext deserializationContext) throws IOException, JsonProcessingException {

        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
        String date = jsonParser.getText();
        try {
            return format.parse(date);
        } catch (ParseException e) {
            throw new RuntimeException(e);
        }

    }

}
******************************
Original:
00 00 00 00 =&gt; (byte) 0
00 00 00 01 =&gt; (byte) 1
00 00 00 10 =&gt; (byte) 2
...
01 11 11 11 =&gt; (byte) Byte.MAX_VALUE
******************************
Normalized:
******************************
Original:
00 00 00 00 =&gt; (byte) 0
00 00 00 01 =&gt; (byte) 1
00 00 00 10 =&gt; (byte) 2
...
01 11 11 11 =&gt; (byte) Byte.MAX_VALUE
******************************
Normalized:
00 00 00 00 =&gt; (byte) 0
00 00 00 01 =&gt; (byte) 1
00 00 00 10 =&gt; (byte) 2
...
01 11 11 11 =&gt; (byte) Byte.MAX_VALUE
******************************
Original:
!StringUtils.isAlphanumeric(String)
******************************
Normalized:
******************************
Original:
!StringUtils.isAlphanumeric(String)
******************************
Normalized:
!StringUtils.isAlphanumeric(String)
******************************
Original:
#
# Build stage
#
FROM maven:3.6.0-jdk-11-slim AS build
COPY src /home/app/src
COPY pom.xml /home/app
RUN mvn -f /home/app/pom.xml clean package

#
# Package stage
#
FROM openjdk:11-jre-slim
COPY --from=build /home/app/target/demo-0.0.1-SNAPSHOT.jar /usr/local/lib/demo.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","/usr/local/lib/demo.jar"]
******************************
Normalized:
******************************
Original:
#
# Build stage
#
FROM maven:3.6.0-jdk-11-slim AS build
COPY src /home/app/src
COPY pom.xml /home/app
RUN mvn -f /home/app/pom.xml clean package

#
# Package stage
#
FROM openjdk:11-jre-slim
COPY --from=build /home/app/target/demo-0.0.1-SNAPSHOT.jar /usr/local/lib/demo.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","/usr/local/lib/demo.jar"]
******************************
Normalized:
#
# Build stage
#
FROM maven:3.6.0-jdk-11-slim AS build
COPY src /home/app/src
COPY pom.xml /home/app
RUN mvn -f /home/app/pom.xml clean package

#
# Package stage
#
FROM openjdk:11-jre-slim
COPY --from=build /home/app/target/demo-0.0.1-SNAPSHOT.jar /usr/local/lib/demo.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","/usr/local/lib/demo.jar"]
******************************
Original:
set.removeIf(item -&gt; {
    if (!item.qualify())
        return false;
    item.operate();
    return true;
});
******************************
Normalized:
******************************
Original:
set.removeIf(item -&gt; {
    if (!item.qualify())
        return false;
    item.operate();
    return true;
});
******************************
Normalized:
set.removeIf(item -&gt; {
    if (!item.qualify())
        return false;
    item.operate();
    return true;
});
******************************
Original:
List&lt;String&gt; numbers = Arrays.asList("zero", "one", "two");
ListIterator&lt;String&gt; it = numbers.listIterator();
while (it.hasNext()) {
    System.out.println(it.nextIndex() + " " + it.next());
}
******************************
Normalized:
******************************
Original:
List&lt;String&gt; numbers = Arrays.asList("zero", "one", "two");
ListIterator&lt;String&gt; it = numbers.listIterator();
while (it.hasNext()) {
    System.out.println(it.nextIndex() + " " + it.next());
}
******************************
Normalized:
List&lt;String&gt; numbers = Arrays.asList("zero", "one", "two");
ListIterator&lt;String&gt; it = numbers.listIterator();
while (it.hasNext()) {
    System.out.println(it.nextIndex() + " " + it.next());
}
******************************
Original:
public class MyAdapter extends Adapter {
     private Context context;

     public MyAdapter(Context context) {
          this.context = context;     
     }

     public View getView(...){
         View v;
         v.setOnClickListener(new OnClickListener() {
             void onClick() {
                 context.startActivity(...);
             }
         });
     }
}
******************************
Normalized:
******************************
Original:
public class MyAdapter extends Adapter {
     private Context context;

     public MyAdapter(Context context) {
          this.context = context;     
     }

     public View getView(...){
         View v;
         v.setOnClickListener(new OnClickListener() {
             void onClick() {
                 context.startActivity(...);
             }
         });
     }
}
******************************
Normalized:
public class MyAdapter extends Adapter {
     private Context context;

     public MyAdapter(Context context) {
          this.context = context;     
     }

     public View getView(...){
         View v;
         v.setOnClickListener(new OnClickListener() {
             void onClick() {
                 context.startActivity(...);
             }
         });
     }
}
******************************
Original:
sudo apt-get install openjdk-11-jdk
******************************
Normalized:
******************************
Original:
sudo apt-get install openjdk-11-jdk
******************************
Normalized:
sudo apt-get install openjdk-11-jdk
******************************
Original:
double[] target = new double[doubles.size()];
 for (int i = 0; i &lt; target.length; i++) {
    target[i] = doubles.get(i).doubleValue();  // java 1.4 style
    // or:
    target[i] = doubles.get(i);                // java 1.5+ style (outboxing)
 }
******************************
Normalized:
******************************
Original:
double[] target = new double[doubles.size()];
 for (int i = 0; i &lt; target.length; i++) {
    target[i] = doubles.get(i).doubleValue();  // java 1.4 style
    // or:
    target[i] = doubles.get(i);                // java 1.5+ style (outboxing)
 }
******************************
Normalized:
double[] target = new double[doubles.size()];
 for (int i = 0; i &lt; target.length; i++) {
    target[i] = doubles.get(i).doubleValue();  // java 1.4 style
    // or:
    target[i] = doubles.get(i);                // java 1.5+ style (outboxing)
 }
******************************
Original:
List&lt;Email&gt; findByEmailIdInAndPincodeIn(List&lt;String&gt; emails, List&lt;String&gt; pinCodes);
******************************
Normalized:
******************************
Original:
List&lt;Email&gt; findByEmailIdInAndPincodeIn(List&lt;String&gt; emails, List&lt;String&gt; pinCodes);
******************************
Normalized:
List&lt;Email&gt; findByEmailIdInAndPincodeIn(List&lt;String&gt; emails, List&lt;String&gt; pinCodes);
******************************
Original:
.andExpect(jsonPath("$.password").doesNotExist())
******************************
Normalized:
******************************
Original:
.andExpect(jsonPath("$.password").doesNotExist())
******************************
Normalized:
.andExpect(jsonPath("$.password").doesNotExist())
******************************
Original:
class SomethingSyncd {
    @Synchronized fun syncFoo() {

    }

    val myLock = Any()

    fun foo() {
        synchronized(myLock) {
            // ... code
        }
    }

    @Volatile var thing = mapOf(...)
}
******************************
Normalized:
******************************
Original:
class SomethingSyncd {
    @Synchronized fun syncFoo() {

    }

    val myLock = Any()

    fun foo() {
        synchronized(myLock) {
            // ... code
        }
    }

    @Volatile var thing = mapOf(...)
}
******************************
Normalized:
class SomethingSyncd {
    @Synchronized fun syncFoo() {

    }

    val myLock = Any()

    fun foo() {
        synchronized(myLock) {
            // ... code
        }
    }

    @Volatile var thing = mapOf(...)
}
******************************
Original:
private fun &lt;T&gt; anyObject(): T {
    Mockito.anyObject&lt;T&gt;()
    return uninitialized()
}

private fun &lt;T&gt; uninitialized(): T = null as T

@Test
fun myTest() {
    `when`(mockedBackend).login(anyObject())).thenAnswer { ... }
}
******************************
Normalized:
******************************
Original:
private fun &lt;T&gt; anyObject(): T {
    Mockito.anyObject&lt;T&gt;()
    return uninitialized()
}

private fun &lt;T&gt; uninitialized(): T = null as T

@Test
fun myTest() {
    `when`(mockedBackend).login(anyObject())).thenAnswer { ... }
}
******************************
Normalized:
private fun &lt;T&gt; anyObject(): T {
    Mockito.anyObject&lt;T&gt;()
    return uninitialized()
}

private fun &lt;T&gt; uninitialized(): T = null as T

@Test
fun myTest() {
    `when`(mockedBackend).login(anyObject())).thenAnswer { ... }
}
******************************
Original:
public final class SupplierUtils {
    private SupplierUtils() {
    }

    public static &lt;T&gt; Supplier&lt;T&gt; wrap(Callable&lt;T&gt; callable) {
        return () -&gt; {
            try {
                return callable.call();
            }
            catch (RuntimeException e) {
                throw e;
            }
            catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
}

public class JdbcConnectionPool extends ObjectPool&lt;Connection&gt; {

    public JdbcConnectionPool(int maxConnections, String url) {
        super(SupplierUtils.wrap(() -&gt; DriverManager.getConnection(url)), maxConnections);
    }
}
******************************
Normalized:
******************************
Original:
public final class SupplierUtils {
    private SupplierUtils() {
    }

    public static &lt;T&gt; Supplier&lt;T&gt; wrap(Callable&lt;T&gt; callable) {
        return () -&gt; {
            try {
                return callable.call();
            }
            catch (RuntimeException e) {
                throw e;
            }
            catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
}

public class JdbcConnectionPool extends ObjectPool&lt;Connection&gt; {

    public JdbcConnectionPool(int maxConnections, String url) {
        super(SupplierUtils.wrap(() -&gt; DriverManager.getConnection(url)), maxConnections);
    }
}
******************************
Normalized:
public final class SupplierUtils {
    private SupplierUtils() {
    }

    public static &lt;T&gt; Supplier&lt;T&gt; wrap(Callable&lt;T&gt; callable) {
        return () -&gt; {
            try {
                return callable.call();
            }
            catch (RuntimeException e) {
                throw e;
            }
            catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
}

public class JdbcConnectionPool extends ObjectPool&lt;Connection&gt; {

    public JdbcConnectionPool(int maxConnections, String url) {
        super(SupplierUtils.wrap(() -&gt; DriverManager.getConnection(url)), maxConnections);
    }
}
******************************
Original:
/**
 * This resolver handles command objects annotated with @SupportsAnnotationParameterResolution
 * that are passed as parameters to controller methods.
 * 
 * It parses @CommandPerameter annotations on command objects to
 * populate the Binder with the appropriate values (that is, the filed names
 * corresponding to the GET parameters)
 * 
 * In order to achieve this, small pieces of code are copied from spring-mvc
 * classes (indicated in-place). The alternative to the copied lines would be to
 * have a decorator around the Binder, but that would be more tedious, and still
 * some methods would need to be copied.
 * 
 * @author bozho
 * 
 */
public class AnnotationServletModelAttributeResolver extends ServletModelAttributeMethodProcessor {

    /**
     * A map caching annotation definitions of command objects (@CommandParameter-to-fieldname mappings)
     */
    private ConcurrentMap&lt;Class&lt;?&gt;, Map&lt;String, String&gt;&gt; definitionsCache = Maps.newConcurrentMap();

    public AnnotationServletModelAttributeResolver(boolean annotationNotRequired) {
        super(annotationNotRequired);
    }

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        if (parameter.getParameterType().isAnnotationPresent(SupportsAnnotationParameterResolution.class)) {
            return true;
        }
        return false;
    }

    @Override
    protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
        ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);
        ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
        bind(servletRequest, servletBinder);
    }

    @SuppressWarnings("unchecked")
    public void bind(ServletRequest request, ServletRequestDataBinder binder) {
        Map&lt;String, ?&gt; propertyValues = parsePropertyValues(request, binder);
        MutablePropertyValues mpvs = new MutablePropertyValues(propertyValues);
        MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);
        if (multipartRequest != null) {
            bindMultipart(multipartRequest.getMultiFileMap(), mpvs);
        }

        // two lines copied from ExtendedServletRequestDataBinder
        String attr = HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;
        mpvs.addPropertyValues((Map&lt;String, String&gt;) request.getAttribute(attr));
        binder.bind(mpvs);
    }

    private Map&lt;String, ?&gt; parsePropertyValues(ServletRequest request, ServletRequestDataBinder binder) {

        // similar to WebUtils.getParametersStartingWith(..) (prefixes not supported)
        Map&lt;String, Object&gt; params = Maps.newTreeMap();
        Assert.notNull(request, "Request must not be null");
        Enumeration&lt;?&gt; paramNames = request.getParameterNames();
        Map&lt;String, String&gt; parameterMappings = getParameterMappings(binder);
        while (paramNames != null &amp;&amp; paramNames.hasMoreElements()) {
            String paramName = (String) paramNames.nextElement();
            String[] values = request.getParameterValues(paramName);

            String fieldName = parameterMappings.get(paramName);
            // no annotation exists, use the default - the param name=field name
            if (fieldName == null) {
                fieldName = paramName;
            }

            if (values == null || values.length == 0) {
                // Do nothing, no values found at all.
            } else if (values.length &gt; 1) {
                params.put(fieldName, values);
            } else {
                params.put(fieldName, values[0]);
            }
        }

        return params;
    }

    /**
     * Gets a mapping between request parameter names and field names.
     * If no annotation is specified, no entry is added
     * @return
     */
    private Map&lt;String, String&gt; getParameterMappings(ServletRequestDataBinder binder) {
        Class&lt;?&gt; targetClass = binder.getTarget().getClass();
        Map&lt;String, String&gt; map = definitionsCache.get(targetClass);
        if (map == null) {
            Field[] fields = targetClass.getDeclaredFields();
            map = Maps.newHashMapWithExpectedSize(fields.length);
            for (Field field : fields) {
                CommandParameter annotation = field.getAnnotation(CommandParameter.class);
                if (annotation != null &amp;&amp; !annotation.value().isEmpty()) {
                    map.put(annotation.value(), field.getName());
                }
            }
            definitionsCache.putIfAbsent(targetClass, map);
            return map;
        } else {
            return map;
        }
    }

    /**
     * Copied from WebDataBinder.
     * 
     * @param multipartFiles
     * @param mpvs
     */
    protected void bindMultipart(Map&lt;String, List&lt;MultipartFile&gt;&gt; multipartFiles, MutablePropertyValues mpvs) {
        for (Map.Entry&lt;String, List&lt;MultipartFile&gt;&gt; entry : multipartFiles.entrySet()) {
            String key = entry.getKey();
            List&lt;MultipartFile&gt; values = entry.getValue();
            if (values.size() == 1) {
                MultipartFile value = values.get(0);
                if (!value.isEmpty()) {
                    mpvs.add(key, value);
                }
            } else {
                mpvs.add(key, values);
            }
        }
    }
}
******************************
Normalized:
******************************
Original:
/**
 * This resolver handles command objects annotated with @SupportsAnnotationParameterResolution
 * that are passed as parameters to controller methods.
 * 
 * It parses @CommandPerameter annotations on command objects to
 * populate the Binder with the appropriate values (that is, the filed names
 * corresponding to the GET parameters)
 * 
 * In order to achieve this, small pieces of code are copied from spring-mvc
 * classes (indicated in-place). The alternative to the copied lines would be to
 * have a decorator around the Binder, but that would be more tedious, and still
 * some methods would need to be copied.
 * 
 * @author bozho
 * 
 */
public class AnnotationServletModelAttributeResolver extends ServletModelAttributeMethodProcessor {

    /**
     * A map caching annotation definitions of command objects (@CommandParameter-to-fieldname mappings)
     */
    private ConcurrentMap&lt;Class&lt;?&gt;, Map&lt;String, String&gt;&gt; definitionsCache = Maps.newConcurrentMap();

    public AnnotationServletModelAttributeResolver(boolean annotationNotRequired) {
        super(annotationNotRequired);
    }

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        if (parameter.getParameterType().isAnnotationPresent(SupportsAnnotationParameterResolution.class)) {
            return true;
        }
        return false;
    }

    @Override
    protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
        ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);
        ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
        bind(servletRequest, servletBinder);
    }

    @SuppressWarnings("unchecked")
    public void bind(ServletRequest request, ServletRequestDataBinder binder) {
        Map&lt;String, ?&gt; propertyValues = parsePropertyValues(request, binder);
        MutablePropertyValues mpvs = new MutablePropertyValues(propertyValues);
        MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);
        if (multipartRequest != null) {
            bindMultipart(multipartRequest.getMultiFileMap(), mpvs);
        }

        // two lines copied from ExtendedServletRequestDataBinder
        String attr = HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;
        mpvs.addPropertyValues((Map&lt;String, String&gt;) request.getAttribute(attr));
        binder.bind(mpvs);
    }

    private Map&lt;String, ?&gt; parsePropertyValues(ServletRequest request, ServletRequestDataBinder binder) {

        // similar to WebUtils.getParametersStartingWith(..) (prefixes not supported)
        Map&lt;String, Object&gt; params = Maps.newTreeMap();
        Assert.notNull(request, "Request must not be null");
        Enumeration&lt;?&gt; paramNames = request.getParameterNames();
        Map&lt;String, String&gt; parameterMappings = getParameterMappings(binder);
        while (paramNames != null &amp;&amp; paramNames.hasMoreElements()) {
            String paramName = (String) paramNames.nextElement();
            String[] values = request.getParameterValues(paramName);

            String fieldName = parameterMappings.get(paramName);
            // no annotation exists, use the default - the param name=field name
            if (fieldName == null) {
                fieldName = paramName;
            }

            if (values == null || values.length == 0) {
                // Do nothing, no values found at all.
            } else if (values.length &gt; 1) {
                params.put(fieldName, values);
            } else {
                params.put(fieldName, values[0]);
            }
        }

        return params;
    }

    /**
     * Gets a mapping between request parameter names and field names.
     * If no annotation is specified, no entry is added
     * @return
     */
    private Map&lt;String, String&gt; getParameterMappings(ServletRequestDataBinder binder) {
        Class&lt;?&gt; targetClass = binder.getTarget().getClass();
        Map&lt;String, String&gt; map = definitionsCache.get(targetClass);
        if (map == null) {
            Field[] fields = targetClass.getDeclaredFields();
            map = Maps.newHashMapWithExpectedSize(fields.length);
            for (Field field : fields) {
                CommandParameter annotation = field.getAnnotation(CommandParameter.class);
                if (annotation != null &amp;&amp; !annotation.value().isEmpty()) {
                    map.put(annotation.value(), field.getName());
                }
            }
            definitionsCache.putIfAbsent(targetClass, map);
            return map;
        } else {
            return map;
        }
    }

    /**
     * Copied from WebDataBinder.
     * 
     * @param multipartFiles
     * @param mpvs
     */
    protected void bindMultipart(Map&lt;String, List&lt;MultipartFile&gt;&gt; multipartFiles, MutablePropertyValues mpvs) {
        for (Map.Entry&lt;String, List&lt;MultipartFile&gt;&gt; entry : multipartFiles.entrySet()) {
            String key = entry.getKey();
            List&lt;MultipartFile&gt; values = entry.getValue();
            if (values.size() == 1) {
                MultipartFile value = values.get(0);
                if (!value.isEmpty()) {
                    mpvs.add(key, value);
                }
            } else {
                mpvs.add(key, values);
            }
        }
    }
}
******************************
Normalized:
/**
 * This resolver handles command objects annotated with @SupportsAnnotationParameterResolution
 * that are passed as parameters to controller methods.
 * 
 * It parses @CommandPerameter annotations on command objects to
 * populate the Binder with the appropriate values (that is, the filed names
 * corresponding to the GET parameters)
 * 
 * In order to achieve this, small pieces of code are copied from spring-mvc
 * classes (indicated in-place). The alternative to the copied lines would be to
 * have a decorator around the Binder, but that would be more tedious, and still
 * some methods would need to be copied.
 * 
 * @author bozho
 * 
 */
public class AnnotationServletModelAttributeResolver extends ServletModelAttributeMethodProcessor {

    /**
     * A map caching annotation definitions of command objects (@CommandParameter-to-fieldname mappings)
     */
    private ConcurrentMap&lt;Class&lt;?&gt;, Map&lt;String, String&gt;&gt; definitionsCache = Maps.newConcurrentMap();

    public AnnotationServletModelAttributeResolver(boolean annotationNotRequired) {
        super(annotationNotRequired);
    }

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        if (parameter.getParameterType().isAnnotationPresent(SupportsAnnotationParameterResolution.class)) {
            return true;
        }
        return false;
    }

    @Override
    protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
        ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);
        ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
        bind(servletRequest, servletBinder);
    }

    @SuppressWarnings("unchecked")
    public void bind(ServletRequest request, ServletRequestDataBinder binder) {
        Map&lt;String, ?&gt; propertyValues = parsePropertyValues(request, binder);
        MutablePropertyValues mpvs = new MutablePropertyValues(propertyValues);
        MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);
        if (multipartRequest != null) {
            bindMultipart(multipartRequest.getMultiFileMap(), mpvs);
        }

        // two lines copied from ExtendedServletRequestDataBinder
        String attr = HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;
        mpvs.addPropertyValues((Map&lt;String, String&gt;) request.getAttribute(attr));
        binder.bind(mpvs);
    }

    private Map&lt;String, ?&gt; parsePropertyValues(ServletRequest request, ServletRequestDataBinder binder) {

        // similar to WebUtils.getParametersStartingWith(..) (prefixes not supported)
        Map&lt;String, Object&gt; params = Maps.newTreeMap();
        Assert.notNull(request, "Request must not be null");
        Enumeration&lt;?&gt; paramNames = request.getParameterNames();
        Map&lt;String, String&gt; parameterMappings = getParameterMappings(binder);
        while (paramNames != null &amp;&amp; paramNames.hasMoreElements()) {
            String paramName = (String) paramNames.nextElement();
            String[] values = request.getParameterValues(paramName);

            String fieldName = parameterMappings.get(paramName);
            // no annotation exists, use the default - the param name=field name
            if (fieldName == null) {
                fieldName = paramName;
            }

            if (values == null || values.length == 0) {
                // Do nothing, no values found at all.
            } else if (values.length &gt; 1) {
                params.put(fieldName, values);
            } else {
                params.put(fieldName, values[0]);
            }
        }

        return params;
    }

    /**
     * Gets a mapping between request parameter names and field names.
     * If no annotation is specified, no entry is added
     * @return
     */
    private Map&lt;String, String&gt; getParameterMappings(ServletRequestDataBinder binder) {
        Class&lt;?&gt; targetClass = binder.getTarget().getClass();
        Map&lt;String, String&gt; map = definitionsCache.get(targetClass);
        if (map == null) {
            Field[] fields = targetClass.getDeclaredFields();
            map = Maps.newHashMapWithExpectedSize(fields.length);
            for (Field field : fields) {
                CommandParameter annotation = field.getAnnotation(CommandParameter.class);
                if (annotation != null &amp;&amp; !annotation.value().isEmpty()) {
                    map.put(annotation.value(), field.getName());
                }
            }
            definitionsCache.putIfAbsent(targetClass, map);
            return map;
        } else {
            return map;
        }
    }

    /**
     * Copied from WebDataBinder.
     * 
     * @param multipartFiles
     * @param mpvs
     */
    protected void bindMultipart(Map&lt;String, List&lt;MultipartFile&gt;&gt; multipartFiles, MutablePropertyValues mpvs) {
        for (Map.Entry&lt;String, List&lt;MultipartFile&gt;&gt; entry : multipartFiles.entrySet()) {
            String key = entry.getKey();
            List&lt;MultipartFile&gt; values = entry.getValue();
            if (values.size() == 1) {
                MultipartFile value = values.get(0);
                if (!value.isEmpty()) {
                    mpvs.add(key, value);
                }
            } else {
                mpvs.add(key, values);
            }
        }
    }
}
******************************
Original:
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:id="@+id/mainLayout"
  android:descendantFocusability="beforeDescendants"
  android:focusableInTouchMode="true" &gt;

    &lt;EditText
        android:id="@+id/password"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@+id/changePass"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="167dp"
        android:ems="10"
        android:imeOptions="flagNoExtractUi"
        android:inputType="textPassword"
        android:maxLength="30" &gt;
    &lt;/EditText&gt;

&lt;/RelativeLayout&gt;
******************************
Normalized:
******************************
Original:
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:id="@+id/mainLayout"
  android:descendantFocusability="beforeDescendants"
  android:focusableInTouchMode="true" &gt;

    &lt;EditText
        android:id="@+id/password"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@+id/changePass"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="167dp"
        android:ems="10"
        android:imeOptions="flagNoExtractUi"
        android:inputType="textPassword"
        android:maxLength="30" &gt;
    &lt;/EditText&gt;

&lt;/RelativeLayout&gt;
******************************
Normalized:
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:id="@+id/mainLayout"
  android:descendantFocusability="beforeDescendants"
  android:focusableInTouchMode="true" &gt;

    &lt;EditText
        android:id="@+id/password"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@+id/changePass"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="167dp"
        android:ems="10"
        android:imeOptions="flagNoExtractUi"
        android:inputType="textPassword"
        android:maxLength="30" &gt;
    &lt;/EditText&gt;

&lt;/RelativeLayout&gt;
******************************
Original:
[Desktop Entry]                                                                 
Encoding=UTF-8
Name=IntelliJ IDEA
Comment=IntelliJ IDEA
Exec=/opt/ideaIC-14.1.2/bin/idea.sh
Icon=/opt/ideaIC-14.1.2/bin/idea.png
Terminal=false
StartupNotify=true
Type=Application
******************************
Normalized:
******************************
Original:
[Desktop Entry]                                                                 
Encoding=UTF-8
Name=IntelliJ IDEA
Comment=IntelliJ IDEA
Exec=/opt/ideaIC-14.1.2/bin/idea.sh
Icon=/opt/ideaIC-14.1.2/bin/idea.png
Terminal=false
StartupNotify=true
Type=Application
******************************
Normalized:
[Desktop Entry]                                                                 
Encoding=UTF-8
Name=IntelliJ IDEA
Comment=IntelliJ IDEA
Exec=/opt/ideaIC-14.1.2/bin/idea.sh
Icon=/opt/ideaIC-14.1.2/bin/idea.png
Terminal=false
StartupNotify=true
Type=Application
******************************
Original:
Throwable getRootCause(Throwable throwable)
******************************
Normalized:
******************************
Original:
Throwable getRootCause(Throwable throwable)
******************************
Normalized:
Throwable getRootCause(Throwable throwable)
******************************
Original:
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.1&lt;/version&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;download-sources&lt;/id&gt;
        &lt;goals&gt;
          &lt;goal&gt;sources&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
  &lt;/plugin&gt;
******************************
Normalized:
******************************
Original:
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.1&lt;/version&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;download-sources&lt;/id&gt;
        &lt;goals&gt;
          &lt;goal&gt;sources&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
  &lt;/plugin&gt;
******************************
Normalized:
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.1&lt;/version&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;download-sources&lt;/id&gt;
        &lt;goals&gt;
          &lt;goal&gt;sources&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
  &lt;/plugin&gt;
******************************
Original:
&lt;li&gt;&lt;a href="#{request.contextPath}/index.xhtml"&gt;Home&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#{request.contextPath}/about_us.xhtml"&gt;About us&lt;/a&gt;&lt;/li&gt;
******************************
Normalized:
******************************
Original:
&lt;li&gt;&lt;a href="#{request.contextPath}/index.xhtml"&gt;Home&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#{request.contextPath}/about_us.xhtml"&gt;About us&lt;/a&gt;&lt;/li&gt;
******************************
Normalized:
&lt;li&gt;&lt;a href="#{request.contextPath}/index.xhtml"&gt;Home&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#{request.contextPath}/about_us.xhtml"&gt;About us&lt;/a&gt;&lt;/li&gt;
******************************
Original:
&lt;servlet&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        &lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;
            org.package.YouConfigurationAnnotatedClass
        &lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
******************************
Normalized:
******************************
Original:
&lt;servlet&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        &lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;
            org.package.YouConfigurationAnnotatedClass
        &lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
******************************
Normalized:
&lt;servlet&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        &lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;
            org.package.YouConfigurationAnnotatedClass
        &lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
******************************
Original:
&lt;target name="compile1"&gt; 
  &lt;mkdir dir="./build/reports"/&gt; 
  &lt;jrc 
    srcdir="./reports"
    destdir="./build/reports"
    tempdir="./build/reports"
    keepjava="true"
    xmlvalidation="true"&gt;
   &lt;classpath refid="runClasspath"/&gt;
   &lt;include name="**/*.jrxml"/&gt;
  &lt;/jrc&gt;
&lt;/target&gt;
******************************
Normalized:
******************************
Original:
&lt;target name="compile1"&gt; 
  &lt;mkdir dir="./build/reports"/&gt; 
  &lt;jrc 
    srcdir="./reports"
    destdir="./build/reports"
    tempdir="./build/reports"
    keepjava="true"
    xmlvalidation="true"&gt;
   &lt;classpath refid="runClasspath"/&gt;
   &lt;include name="**/*.jrxml"/&gt;
  &lt;/jrc&gt;
&lt;/target&gt;
******************************
Normalized:
&lt;target name="compile1"&gt; 
  &lt;mkdir dir="./build/reports"/&gt; 
  &lt;jrc 
    srcdir="./reports"
    destdir="./build/reports"
    tempdir="./build/reports"
    keepjava="true"
    xmlvalidation="true"&gt;
   &lt;classpath refid="runClasspath"/&gt;
   &lt;include name="**/*.jrxml"/&gt;
  &lt;/jrc&gt;
&lt;/target&gt;
******************************
Original:
List&lt;List&lt;String&gt;&gt; first = list1.stream().map(Arrays::asList).collect(toList());
List&lt;List&lt;String&gt;&gt; second = list2.stream().map(Arrays::asList).collect(toList());
return first.equals(second);
******************************
Normalized:
******************************
Original:
List&lt;List&lt;String&gt;&gt; first = list1.stream().map(Arrays::asList).collect(toList());
List&lt;List&lt;String&gt;&gt; second = list2.stream().map(Arrays::asList).collect(toList());
return first.equals(second);
******************************
Normalized:
List&lt;List&lt;String&gt;&gt; first = list1.stream().map(Arrays::asList).collect(toList());
List&lt;List&lt;String&gt;&gt; second = list2.stream().map(Arrays::asList).collect(toList());
return first.equals(second);
******************************
Original:
&lt;c:if test="${content.contentType.name ne 'MCE'}"&gt;
    &lt;%-- snip --%&gt;
&lt;/c:if&gt;
******************************
Normalized:
******************************
Original:
&lt;c:if test="${content.contentType.name ne 'MCE'}"&gt;
    &lt;%-- snip --%&gt;
&lt;/c:if&gt;
******************************
Normalized:
&lt;c:if test="${content.contentType.name ne 'MCE'}"&gt;
    &lt;%-- snip --%&gt;
&lt;/c:if&gt;
******************************
Original:
Your keystore contains 1 entry

myalias, Feb 15, 2012, PrivateKeyEntry, 
Certificate fingerprint (MD5): xxxxxxxx
******************************
Normalized:
******************************
Original:
Your keystore contains 1 entry

myalias, Feb 15, 2012, PrivateKeyEntry, 
Certificate fingerprint (MD5): xxxxxxxx
******************************
Normalized:
Your keystore contains 1 entry

myalias, Feb 15, 2012, PrivateKeyEntry, 
Certificate fingerprint (MD5): xxxxxxxx
******************************
Original:
GOTO --&gt;JAVA--Compiler---&gt; and change compiler level to `1.5` instead of `1.6`
******************************
Normalized:
******************************
Original:
GOTO --&gt;JAVA--Compiler---&gt; and change compiler level to `1.5` instead of `1.6`
******************************
Normalized:
GOTO --&gt;JAVA--Compiler---&gt; and change compiler level to `1.5` instead of `1.6`
******************************
Original:
try{
    int i = Integer.parseInt(input);
} catch(NumberFormatException ex){ // handle your exception
    ...
}
******************************
Normalized:
******************************
Original:
try{
    int i = Integer.parseInt(input);
} catch(NumberFormatException ex){ // handle your exception
    ...
}
******************************
Normalized:
try{
    int i = Integer.parseInt(input);
} catch(NumberFormatException ex){ // handle your exception
    ...
}
******************************
Original:
0x021dd753: test   %eax,0x180100      ;   {poll}
  0x021dd759: cmp    $0x0,%ecx
  0x021dd75c: je     0x021dd748         ;*ifeq
                                        ; - Test$1::run@7 (line 13)
  0x021dd75e: cmp    $0x0,%edx
  0x021dd761: jne    0x021dd788         ;*ifne
                                        ; - Test$1::run@13 (line 17)
  0x021dd767: nop    
  0x021dd768: jmp    0x021dd7b8         ;   {no_reloc}
  0x021dd76d: xchg   %ax,%ax
  0x021dd770: jmp    0x021dd7d2         ; implicit exception: dispatches to 0x021dd7c2
  0x021dd775: nop                       ;*getstatic out
                                        ; - Test$1::run@16 (line 18)
  0x021dd776: cmp    (%ecx),%eax        ; implicit exception: dispatches to 0x021dd7dc
  0x021dd778: mov    $0x39239500,%edx   ;*invokevirtual println
******************************
Normalized:
******************************
Original:
0x021dd753: test   %eax,0x180100      ;   {poll}
  0x021dd759: cmp    $0x0,%ecx
  0x021dd75c: je     0x021dd748         ;*ifeq
                                        ; - Test$1::run@7 (line 13)
  0x021dd75e: cmp    $0x0,%edx
  0x021dd761: jne    0x021dd788         ;*ifne
                                        ; - Test$1::run@13 (line 17)
  0x021dd767: nop    
  0x021dd768: jmp    0x021dd7b8         ;   {no_reloc}
  0x021dd76d: xchg   %ax,%ax
  0x021dd770: jmp    0x021dd7d2         ; implicit exception: dispatches to 0x021dd7c2
  0x021dd775: nop                       ;*getstatic out
                                        ; - Test$1::run@16 (line 18)
  0x021dd776: cmp    (%ecx),%eax        ; implicit exception: dispatches to 0x021dd7dc
  0x021dd778: mov    $0x39239500,%edx   ;*invokevirtual println
******************************
Normalized:
0x021dd753: test   %eax,0x180100      ;   {poll}
  0x021dd759: cmp    $0x0,%ecx
  0x021dd75c: je     0x021dd748         ;*ifeq
                                        ; - Test$1::run@7 (line 13)
  0x021dd75e: cmp    $0x0,%edx
  0x021dd761: jne    0x021dd788         ;*ifne
                                        ; - Test$1::run@13 (line 17)
  0x021dd767: nop    
  0x021dd768: jmp    0x021dd7b8         ;   {no_reloc}
  0x021dd76d: xchg   %ax,%ax
  0x021dd770: jmp    0x021dd7d2         ; implicit exception: dispatches to 0x021dd7c2
  0x021dd775: nop                       ;*getstatic out
                                        ; - Test$1::run@16 (line 18)
  0x021dd776: cmp    (%ecx),%eax        ; implicit exception: dispatches to 0x021dd7dc
  0x021dd778: mov    $0x39239500,%edx   ;*invokevirtual println
******************************
Original:
final Path path = FileSystems.getDefault().getPath(System.getProperty("user.home"), "Desktop");
System.out.println(path);
try (final WatchService watchService = FileSystems.getDefault().newWatchService()) {
    final WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);
    while (true) {
        final WatchKey wk = watchService.take();
        for (WatchEvent&lt;?&gt; event : wk.pollEvents()) {
            //we only register "ENTRY_MODIFY" so the context is always a Path.
            final Path changed = (Path) event.context();
            System.out.println(changed);
            if (changed.endsWith("myFile.txt")) {
                System.out.println("My file has changed");
            }
        }
        // reset the key
        boolean valid = wk.reset();
        if (!valid) {
            System.out.println("Key has been unregisterede");
        }
    }
}
******************************
Normalized:
******************************
Original:
final Path path = FileSystems.getDefault().getPath(System.getProperty("user.home"), "Desktop");
System.out.println(path);
try (final WatchService watchService = FileSystems.getDefault().newWatchService()) {
    final WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);
    while (true) {
        final WatchKey wk = watchService.take();
        for (WatchEvent&lt;?&gt; event : wk.pollEvents()) {
            //we only register "ENTRY_MODIFY" so the context is always a Path.
            final Path changed = (Path) event.context();
            System.out.println(changed);
            if (changed.endsWith("myFile.txt")) {
                System.out.println("My file has changed");
            }
        }
        // reset the key
        boolean valid = wk.reset();
        if (!valid) {
            System.out.println("Key has been unregisterede");
        }
    }
}
******************************
Normalized:
final Path path = FileSystems.getDefault().getPath(System.getProperty("user.home"), "Desktop");
System.out.println(path);
try (final WatchService watchService = FileSystems.getDefault().newWatchService()) {
    final WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);
    while (true) {
        final WatchKey wk = watchService.take();
        for (WatchEvent&lt;?&gt; event : wk.pollEvents()) {
            //we only register "ENTRY_MODIFY" so the context is always a Path.
            final Path changed = (Path) event.context();
            System.out.println(changed);
            if (changed.endsWith("myFile.txt")) {
                System.out.println("My file has changed");
            }
        }
        // reset the key
        boolean valid = wk.reset();
        if (!valid) {
            System.out.println("Key has been unregisterede");
        }
    }
}
******************************
Original:
Map&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();

// Add Items to the TreeMap
map.put(1, "One");
map.put(2, "Two");
map.put(3, "Three");

// Iterate over them
for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {
    System.out.println(entry.getKey() + " =&gt; " + entry.getValue());
}
******************************
Normalized:
******************************
Original:
Map&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();

// Add Items to the TreeMap
map.put(1, "One");
map.put(2, "Two");
map.put(3, "Three");

// Iterate over them
for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {
    System.out.println(entry.getKey() + " =&gt; " + entry.getValue());
}
******************************
Normalized:
Map&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();

// Add Items to the TreeMap
map.put(1, "One");
map.put(2, "Two");
map.put(3, "Three");

// Iterate over them
for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {
    System.out.println(entry.getKey() + " =&gt; " + entry.getValue());
}
******************************
Original:
EnumSet largeSize
******************************
Normalized:
******************************
Original:
EnumSet largeSize
******************************
Normalized:
EnumSet largeSize
******************************
Original:
@OneToMany
@JoinColumn(name="TXTHEAD_CODE")
private Set&lt;Text&gt; text;
******************************
Normalized:
******************************
Original:
@OneToMany
@JoinColumn(name="TXTHEAD_CODE")
private Set&lt;Text&gt; text;
******************************
Normalized:
@OneToMany
@JoinColumn(name="TXTHEAD_CODE")
private Set&lt;Text&gt; text;
******************************
Original:
&lt;mvc:resources mapping="/static/**" location="/static/" /&gt;
******************************
Normalized:
******************************
Original:
&lt;mvc:resources mapping="/static/**" location="/static/" /&gt;
******************************
Normalized:
&lt;mvc:resources mapping="/static/**" location="/static/" /&gt;
******************************
Original:
IntStream.iterate(0, i -&gt; i + 2);
******************************
Normalized:
******************************
Original:
IntStream.iterate(0, i -&gt; i + 2);
******************************
Normalized:
IntStream.iterate(0, i -&gt; i + 2);
******************************
Original:
gcc -I/usr/lib/jvm/jdk1.7.0_07/include
******************************
Normalized:
******************************
Original:
gcc -I/usr/lib/jvm/jdk1.7.0_07/include
******************************
Normalized:
gcc -I/usr/lib/jvm/jdk1.7.0_07/include
******************************
Original:
// parent entity has simple primary key

@Entity
public class Employee {
   @Id long empId;
   String name;
   ...
} 

// dependent entity uses EmbeddedId for composite key

@Embeddable
public class DependentId {
   String name;
   long empid;   // corresponds to primary key type of Employee
}

@Entity
public class Dependent {
   @EmbeddedId DependentId id;
    ...
   @MapsId("empid")  //  maps the empid attribute of embedded id
   @ManyToOne Employee emp;
}
******************************
Normalized:
******************************
Original:
// parent entity has simple primary key

@Entity
public class Employee {
   @Id long empId;
   String name;
   ...
} 

// dependent entity uses EmbeddedId for composite key

@Embeddable
public class DependentId {
   String name;
   long empid;   // corresponds to primary key type of Employee
}

@Entity
public class Dependent {
   @EmbeddedId DependentId id;
    ...
   @MapsId("empid")  //  maps the empid attribute of embedded id
   @ManyToOne Employee emp;
}
******************************
Normalized:
// parent entity has simple primary key

@Entity
public class Employee {
   @Id long empId;
   String name;
   ...
} 

// dependent entity uses EmbeddedId for composite key

@Embeddable
public class DependentId {
   String name;
   long empid;   // corresponds to primary key type of Employee
}

@Entity
public class Dependent {
   @EmbeddedId DependentId id;
    ...
   @MapsId("empid")  //  maps the empid attribute of embedded id
   @ManyToOne Employee emp;
}
******************************
Original:
//Import all needed packages
package general;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipUtils {

    private List &lt;String&gt; fileList;
    private static final String OUTPUT_ZIP_FILE = "Folder.zip";
    private static final String SOURCE_FOLDER = "D:\\Reports"; // SourceFolder path

    public ZipUtils() {
        fileList = new ArrayList &lt; String &gt; ();
    }

    public static void main(String[] args) {
        ZipUtils appZip = new ZipUtils();
        appZip.generateFileList(new File(SOURCE_FOLDER));
        appZip.zipIt(OUTPUT_ZIP_FILE);
    }

    public void zipIt(String zipFile) {
        byte[] buffer = new byte[1024];
        String source = new File(SOURCE_FOLDER).getName();
        FileOutputStream fos = null;
        ZipOutputStream zos = null;
        try {
            fos = new FileOutputStream(zipFile);
            zos = new ZipOutputStream(fos);

            System.out.println("Output to Zip : " + zipFile);
            FileInputStream in = null;

            for (String file: this.fileList) {
                System.out.println("File Added : " + file);
                ZipEntry ze = new ZipEntry(source + File.separator + file);
                zos.putNextEntry(ze);
                try {
                    in = new FileInputStream(SOURCE_FOLDER + File.separator + file);
                    int len;
                    while ((len = in .read(buffer)) &gt; 0) {
                        zos.write(buffer, 0, len);
                    }
                } finally {
                    in.close();
                }
            }

            zos.closeEntry();
            System.out.println("Folder successfully compressed");

        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            try {
                zos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public void generateFileList(File node) {
        // add file only
        if (node.isFile()) {
            fileList.add(generateZipEntry(node.toString()));
        }

        if (node.isDirectory()) {
            String[] subNote = node.list();
            for (String filename: subNote) {
                generateFileList(new File(node, filename));
            }
        }
    }

    private String generateZipEntry(String file) {
        return file.substring(SOURCE_FOLDER.length() + 1, file.length());
    }
}
******************************
Normalized:
******************************
Original:
//Import all needed packages
package general;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipUtils {

    private List &lt;String&gt; fileList;
    private static final String OUTPUT_ZIP_FILE = "Folder.zip";
    private static final String SOURCE_FOLDER = "D:\\Reports"; // SourceFolder path

    public ZipUtils() {
        fileList = new ArrayList &lt; String &gt; ();
    }

    public static void main(String[] args) {
        ZipUtils appZip = new ZipUtils();
        appZip.generateFileList(new File(SOURCE_FOLDER));
        appZip.zipIt(OUTPUT_ZIP_FILE);
    }

    public void zipIt(String zipFile) {
        byte[] buffer = new byte[1024];
        String source = new File(SOURCE_FOLDER).getName();
        FileOutputStream fos = null;
        ZipOutputStream zos = null;
        try {
            fos = new FileOutputStream(zipFile);
            zos = new ZipOutputStream(fos);

            System.out.println("Output to Zip : " + zipFile);
            FileInputStream in = null;

            for (String file: this.fileList) {
                System.out.println("File Added : " + file);
                ZipEntry ze = new ZipEntry(source + File.separator + file);
                zos.putNextEntry(ze);
                try {
                    in = new FileInputStream(SOURCE_FOLDER + File.separator + file);
                    int len;
                    while ((len = in .read(buffer)) &gt; 0) {
                        zos.write(buffer, 0, len);
                    }
                } finally {
                    in.close();
                }
            }

            zos.closeEntry();
            System.out.println("Folder successfully compressed");

        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            try {
                zos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public void generateFileList(File node) {
        // add file only
        if (node.isFile()) {
            fileList.add(generateZipEntry(node.toString()));
        }

        if (node.isDirectory()) {
            String[] subNote = node.list();
            for (String filename: subNote) {
                generateFileList(new File(node, filename));
            }
        }
    }

    private String generateZipEntry(String file) {
        return file.substring(SOURCE_FOLDER.length() + 1, file.length());
    }
}
******************************
Normalized:
//Import all needed packages
package general;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipUtils {

    private List &lt;String&gt; fileList;
    private static final String OUTPUT_ZIP_FILE = "Folder.zip";
    private static final String SOURCE_FOLDER = "D:\\Reports"; // SourceFolder path

    public ZipUtils() {
        fileList = new ArrayList &lt; String &gt; ();
    }

    public static void main(String[] args) {
        ZipUtils appZip = new ZipUtils();
        appZip.generateFileList(new File(SOURCE_FOLDER));
        appZip.zipIt(OUTPUT_ZIP_FILE);
    }

    public void zipIt(String zipFile) {
        byte[] buffer = new byte[1024];
        String source = new File(SOURCE_FOLDER).getName();
        FileOutputStream fos = null;
        ZipOutputStream zos = null;
        try {
            fos = new FileOutputStream(zipFile);
            zos = new ZipOutputStream(fos);

            System.out.println("Output to Zip : " + zipFile);
            FileInputStream in = null;

            for (String file: this.fileList) {
                System.out.println("File Added : " + file);
                ZipEntry ze = new ZipEntry(source + File.separator + file);
                zos.putNextEntry(ze);
                try {
                    in = new FileInputStream(SOURCE_FOLDER + File.separator + file);
                    int len;
                    while ((len = in .read(buffer)) &gt; 0) {
                        zos.write(buffer, 0, len);
                    }
                } finally {
                    in.close();
                }
            }

            zos.closeEntry();
            System.out.println("Folder successfully compressed");

        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            try {
                zos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public void generateFileList(File node) {
        // add file only
        if (node.isFile()) {
            fileList.add(generateZipEntry(node.toString()));
        }

        if (node.isDirectory()) {
            String[] subNote = node.list();
            for (String filename: subNote) {
                generateFileList(new File(node, filename));
            }
        }
    }

    private String generateZipEntry(String file) {
        return file.substring(SOURCE_FOLDER.length() + 1, file.length());
    }
}
******************************
Original:
public enum Month {
    JANUARY, FEBRUARY, ...
}
******************************
Normalized:
******************************
Original:
public enum Month {
    JANUARY, FEBRUARY, ...
}
******************************
Normalized:
public enum Month {
    JANUARY, FEBRUARY, ...
}
******************************
Original:
ext {
    ver = [
        guava: '14.0.1'
    ]
}
******************************
Normalized:
******************************
Original:
ext {
    ver = [
        guava: '14.0.1'
    ]
}
******************************
Normalized:
ext {
    ver = [
        guava: '14.0.1'
    ]
}
******************************
Original:
private static long gcd(long a, long b)
{
    while (b &gt; 0)
    {
        long temp = b;
        b = a % b; // % is remainder
        a = temp;
    }
    return a;
}

private static long gcd(long[] input)
{
    long result = input[0];
    for(int i = 1; i &lt; input.length; i++) result = gcd(result, input[i]);
    return result;
}
******************************
Normalized:
******************************
Original:
private static long gcd(long a, long b)
{
    while (b &gt; 0)
    {
        long temp = b;
        b = a % b; // % is remainder
        a = temp;
    }
    return a;
}

private static long gcd(long[] input)
{
    long result = input[0];
    for(int i = 1; i &lt; input.length; i++) result = gcd(result, input[i]);
    return result;
}
******************************
Normalized:
private static long gcd(long a, long b)
{
    while (b &gt; 0)
    {
        long temp = b;
        b = a % b; // % is remainder
        a = temp;
    }
    return a;
}

private static long gcd(long[] input)
{
    long result = input[0];
    for(int i = 1; i &lt; input.length; i++) result = gcd(result, input[i]);
    return result;
}
******************************
Original:
$ sudo apt-get install libxtst6:i386
******************************
Normalized:
******************************
Original:
$ sudo apt-get install libxtst6:i386
******************************
Normalized:
$ sudo apt-get install libxtst6:i386
******************************
Original:
public class Helper {

        public static boolean isAppRunning(final Context context, final String packageName) {
            final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            final List&lt;ActivityManager.RunningAppProcessInfo&gt; procInfos = activityManager.getRunningAppProcesses();
            if (procInfos != null)
            {
                for (final ActivityManager.RunningAppProcessInfo processInfo : procInfos) {
                    if (processInfo.processName.equals(packageName)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
******************************
Normalized:
******************************
Original:
public class Helper {

        public static boolean isAppRunning(final Context context, final String packageName) {
            final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            final List&lt;ActivityManager.RunningAppProcessInfo&gt; procInfos = activityManager.getRunningAppProcesses();
            if (procInfos != null)
            {
                for (final ActivityManager.RunningAppProcessInfo processInfo : procInfos) {
                    if (processInfo.processName.equals(packageName)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
******************************
Normalized:
public class Helper {

        public static boolean isAppRunning(final Context context, final String packageName) {
            final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            final List&lt;ActivityManager.RunningAppProcessInfo&gt; procInfos = activityManager.getRunningAppProcesses();
            if (procInfos != null)
            {
                for (final ActivityManager.RunningAppProcessInfo processInfo : procInfos) {
                    if (processInfo.processName.equals(packageName)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
******************************
Original:
# Set root logger level to DEBUG and its only appender to A1.
log4j.rootLogger=DEBUG, A1

# A1 is set to be a ConsoleAppender.
log4j.appender.A1=org.apache.log4j.ConsoleAppender

# A1 uses PatternLayout.
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n

# An alternative logging format:
# log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1} - %m%n
******************************
Normalized:
******************************
Original:
# Set root logger level to DEBUG and its only appender to A1.
log4j.rootLogger=DEBUG, A1

# A1 is set to be a ConsoleAppender.
log4j.appender.A1=org.apache.log4j.ConsoleAppender

# A1 uses PatternLayout.
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n

# An alternative logging format:
# log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1} - %m%n
******************************
Normalized:
# Set root logger level to DEBUG and its only appender to A1.
log4j.rootLogger=DEBUG, A1

# A1 is set to be a ConsoleAppender.
log4j.appender.A1=org.apache.log4j.ConsoleAppender

# A1 uses PatternLayout.
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n

# An alternative logging format:
# log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1} - %m%n
******************************
Original:
public class MyComparator implements Comparator&lt;Integer&gt; {
   public int compare(Integer a, Integer b) {
      //
   }
}
******************************
Normalized:
******************************
Original:
public class MyComparator implements Comparator&lt;Integer&gt; {
   public int compare(Integer a, Integer b) {
      //
   }
}
******************************
Normalized:
public class MyComparator implements Comparator&lt;Integer&gt; {
   public int compare(Integer a, Integer b) {
      //
   }
}
******************************
Original:
public InputField(String labelText, Class&lt;W&gt; clazz)
{
    super(new String[] {labelText}, clazz);
}
******************************
Normalized:
******************************
Original:
public InputField(String labelText, Class&lt;W&gt; clazz)
{
    super(new String[] {labelText}, clazz);
}
******************************
Normalized:
public InputField(String labelText, Class&lt;W&gt; clazz)
{
    super(new String[] {labelText}, clazz);
}
******************************
Original:
private Object actuallyT;

public &lt;T&gt; List&lt;T&gt; magicalListGetter(Class&lt;T&gt; klazz) {
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    list.add(klazz.cast(actuallyT));
    try {
        list.add(klazz.getConstructor().newInstance()); // If default constructor
    } ...
    return list;
}
******************************
Normalized:
******************************
Original:
private Object actuallyT;

public &lt;T&gt; List&lt;T&gt; magicalListGetter(Class&lt;T&gt; klazz) {
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    list.add(klazz.cast(actuallyT));
    try {
        list.add(klazz.getConstructor().newInstance()); // If default constructor
    } ...
    return list;
}
******************************
Normalized:
private Object actuallyT;

public &lt;T&gt; List&lt;T&gt; magicalListGetter(Class&lt;T&gt; klazz) {
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    list.add(klazz.cast(actuallyT));
    try {
        list.add(klazz.getConstructor().newInstance()); // If default constructor
    } ...
    return list;
}
******************************
Original:
@Component
public class ImagesPurgeJob implements Job {

    private Logger logger = Logger.getLogger(this.getClass());

    @Value("${jobs.mediafiles.imagesPurgeJob.enable}")
    private boolean imagesPurgeJobEnable;

    @Override
    @Transactional(readOnly=true)
    @Scheduled(cron = "${jobs.mediafiles.imagesPurgeJob.schedule}")
    public void execute() {

         //Do something
        //can use DAO or other autowired beans here
        if(imagesPurgeJobEnable){

            Do your conditional job here...

        }
    }
}
******************************
Normalized:
******************************
Original:
@Component
public class ImagesPurgeJob implements Job {

    private Logger logger = Logger.getLogger(this.getClass());

    @Value("${jobs.mediafiles.imagesPurgeJob.enable}")
    private boolean imagesPurgeJobEnable;

    @Override
    @Transactional(readOnly=true)
    @Scheduled(cron = "${jobs.mediafiles.imagesPurgeJob.schedule}")
    public void execute() {

         //Do something
        //can use DAO or other autowired beans here
        if(imagesPurgeJobEnable){

            Do your conditional job here...

        }
    }
}
******************************
Normalized:
@Component
public class ImagesPurgeJob implements Job {

    private Logger logger = Logger.getLogger(this.getClass());

    @Value("${jobs.mediafiles.imagesPurgeJob.enable}")
    private boolean imagesPurgeJobEnable;

    @Override
    @Transactional(readOnly=true)
    @Scheduled(cron = "${jobs.mediafiles.imagesPurgeJob.schedule}")
    public void execute() {

         //Do something
        //can use DAO or other autowired beans here
        if(imagesPurgeJobEnable){

            Do your conditional job here...

        }
    }
}
******************************
Original:
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
******************************
Normalized:
******************************
Original:
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
******************************
Normalized:
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
******************************
Original:
@RunWith(Parameterized.class)
 @ContextConfiguration(classes = {ApplicationConfigTest.class})
 public class ServiceTest {

     private TestContextManager testContextManager;

     @Before
     public void setUpContext() throws Exception {
         //this is where the magic happens, we actually do "by hand" what the spring runner would do for us,
        // read the JavaDoc for the class bellow to know exactly what it does, the method names are quite accurate though
       this.testContextManager = new TestContextManager(getClass());
       this.testContextManager.prepareTestInstance(this);
     }
     ...
 }
******************************
Normalized:
******************************
Original:
@RunWith(Parameterized.class)
 @ContextConfiguration(classes = {ApplicationConfigTest.class})
 public class ServiceTest {

     private TestContextManager testContextManager;

     @Before
     public void setUpContext() throws Exception {
         //this is where the magic happens, we actually do "by hand" what the spring runner would do for us,
        // read the JavaDoc for the class bellow to know exactly what it does, the method names are quite accurate though
       this.testContextManager = new TestContextManager(getClass());
       this.testContextManager.prepareTestInstance(this);
     }
     ...
 }
******************************
Normalized:
@RunWith(Parameterized.class)
 @ContextConfiguration(classes = {ApplicationConfigTest.class})
 public class ServiceTest {

     private TestContextManager testContextManager;

     @Before
     public void setUpContext() throws Exception {
         //this is where the magic happens, we actually do "by hand" what the spring runner would do for us,
        // read the JavaDoc for the class bellow to know exactly what it does, the method names are quite accurate though
       this.testContextManager = new TestContextManager(getClass());
       this.testContextManager.prepareTestInstance(this);
     }
     ...
 }
******************************
Original:
@SuppressWarnings("WeakerAccess")
******************************
Normalized:
******************************
Original:
@SuppressWarnings("WeakerAccess")
******************************
Normalized:
@SuppressWarnings("WeakerAccess")
******************************
Original:
-vm
C:\Program Files\Java\jdk1.6.0_07\bin\
******************************
Normalized:
******************************
Original:
-vm
C:\Program Files\Java\jdk1.6.0_07\bin\
******************************
Normalized:
-vm
C:\Program Files\Java\jdk1.6.0_07\bin\
******************************
Original:
final List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
list = new ArrayList&lt;Integer&gt;(); // Since `list' is final, this won't compile
******************************
Normalized:
******************************
Original:
final List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
list = new ArrayList&lt;Integer&gt;(); // Since `list' is final, this won't compile
******************************
Normalized:
final List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
list = new ArrayList&lt;Integer&gt;(); // Since `list' is final, this won't compile
******************************
Original:
JarFile jarFile = new JarFile(pathToJar);
Enumeration&lt;JarEntry&gt; e = jarFile.entries();

URL[] urls = { new URL("jar:file:" + pathToJar+"!/") };
URLClassLoader cl = URLClassLoader.newInstance(urls);

while (e.hasMoreElements()) {
    JarEntry je = e.nextElement();
    if(je.isDirectory() || !je.getName().endsWith(".class")){
        continue;
    }
    // -6 because of .class
    String className = je.getName().substring(0,je.getName().length()-6);
    className = className.replace('/', '.');
    Class c = cl.loadClass(className);

}
******************************
Normalized:
******************************
Original:
JarFile jarFile = new JarFile(pathToJar);
Enumeration&lt;JarEntry&gt; e = jarFile.entries();

URL[] urls = { new URL("jar:file:" + pathToJar+"!/") };
URLClassLoader cl = URLClassLoader.newInstance(urls);

while (e.hasMoreElements()) {
    JarEntry je = e.nextElement();
    if(je.isDirectory() || !je.getName().endsWith(".class")){
        continue;
    }
    // -6 because of .class
    String className = je.getName().substring(0,je.getName().length()-6);
    className = className.replace('/', '.');
    Class c = cl.loadClass(className);

}
******************************
Normalized:
JarFile jarFile = new JarFile(pathToJar);
Enumeration&lt;JarEntry&gt; e = jarFile.entries();

URL[] urls = { new URL("jar:file:" + pathToJar+"!/") };
URLClassLoader cl = URLClassLoader.newInstance(urls);

while (e.hasMoreElements()) {
    JarEntry je = e.nextElement();
    if(je.isDirectory() || !je.getName().endsWith(".class")){
        continue;
    }
    // -6 because of .class
    String className = je.getName().substring(0,je.getName().length()-6);
    className = className.replace('/', '.');
    Class c = cl.loadClass(className);

}
******************************
Original:
// All exception handling omitted!
Class&lt;?&gt; enclosingClass = Class.forName("com.mycompany.Mother");
Object enclosingInstance = enclosingClass.newInstance();

Class&lt;?&gt; innerClass = Class.forName("com.mycompany.Mother$Child");
Constructor&lt;?&gt; ctor = innerClass.getDeclaredConstructor(enclosingClass);

Object innerInstance = ctor.newInstance(enclosingInstance);
******************************
Normalized:
******************************
Original:
// All exception handling omitted!
Class&lt;?&gt; enclosingClass = Class.forName("com.mycompany.Mother");
Object enclosingInstance = enclosingClass.newInstance();

Class&lt;?&gt; innerClass = Class.forName("com.mycompany.Mother$Child");
Constructor&lt;?&gt; ctor = innerClass.getDeclaredConstructor(enclosingClass);

Object innerInstance = ctor.newInstance(enclosingInstance);
******************************
Normalized:
// All exception handling omitted!
Class&lt;?&gt; enclosingClass = Class.forName("com.mycompany.Mother");
Object enclosingInstance = enclosingClass.newInstance();

Class&lt;?&gt; innerClass = Class.forName("com.mycompany.Mother$Child");
Constructor&lt;?&gt; ctor = innerClass.getDeclaredConstructor(enclosingClass);

Object innerInstance = ctor.newInstance(enclosingInstance);
******************************
Original:
private static final Consumer&lt;Object&gt; NOOP = whatever -&gt; {};
******************************
Normalized:
******************************
Original:
private static final Consumer&lt;Object&gt; NOOP = whatever -&gt; {};
******************************
Normalized:
private static final Consumer&lt;Object&gt; NOOP = whatever -&gt; {};
******************************
Original:
&lt;bean id="transactionManager1"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory1" /&gt;
    &lt;qualifier value="account"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionManager2"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory2" /&gt;
    &lt;qualifier value="businessData"/&gt;
&lt;/bean&gt;
******************************
Normalized:
******************************
Original:
&lt;bean id="transactionManager1"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory1" /&gt;
    &lt;qualifier value="account"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionManager2"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory2" /&gt;
    &lt;qualifier value="businessData"/&gt;
&lt;/bean&gt;
******************************
Normalized:
&lt;bean id="transactionManager1"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory1" /&gt;
    &lt;qualifier value="account"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionManager2"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory2" /&gt;
    &lt;qualifier value="businessData"/&gt;
&lt;/bean&gt;
******************************
Original:
// Get file from file name
File file = new File("U:\intranet_root\intranet\R1112B2.zip");

// Get length of file in bytes
long fileSizeInBytes = file.length();
// Convert the bytes to Kilobytes (1 KB = 1024 Bytes)
long fileSizeInKB = fileSizeInBytes / 1024;
// Convert the KB to MegaBytes (1 MB = 1024 KBytes)
long fileSizeInMB = fileSizeInKB / 1024;

if (fileSizeInMB &gt; 27) {
  ...
}
******************************
Normalized:
******************************
Original:
// Get file from file name
File file = new File("U:\intranet_root\intranet\R1112B2.zip");

// Get length of file in bytes
long fileSizeInBytes = file.length();
// Convert the bytes to Kilobytes (1 KB = 1024 Bytes)
long fileSizeInKB = fileSizeInBytes / 1024;
// Convert the KB to MegaBytes (1 MB = 1024 KBytes)
long fileSizeInMB = fileSizeInKB / 1024;

if (fileSizeInMB &gt; 27) {
  ...
}
******************************
Normalized:
// Get file from file name
File file = new File("U:\intranet_root\intranet\R1112B2.zip");

// Get length of file in bytes
long fileSizeInBytes = file.length();
// Convert the bytes to Kilobytes (1 KB = 1024 Bytes)
long fileSizeInKB = fileSizeInBytes / 1024;
// Convert the KB to MegaBytes (1 MB = 1024 KBytes)
long fileSizeInMB = fileSizeInKB / 1024;

if (fileSizeInMB &gt; 27) {
  ...
}
******************************
Original:
[{A,1},{B,1},{C,2}]
******************************
Normalized:
******************************
Original:
[{A,1},{B,1},{C,2}]
******************************
Normalized:
[{A,1},{B,1},{C,2}]
******************************
Original:
grammar Math;

compileUnit
    :   expr EOF
    ;

expr
    :   '(' expr ')'                         # parensExpr
    |   op=('+'|'-') expr                    # unaryExpr
    |   left=expr op=('*'|'/') right=expr    # infixExpr
    |   left=expr op=('+'|'-') right=expr    # infixExpr
    |   func=ID '(' expr ')'                 # funcExpr
    |   value=NUM                            # numberExpr
    ;

OP_ADD: '+';
OP_SUB: '-';
OP_MUL: '*';
OP_DIV: '/';

NUM :   [0-9]+ ('.' [0-9]+)? ([eE] [+-]? [0-9]+)?;
ID  :   [a-zA-Z]+;
WS  :   [ \t\r\n] -&gt; channel(HIDDEN);
******************************
Normalized:
******************************
Original:
grammar Math;

compileUnit
    :   expr EOF
    ;

expr
    :   '(' expr ')'                         # parensExpr
    |   op=('+'|'-') expr                    # unaryExpr
    |   left=expr op=('*'|'/') right=expr    # infixExpr
    |   left=expr op=('+'|'-') right=expr    # infixExpr
    |   func=ID '(' expr ')'                 # funcExpr
    |   value=NUM                            # numberExpr
    ;

OP_ADD: '+';
OP_SUB: '-';
OP_MUL: '*';
OP_DIV: '/';

NUM :   [0-9]+ ('.' [0-9]+)? ([eE] [+-]? [0-9]+)?;
ID  :   [a-zA-Z]+;
WS  :   [ \t\r\n] -&gt; channel(HIDDEN);
******************************
Normalized:
grammar Math;

compileUnit
    :   expr EOF
    ;

expr
    :   '(' expr ')'                         # parensExpr
    |   op=('+'|'-') expr                    # unaryExpr
    |   left=expr op=('*'|'/') right=expr    # infixExpr
    |   left=expr op=('+'|'-') right=expr    # infixExpr
    |   func=ID '(' expr ')'                 # funcExpr
    |   value=NUM                            # numberExpr
    ;

OP_ADD: '+';
OP_SUB: '-';
OP_MUL: '*';
OP_DIV: '/';

NUM :   [0-9]+ ('.' [0-9]+)? ([eE] [+-]? [0-9]+)?;
ID  :   [a-zA-Z]+;
WS  :   [ \t\r\n] -&gt; channel(HIDDEN);
******************************
Original:
byte[] one = getBytesForOne();
byte[] two = getBytesForTwo();
byte[] combined = new byte[one.length + two.length];

for (int i = 0; i &lt; combined.length; ++i)
{
    combined[i] = i &lt; one.length ? one[i] : two[i - one.length];
}
******************************
Normalized:
******************************
Original:
byte[] one = getBytesForOne();
byte[] two = getBytesForTwo();
byte[] combined = new byte[one.length + two.length];

for (int i = 0; i &lt; combined.length; ++i)
{
    combined[i] = i &lt; one.length ? one[i] : two[i - one.length];
}
******************************
Normalized:
byte[] one = getBytesForOne();
byte[] two = getBytesForTwo();
byte[] combined = new byte[one.length + two.length];

for (int i = 0; i &lt; combined.length; ++i)
{
    combined[i] = i &lt; one.length ? one[i] : two[i - one.length];
}
******************************
Original:
&lt;string name="meatShootingMessage"&gt;You shot %1$d pounds of meat!&lt;/string&gt;  


int numPoundsMeat = 123;
String strMeatFormat = getResources().getString(R.string.meatShootingMessage, numPoundsMeat);
******************************
Normalized:
******************************
Original:
&lt;string name="meatShootingMessage"&gt;You shot %1$d pounds of meat!&lt;/string&gt;  


int numPoundsMeat = 123;
String strMeatFormat = getResources().getString(R.string.meatShootingMessage, numPoundsMeat);
******************************
Normalized:
&lt;string name="meatShootingMessage"&gt;You shot %1$d pounds of meat!&lt;/string&gt;  


int numPoundsMeat = 123;
String strMeatFormat = getResources().getString(R.string.meatShootingMessage, numPoundsMeat);
******************************
Original:
class MyClass {
    companion object {
        public const val FOO = 1

    }
}
******************************
Normalized:
******************************
Original:
class MyClass {
    companion object {
        public const val FOO = 1

    }
}
******************************
Normalized:
class MyClass {
    companion object {
        public const val FOO = 1

    }
}
******************************
Original:
Set&lt;String&gt; users = new HashSet&lt;&gt;(Arrays.asList("Alice", "Bob"));

System.out.println(users.contains("Alice"));
// -&gt; prints true

System.out.println(users.contains("Jack"));
// -&gt; prints false
******************************
Normalized:
******************************
Original:
Set&lt;String&gt; users = new HashSet&lt;&gt;(Arrays.asList("Alice", "Bob"));

System.out.println(users.contains("Alice"));
// -&gt; prints true

System.out.println(users.contains("Jack"));
// -&gt; prints false
******************************
Normalized:
Set&lt;String&gt; users = new HashSet&lt;&gt;(Arrays.asList("Alice", "Bob"));

System.out.println(users.contains("Alice"));
// -&gt; prints true

System.out.println(users.contains("Jack"));
// -&gt; prints false
******************************
Original:
@TestPropertySource(properties=
{"spring.autoconfigure.exclude=comma.seperated.ClassNames,com.example.FooAutoConfiguration"})
@SpringBootTest
public class MySpringTest {...}
******************************
Normalized:
******************************
Original:
@TestPropertySource(properties=
{"spring.autoconfigure.exclude=comma.seperated.ClassNames,com.example.FooAutoConfiguration"})
@SpringBootTest
public class MySpringTest {...}
******************************
Normalized:
@TestPropertySource(properties=
{"spring.autoconfigure.exclude=comma.seperated.ClassNames,com.example.FooAutoConfiguration"})
@SpringBootTest
public class MySpringTest {...}
******************************
Original:
// use '..' in the args expression if you have zero or more parameters at that point
@Before("execution(* com.mkyong.customer.bo.CustomerBo.addCustomer(..)) &amp;&amp; args(yourString,..)")
******************************
Normalized:
******************************
Original:
// use '..' in the args expression if you have zero or more parameters at that point
@Before("execution(* com.mkyong.customer.bo.CustomerBo.addCustomer(..)) &amp;&amp; args(yourString,..)")
******************************
Normalized:
// use '..' in the args expression if you have zero or more parameters at that point
@Before("execution(* com.mkyong.customer.bo.CustomerBo.addCustomer(..)) &amp;&amp; args(yourString,..)")
******************************
Original:
mvn eclipse:eclipse
******************************
Normalized:
******************************
Original:
mvn eclipse:eclipse
******************************
Normalized:
mvn eclipse:eclipse
******************************
Original:
java -cp "$LIB/*"
******************************
Normalized:
******************************
Original:
java -cp "$LIB/*"
******************************
Normalized:
java -cp "$LIB/*"
******************************
Original:
&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd" &gt;
&lt;log4j:configuration debug="false"&gt;

    &lt;appender name="default.console" class="org.apache.log4j.ConsoleAppender"&gt;
        &lt;param name="target" value="System.out" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="default.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/mylogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="another.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/anotherlogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;logger name="com.yourcompany.SomeClass" additivity="false"&gt;
        &lt;level value="debug" /&gt;
        &lt;appender-ref ref="another.file" /&gt;
    &lt;/logger&gt;

    &lt;root&gt;
        &lt;priority value="info" /&gt;
        &lt;appender-ref ref="default.console" /&gt;
        &lt;appender-ref ref="default.file" /&gt;
    &lt;/root&gt;
&lt;/log4j:configuration&gt;
******************************
Normalized:
******************************
Original:
&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd" &gt;
&lt;log4j:configuration debug="false"&gt;

    &lt;appender name="default.console" class="org.apache.log4j.ConsoleAppender"&gt;
        &lt;param name="target" value="System.out" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="default.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/mylogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="another.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/anotherlogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;logger name="com.yourcompany.SomeClass" additivity="false"&gt;
        &lt;level value="debug" /&gt;
        &lt;appender-ref ref="another.file" /&gt;
    &lt;/logger&gt;

    &lt;root&gt;
        &lt;priority value="info" /&gt;
        &lt;appender-ref ref="default.console" /&gt;
        &lt;appender-ref ref="default.file" /&gt;
    &lt;/root&gt;
&lt;/log4j:configuration&gt;
******************************
Normalized:
&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd" &gt;
&lt;log4j:configuration debug="false"&gt;

    &lt;appender name="default.console" class="org.apache.log4j.ConsoleAppender"&gt;
        &lt;param name="target" value="System.out" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="default.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/mylogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="another.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/anotherlogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;logger name="com.yourcompany.SomeClass" additivity="false"&gt;
        &lt;level value="debug" /&gt;
        &lt;appender-ref ref="another.file" /&gt;
    &lt;/logger&gt;

    &lt;root&gt;
        &lt;priority value="info" /&gt;
        &lt;appender-ref ref="default.console" /&gt;
        &lt;appender-ref ref="default.file" /&gt;
    &lt;/root&gt;
&lt;/log4j:configuration&gt;
******************************
Original:
Supplier&lt;List&lt;Shape&gt;&gt; supplier = () -&gt; new LinkedList&lt;Shape&gt;();

List&lt;Shape&gt; blue = shapes.stream()
            .filter(s -&gt; s.getColor() == BLUE)
            .collect(Collectors.toCollection(supplier));
******************************
Normalized:
******************************
Original:
Supplier&lt;List&lt;Shape&gt;&gt; supplier = () -&gt; new LinkedList&lt;Shape&gt;();

List&lt;Shape&gt; blue = shapes.stream()
            .filter(s -&gt; s.getColor() == BLUE)
            .collect(Collectors.toCollection(supplier));
******************************
Normalized:
Supplier&lt;List&lt;Shape&gt;&gt; supplier = () -&gt; new LinkedList&lt;Shape&gt;();

List&lt;Shape&gt; blue = shapes.stream()
            .filter(s -&gt; s.getColor() == BLUE)
            .collect(Collectors.toCollection(supplier));
******************************
Original:
Criterion topPercentFromRange(Comparator&lt;Widget&gt; cmp, double from, double to) {
    return stream -&gt; {
        List&lt;Widget&gt; temp =
            stream.sorted(cmp).collect(toList());
        return temp.stream()
                   .skip((long)(temp.size() * from))
                   .limit((long)(temp.size() * (to - from)));
    };
}
******************************
Normalized:
******************************
Original:
Criterion topPercentFromRange(Comparator&lt;Widget&gt; cmp, double from, double to) {
    return stream -&gt; {
        List&lt;Widget&gt; temp =
            stream.sorted(cmp).collect(toList());
        return temp.stream()
                   .skip((long)(temp.size() * from))
                   .limit((long)(temp.size() * (to - from)));
    };
}
******************************
Normalized:
Criterion topPercentFromRange(Comparator&lt;Widget&gt; cmp, double from, double to) {
    return stream -&gt; {
        List&lt;Widget&gt; temp =
            stream.sorted(cmp).collect(toList());
        return temp.stream()
                   .skip((long)(temp.size() * from))
                   .limit((long)(temp.size() * (to - from)));
    };
}
******************************
Original:
Scanner s = new Scanner(new File("filepath"));
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
while (s.hasNext()){
    list.add(s.next());
}
s.close();
******************************
Normalized:
******************************
Original:
Scanner s = new Scanner(new File("filepath"));
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
while (s.hasNext()){
    list.add(s.next());
}
s.close();
******************************
Normalized:
Scanner s = new Scanner(new File("filepath"));
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
while (s.hasNext()){
    list.add(s.next());
}
s.close();
******************************
Original:
Stream&lt;String&gt; texts = optional.stream();
******************************
Normalized:
******************************
Original:
Stream&lt;String&gt; texts = optional.stream();
******************************
Normalized:
Stream&lt;String&gt; texts = optional.stream();
******************************
Original:
ObjectListing listing = s3.listObjects( bucketName, prefix );
List&lt;S3ObjectSummary&gt; summaries = listing.getObjectSummaries();

while (listing.isTruncated()) {
   listing = s3.listNextBatchOfObjects (listing);
   summaries.addAll (listing.getObjectSummaries());
}
******************************
Normalized:
******************************
Original:
ObjectListing listing = s3.listObjects( bucketName, prefix );
List&lt;S3ObjectSummary&gt; summaries = listing.getObjectSummaries();

while (listing.isTruncated()) {
   listing = s3.listNextBatchOfObjects (listing);
   summaries.addAll (listing.getObjectSummaries());
}
******************************
Normalized:
ObjectListing listing = s3.listObjects( bucketName, prefix );
List&lt;S3ObjectSummary&gt; summaries = listing.getObjectSummaries();

while (listing.isTruncated()) {
   listing = s3.listNextBatchOfObjects (listing);
   summaries.addAll (listing.getObjectSummaries());
}
******************************
Original:
/*[local-name()='workbook'
    and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheets'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheet'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main'][1]
******************************
Normalized:
******************************
Original:
/*[local-name()='workbook'
    and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheets'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheet'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main'][1]
******************************
Normalized:
/*[local-name()='workbook'
    and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheets'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheet'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main'][1]
******************************
Original:
/**
 * Stateful filter. T is type of stream element, K is type of extracted key.
 */
static class DistinctByKey&lt;T,K&gt; {
    Map&lt;K,Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;();
    Function&lt;T,K&gt; keyExtractor;
    public DistinctByKey(Function&lt;T,K&gt; ke) {
        this.keyExtractor = ke;
    }
    public boolean filter(T t) {
        return seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
    }
}
******************************
Normalized:
******************************
Original:
/**
 * Stateful filter. T is type of stream element, K is type of extracted key.
 */
static class DistinctByKey&lt;T,K&gt; {
    Map&lt;K,Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;();
    Function&lt;T,K&gt; keyExtractor;
    public DistinctByKey(Function&lt;T,K&gt; ke) {
        this.keyExtractor = ke;
    }
    public boolean filter(T t) {
        return seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
    }
}
******************************
Normalized:
/**
 * Stateful filter. T is type of stream element, K is type of extracted key.
 */
static class DistinctByKey&lt;T,K&gt; {
    Map&lt;K,Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;();
    Function&lt;T,K&gt; keyExtractor;
    public DistinctByKey(Function&lt;T,K&gt; ke) {
        this.keyExtractor = ke;
    }
    public boolean filter(T t) {
        return seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
    }
}
******************************
Original:
List&lt;String&gt; species = Arrays.asList(speciesArr);
******************************
Normalized:
******************************
Original:
List&lt;String&gt; species = Arrays.asList(speciesArr);
******************************
Normalized:
List&lt;String&gt; species = Arrays.asList(speciesArr);
******************************
Original:
ObjectMapper mapper = new ObjectMapper();
Map&lt;String,Object&gt; map = mapper.readValue(json, Map.class);
******************************
Normalized:
******************************
Original:
ObjectMapper mapper = new ObjectMapper();
Map&lt;String,Object&gt; map = mapper.readValue(json, Map.class);
******************************
Normalized:
ObjectMapper mapper = new ObjectMapper();
Map&lt;String,Object&gt; map = mapper.readValue(json, Map.class);
******************************
Original:
for (initialization statement; condition check; update)
    loop body;
******************************
Normalized:
******************************
Original:
for (initialization statement; condition check; update)
    loop body;
******************************
Normalized:
for (initialization statement; condition check; update)
    loop body;
******************************
Original:
public class ArrayIndexComparator implements Comparator&lt;Integer&gt;
{
    private final String[] array;

    public ArrayIndexComparator(String[] array)
    {
        this.array = array;
    }

    public Integer[] createIndexArray()
    {
        Integer[] indexes = new Integer[array.length];
        for (int i = 0; i &lt; array.length; i++)
        {
            indexes[i] = i; // Autoboxing
        }
        return indexes;
    }

    @Override
    public int compare(Integer index1, Integer index2)
    {
         // Autounbox from Integer to int to use as array indexes
        return array[index1].compareTo(array[index2]);
    }
}
******************************
Normalized:
******************************
Original:
public class ArrayIndexComparator implements Comparator&lt;Integer&gt;
{
    private final String[] array;

    public ArrayIndexComparator(String[] array)
    {
        this.array = array;
    }

    public Integer[] createIndexArray()
    {
        Integer[] indexes = new Integer[array.length];
        for (int i = 0; i &lt; array.length; i++)
        {
            indexes[i] = i; // Autoboxing
        }
        return indexes;
    }

    @Override
    public int compare(Integer index1, Integer index2)
    {
         // Autounbox from Integer to int to use as array indexes
        return array[index1].compareTo(array[index2]);
    }
}
******************************
Normalized:
public class ArrayIndexComparator implements Comparator&lt;Integer&gt;
{
    private final String[] array;

    public ArrayIndexComparator(String[] array)
    {
        this.array = array;
    }

    public Integer[] createIndexArray()
    {
        Integer[] indexes = new Integer[array.length];
        for (int i = 0; i &lt; array.length; i++)
        {
            indexes[i] = i; // Autoboxing
        }
        return indexes;
    }

    @Override
    public int compare(Integer index1, Integer index2)
    {
         // Autounbox from Integer to int to use as array indexes
        return array[index1].compareTo(array[index2]);
    }
}
******************************
Original:
android {
    ....
    ....

    sourceSets {
        main.java.srcDirs += 'src/main/&lt;YOUR DIRECTORY&gt;'
    }

}
******************************
Normalized:
******************************
Original:
android {
    ....
    ....

    sourceSets {
        main.java.srcDirs += 'src/main/&lt;YOUR DIRECTORY&gt;'
    }

}
******************************
Normalized:
android {
    ....
    ....

    sourceSets {
        main.java.srcDirs += 'src/main/&lt;YOUR DIRECTORY&gt;'
    }

}
******************************
Original:
import org.mockito.internal.util.MockUtil;

new MockUtil().isMock(obj)
******************************
Normalized:
******************************
Original:
import org.mockito.internal.util.MockUtil;

new MockUtil().isMock(obj)
******************************
Normalized:
import org.mockito.internal.util.MockUtil;

new MockUtil().isMock(obj)
******************************
Original:
[A-Za-z0-9.,-:]*
******************************
Normalized:
******************************
Original:
[A-Za-z0-9.,-:]*
******************************
Normalized:
[A-Za-z0-9.,-:]*
******************************
Original:
Consumer&lt;String&gt; p = ""::equals;
******************************
Normalized:
******************************
Original:
Consumer&lt;String&gt; p = ""::equals;
******************************
Normalized:
Consumer&lt;String&gt; p = ""::equals;
******************************
Original:
# cat Athrow.j 
.source Athrow.j
.class public Athrow
.super java/lang/Object

.method public &lt;init&gt;()V
    aload_0
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    return
.end method

.method public static main([Ljava/lang/String;)V
    .limit stack 2

    new java/lang/Object
    dup
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    athrow

    return
.end method

# java -jar jasmin.jar Athrow.j 
Generated: Athrow.class

# java Athrow
Exception in thread "main" java.lang.VerifyError: (class: Athrow, method: main signature: ([Ljava/lang/String;)V) Can only throw Throwable objects
******************************
Normalized:
******************************
Original:
# cat Athrow.j 
.source Athrow.j
.class public Athrow
.super java/lang/Object

.method public &lt;init&gt;()V
    aload_0
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    return
.end method

.method public static main([Ljava/lang/String;)V
    .limit stack 2

    new java/lang/Object
    dup
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    athrow

    return
.end method

# java -jar jasmin.jar Athrow.j 
Generated: Athrow.class

# java Athrow
Exception in thread "main" java.lang.VerifyError: (class: Athrow, method: main signature: ([Ljava/lang/String;)V) Can only throw Throwable objects
******************************
Normalized:
# cat Athrow.j 
.source Athrow.j
.class public Athrow
.super java/lang/Object

.method public &lt;init&gt;()V
    aload_0
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    return
.end method

.method public static main([Ljava/lang/String;)V
    .limit stack 2

    new java/lang/Object
    dup
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    athrow

    return
.end method

# java -jar jasmin.jar Athrow.j 
Generated: Athrow.class

# java Athrow
Exception in thread "main" java.lang.VerifyError: (class: Athrow, method: main signature: ([Ljava/lang/String;)V) Can only throw Throwable objects
******************************
Original:
&lt;manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:sharedUserId="android.uid.shared"
    android:sharedUserLabel="@string/sharedUserLabel"
    ...&gt;
******************************
Normalized:
******************************
Original:
&lt;manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:sharedUserId="android.uid.shared"
    android:sharedUserLabel="@string/sharedUserLabel"
    ...&gt;
******************************
Normalized:
&lt;manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:sharedUserId="android.uid.shared"
    android:sharedUserLabel="@string/sharedUserLabel"
    ...&gt;
******************************
Original:
ExecutorService executor = Executors.newSingleThreadExecutor();

    // LAMBDA COMPILED INTO A 'Callable&lt;?&gt;'
    executor.submit(() -&gt; {
        while (true)
            throw new Exception();
    });

    // LAMBDA COMPILED INTO A 'Runnable': EXCEPTIONS MUST BE HANDLED BY LAMBDA ITSELF!
    executor.submit(() -&gt; {
        boolean value = true;
        while (value)
            throw new Exception();
    });
******************************
Normalized:
******************************
Original:
ExecutorService executor = Executors.newSingleThreadExecutor();

    // LAMBDA COMPILED INTO A 'Callable&lt;?&gt;'
    executor.submit(() -&gt; {
        while (true)
            throw new Exception();
    });

    // LAMBDA COMPILED INTO A 'Runnable': EXCEPTIONS MUST BE HANDLED BY LAMBDA ITSELF!
    executor.submit(() -&gt; {
        boolean value = true;
        while (value)
            throw new Exception();
    });
******************************
Normalized:
ExecutorService executor = Executors.newSingleThreadExecutor();

    // LAMBDA COMPILED INTO A 'Callable&lt;?&gt;'
    executor.submit(() -&gt; {
        while (true)
            throw new Exception();
    });

    // LAMBDA COMPILED INTO A 'Runnable': EXCEPTIONS MUST BE HANDLED BY LAMBDA ITSELF!
    executor.submit(() -&gt; {
        boolean value = true;
        while (value)
            throw new Exception();
    });
******************************
Original:
public void webmethod(@RequestParam("date") String strDate) {
    Date date = ... // manually parse the date
 }
******************************
Normalized:
******************************
Original:
public void webmethod(@RequestParam("date") String strDate) {
    Date date = ... // manually parse the date
 }
******************************
Normalized:
public void webmethod(@RequestParam("date") String strDate) {
    Date date = ... // manually parse the date
 }
******************************
Original:
(throws IOException)

Image image = null;
try {
    URL url = new URL("http://www.yahoo.com/image_to_read.jpg");
    image = ImageIO.read(url);
} catch (IOException e) {
}
******************************
Normalized:
******************************
Original:
(throws IOException)

Image image = null;
try {
    URL url = new URL("http://www.yahoo.com/image_to_read.jpg");
    image = ImageIO.read(url);
} catch (IOException e) {
}
******************************
Normalized:
(throws IOException)

Image image = null;
try {
    URL url = new URL("http://www.yahoo.com/image_to_read.jpg");
    image = ImageIO.read(url);
} catch (IOException e) {
}
******************************
Original:
&lt;style name="MyTheme" parent="android:Theme.Holo.Light"&gt;
    &lt;item name="actionButtonStyle"&gt;@style/MyActionButtonStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="MyActionButtonStyle" parent="Widget.ActionButton"&gt;
    &lt;item name="android:minWidth"&gt;28dip&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
******************************
Original:
&lt;style name="MyTheme" parent="android:Theme.Holo.Light"&gt;
    &lt;item name="actionButtonStyle"&gt;@style/MyActionButtonStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="MyActionButtonStyle" parent="Widget.ActionButton"&gt;
    &lt;item name="android:minWidth"&gt;28dip&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
&lt;style name="MyTheme" parent="android:Theme.Holo.Light"&gt;
    &lt;item name="actionButtonStyle"&gt;@style/MyActionButtonStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="MyActionButtonStyle" parent="Widget.ActionButton"&gt;
    &lt;item name="android:minWidth"&gt;28dip&lt;/item&gt;
&lt;/style&gt;
******************************
Original:
public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(
    Collection&lt;? extends T&gt; coll
)
******************************
Normalized:
******************************
Original:
public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(
    Collection&lt;? extends T&gt; coll
)
******************************
Normalized:
public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(
    Collection&lt;? extends T&gt; coll
)
******************************
Original:
public static boolean isBetween(int x, int lower, int upper) {
  return lower &lt;= x &amp;&amp; x &lt;= upper;
}

if (isBetween(num, 1, 5)) {
  System.out.println("testing case 1 to 5");
} else if (isBetween(num, 6, 10)) {
  System.out.println("testing case 6 to 10");
}
******************************
Normalized:
******************************
Original:
public static boolean isBetween(int x, int lower, int upper) {
  return lower &lt;= x &amp;&amp; x &lt;= upper;
}

if (isBetween(num, 1, 5)) {
  System.out.println("testing case 1 to 5");
} else if (isBetween(num, 6, 10)) {
  System.out.println("testing case 6 to 10");
}
******************************
Normalized:
public static boolean isBetween(int x, int lower, int upper) {
  return lower &lt;= x &amp;&amp; x &lt;= upper;
}

if (isBetween(num, 1, 5)) {
  System.out.println("testing case 1 to 5");
} else if (isBetween(num, 6, 10)) {
  System.out.println("testing case 6 to 10");
}
******************************
Original:
ObjectMapper objectMapper = new ObjectMapper();
TypeFactory typeFactory = objectMapper.getTypeFactory();
List&lt;SomeClass&gt; someClassList = objectMapper.readValue(jsonString, typeFactory.constructCollectionType(List.class, SomeClass.class));
******************************
Normalized:
******************************
Original:
ObjectMapper objectMapper = new ObjectMapper();
TypeFactory typeFactory = objectMapper.getTypeFactory();
List&lt;SomeClass&gt; someClassList = objectMapper.readValue(jsonString, typeFactory.constructCollectionType(List.class, SomeClass.class));
******************************
Normalized:
ObjectMapper objectMapper = new ObjectMapper();
TypeFactory typeFactory = objectMapper.getTypeFactory();
List&lt;SomeClass&gt; someClassList = objectMapper.readValue(jsonString, typeFactory.constructCollectionType(List.class, SomeClass.class));
******************************
Original:
packagingOptions {
   pickFirst  'META-INF/license.txt'
}
******************************
Normalized:
******************************
Original:
packagingOptions {
   pickFirst  'META-INF/license.txt'
}
******************************
Normalized:
packagingOptions {
   pickFirst  'META-INF/license.txt'
}
******************************
Original:
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
******************************
Normalized:
******************************
Original:
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
******************************
Normalized:
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
******************************
Original:
object ScannerTest {
  def main(args: Array[String]) {
    var ok = true
    while (ok) {
      val ln = readLine()
      ok = ln != null
      if (ok) println(ln)
    }
  }
}
******************************
Normalized:
******************************
Original:
object ScannerTest {
  def main(args: Array[String]) {
    var ok = true
    while (ok) {
      val ln = readLine()
      ok = ln != null
      if (ok) println(ln)
    }
  }
}
******************************
Normalized:
object ScannerTest {
  def main(args: Array[String]) {
    var ok = true
    while (ok) {
      val ln = readLine()
      ok = ln != null
      if (ok) println(ln)
    }
  }
}
******************************
Original:
&lt;global-method-security&gt;
  &lt;expression-handler ref="myMethodSecurityExpressionHandler"/&gt;
&lt;/global-method-security&gt;
******************************
Normalized:
******************************
Original:
&lt;global-method-security&gt;
  &lt;expression-handler ref="myMethodSecurityExpressionHandler"/&gt;
&lt;/global-method-security&gt;
******************************
Normalized:
&lt;global-method-security&gt;
  &lt;expression-handler ref="myMethodSecurityExpressionHandler"/&gt;
&lt;/global-method-security&gt;
******************************
Original:
int r = x % n;
if (r &gt; 0 &amp;&amp; x &lt; 0)
{
    r -= n;
}
******************************
Normalized:
******************************
Original:
int r = x % n;
if (r &gt; 0 &amp;&amp; x &lt; 0)
{
    r -= n;
}
******************************
Normalized:
int r = x % n;
if (r &gt; 0 &amp;&amp; x &lt; 0)
{
    r -= n;
}
******************************
Original:
mvn eclipse:eclipse -DdownloadSources=true
******************************
Normalized:
******************************
Original:
mvn eclipse:eclipse -DdownloadSources=true
******************************
Normalized:
mvn eclipse:eclipse -DdownloadSources=true
******************************
Original:
@POST
public Response postSomething(@QueryParam("name") String name, @Context UriInfo uriInfo, String content) {
     MultivaluedMap&lt;String, String&gt; queryParams = uriInfo.getQueryParameters(); 
     String nameParam = queryParams.getFirst("name");
}
******************************
Normalized:
******************************
Original:
@POST
public Response postSomething(@QueryParam("name") String name, @Context UriInfo uriInfo, String content) {
     MultivaluedMap&lt;String, String&gt; queryParams = uriInfo.getQueryParameters(); 
     String nameParam = queryParams.getFirst("name");
}
******************************
Normalized:
@POST
public Response postSomething(@QueryParam("name") String name, @Context UriInfo uriInfo, String content) {
     MultivaluedMap&lt;String, String&gt; queryParams = uriInfo.getQueryParameters(); 
     String nameParam = queryParams.getFirst("name");
}
******************************
Original:
interface CustomUserRepository {

  List&lt;User&gt; yourCustomMethod();
}
******************************
Normalized:
******************************
Original:
interface CustomUserRepository {

  List&lt;User&gt; yourCustomMethod();
}
******************************
Normalized:
interface CustomUserRepository {

  List&lt;User&gt; yourCustomMethod();
}
******************************
Original:
1372060916 = Mon, 24 Jun 2013 08:01:56 GMT
******************************
Normalized:
******************************
Original:
1372060916 = Mon, 24 Jun 2013 08:01:56 GMT
******************************
Normalized:
1372060916 = Mon, 24 Jun 2013 08:01:56 GMT
******************************
Original:
0x00007fdd859dbb80: test   %eax,0x5f7847a(%rip)  /* fun JVM hack */
0x00007fdd859dbb86: dec    %r11                  /* i-- */
0x00007fdd859dbb89: mov    %r11,0x258(%r10)      /* store i to memory */
0x00007fdd859dbb90: test   %r11,%r11             /* unnecessary test */
0x00007fdd859dbb93: jge    0x00007fdd859dbb80    /* go back to the loop top */
******************************
Normalized:
******************************
Original:
0x00007fdd859dbb80: test   %eax,0x5f7847a(%rip)  /* fun JVM hack */
0x00007fdd859dbb86: dec    %r11                  /* i-- */
0x00007fdd859dbb89: mov    %r11,0x258(%r10)      /* store i to memory */
0x00007fdd859dbb90: test   %r11,%r11             /* unnecessary test */
0x00007fdd859dbb93: jge    0x00007fdd859dbb80    /* go back to the loop top */
******************************
Normalized:
0x00007fdd859dbb80: test   %eax,0x5f7847a(%rip)  /* fun JVM hack */
0x00007fdd859dbb86: dec    %r11                  /* i-- */
0x00007fdd859dbb89: mov    %r11,0x258(%r10)      /* store i to memory */
0x00007fdd859dbb90: test   %r11,%r11             /* unnecessary test */
0x00007fdd859dbb93: jge    0x00007fdd859dbb80    /* go back to the loop top */
******************************
Original:
Class&lt;?&gt; driverClass = Class.forName("oracle.jdbc.driver.OracleDriver");
// and
Class&lt;?&gt; stringClass = Class.forName("java.lang.String");
******************************
Normalized:
******************************
Original:
Class&lt;?&gt; driverClass = Class.forName("oracle.jdbc.driver.OracleDriver");
// and
Class&lt;?&gt; stringClass = Class.forName("java.lang.String");
******************************
Normalized:
Class&lt;?&gt; driverClass = Class.forName("oracle.jdbc.driver.OracleDriver");
// and
Class&lt;?&gt; stringClass = Class.forName("java.lang.String");
******************************
Original:
byte b1 = (byte) 129;
String s1 = String.format("%8s", Integer.toBinaryString(b1 &amp; 0xFF)).replace(' ', '0');
System.out.println(s1); // 10000001

byte b2 = (byte) 2;
String s2 = String.format("%8s", Integer.toBinaryString(b2 &amp; 0xFF)).replace(' ', '0');
System.out.println(s2); // 00000010
******************************
Normalized:
******************************
Original:
byte b1 = (byte) 129;
String s1 = String.format("%8s", Integer.toBinaryString(b1 &amp; 0xFF)).replace(' ', '0');
System.out.println(s1); // 10000001

byte b2 = (byte) 2;
String s2 = String.format("%8s", Integer.toBinaryString(b2 &amp; 0xFF)).replace(' ', '0');
System.out.println(s2); // 00000010
******************************
Normalized:
byte b1 = (byte) 129;
String s1 = String.format("%8s", Integer.toBinaryString(b1 &amp; 0xFF)).replace(' ', '0');
System.out.println(s1); // 10000001

byte b2 = (byte) 2;
String s2 = String.format("%8s", Integer.toBinaryString(b2 &amp; 0xFF)).replace(' ', '0');
System.out.println(s2); // 00000010
******************************
Original:
keytool -genkey -noprompt \
 -alias alias1 \
 -dname "CN=mqttserver.ibm.com, OU=ID, O=IBM, L=Hursley, S=Hants, C=GB" \
 -keystore keystore \
 -storepass password \
 -keypass password
******************************
Normalized:
******************************
Original:
keytool -genkey -noprompt \
 -alias alias1 \
 -dname "CN=mqttserver.ibm.com, OU=ID, O=IBM, L=Hursley, S=Hants, C=GB" \
 -keystore keystore \
 -storepass password \
 -keypass password
******************************
Normalized:
keytool -genkey -noprompt \
 -alias alias1 \
 -dname "CN=mqttserver.ibm.com, OU=ID, O=IBM, L=Hursley, S=Hants, C=GB" \
 -keystore keystore \
 -storepass password \
 -keypass password
******************************
Original:
&lt;c:if test="${not theBooleanVariable}"&gt;It's false!&lt;/c:if&gt;
******************************
Normalized:
******************************
Original:
&lt;c:if test="${not theBooleanVariable}"&gt;It's false!&lt;/c:if&gt;
******************************
Normalized:
&lt;c:if test="${not theBooleanVariable}"&gt;It's false!&lt;/c:if&gt;
******************************
Original:
while (condition) { 
  ... 
}
******************************
Normalized:
******************************
Original:
while (condition) { 
  ... 
}
******************************
Normalized:
while (condition) { 
  ... 
}
******************************
Original:
&lt;build&gt;
  &lt;finalName&gt;bird&lt;/finalName&gt;
 . . .
&lt;/build&gt;
******************************
Normalized:
******************************
Original:
&lt;build&gt;
  &lt;finalName&gt;bird&lt;/finalName&gt;
 . . .
&lt;/build&gt;
******************************
Normalized:
&lt;build&gt;
  &lt;finalName&gt;bird&lt;/finalName&gt;
 . . .
&lt;/build&gt;
******************************
Original:
git init
******************************
Normalized:
******************************
Original:
git init
******************************
Normalized:
git init
******************************
Original:
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST"
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST\\;" + 
                  "SET SCHEMA TEST";
String url = "jdbc:h2:mem;" + 
             "INIT=RUNSCRIPT FROM '~/create.sql'\\;" + 
                  "RUNSCRIPT FROM '~/populate.sql'";
******************************
Normalized:
******************************
Original:
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST"
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST\\;" + 
                  "SET SCHEMA TEST";
String url = "jdbc:h2:mem;" + 
             "INIT=RUNSCRIPT FROM '~/create.sql'\\;" + 
                  "RUNSCRIPT FROM '~/populate.sql'";
******************************
Normalized:
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST"
String url = "jdbc:h2:mem:test;" + 
             "INIT=CREATE SCHEMA IF NOT EXISTS TEST\\;" + 
                  "SET SCHEMA TEST";
String url = "jdbc:h2:mem;" + 
             "INIT=RUNSCRIPT FROM '~/create.sql'\\;" + 
                  "RUNSCRIPT FROM '~/populate.sql'";
******************************
Original:
public void testHardCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    for(int i = 0; i &lt; out.length; i++)
    {
        out[i] = bytes[i];
    }
}

public void testArrayCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    System.arraycopy(bytes, 0, out, 0, out.length);
}
******************************
Normalized:
******************************
Original:
public void testHardCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    for(int i = 0; i &lt; out.length; i++)
    {
        out[i] = bytes[i];
    }
}

public void testArrayCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    System.arraycopy(bytes, 0, out, 0, out.length);
}
******************************
Normalized:
public void testHardCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    for(int i = 0; i &lt; out.length; i++)
    {
        out[i] = bytes[i];
    }
}

public void testArrayCopyBytes()
{
    byte[] bytes = new byte[0x5000000]; /*~83mb buffer*/
    byte[] out = new byte[bytes.length];
    System.arraycopy(bytes, 0, out, 0, out.length);
}
******************************
Original:
String commaSeparatedNumbers = Arrays.stream(numbers)
    .mapToObj(i -&gt; ((Integer) i).toString()) //i is an int, not an Integer
    .collect(Collectors.joining(", "));
******************************
Normalized:
******************************
Original:
String commaSeparatedNumbers = Arrays.stream(numbers)
    .mapToObj(i -&gt; ((Integer) i).toString()) //i is an int, not an Integer
    .collect(Collectors.joining(", "));
******************************
Normalized:
String commaSeparatedNumbers = Arrays.stream(numbers)
    .mapToObj(i -&gt; ((Integer) i).toString()) //i is an int, not an Integer
    .collect(Collectors.joining(", "));
******************************
Original:
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;



class FloodIsolation {
public:
  FloodIsolation() :
      numberOfCells(20000),
      data(numberOfCells)
  {
  }
  ~FloodIsolation(){
  }

  void isUpdateNeeded() {
    for (int i = 0; i &lt; numberOfCells; ++i) {
       data[i].h = data[i].h + 1;
       data[i].floodedCells = !data[i].floodedCells;
       data[i].floodedCellsTimeInterval = !data[i].floodedCellsTimeInterval;
       data[i].qInflow = data[i].qInflow + 1;
       data[i].qStartTime = data[i].qStartTime + 1;
       data[i].qEndTime = data[i].qEndTime + 1;
       data[i].lowerFloorCells = data[i].lowerFloorCells + 1;
       data[i].cellLocationX = data[i].cellLocationX + 1;
       data[i].cellLocationY = data[i].cellLocationY + 1;
       data[i].cellLocationZ = data[i].cellLocationZ + 1;
       data[i].levelOfCell = data[i].levelOfCell + 1;
       data[i].valueOfCellIds = data[i].valueOfCellIds + 1;
       data[i].h0 = data[i].h0 + 1;
       data[i].vU = data[i].vU + 1;
       data[i].vV = data[i].vV + 1;
       data[i].vUh = data[i].vUh + 1;
       data[i].vVh = data[i].vVh + 1;
       data[i].vUh0 = data[i].vUh0 + 1;
       data[i].vVh0 = data[i].vVh0 + 1;
       data[i].ghh = data[i].ghh + 1;
       data[i].sfx = data[i].sfx + 1;
       data[i].sfy = data[i].sfy + 1;
       data[i].qIn = data[i].qIn + 1;


      for(int j = 0; j &lt; nEdges; ++j) {
        data[i].flagInterface[j] = !data[i].flagInterface[j];
        data[i].typeInterface[j] = data[i].typeInterface[j] + 1;
        data[i].neighborIds[j] = data[i].neighborIds[j] + 1;
      }
    }

  }

private:

  const int numberOfCells;
  static const int nEdges = 6;
  struct data_t {
    bool floodedCells = 0;
    bool floodedCellsTimeInterval = 0;

    double valueOfCellIds = 0;
    double h = 0;

    double h0 = 0;
    double vU = 0;
    double vV = 0;
    double vUh = 0;
    double vVh = 0;
    double vUh0 = 0;
    double vVh0 = 0;
    double ghh = 0;
    double sfx = 0;
    double sfy = 0;
    double qInflow = 0;
    double qStartTime = 0;
    double qEndTime = 0;
    double qIn = 0;
    double nx = 0;
    double ny = 0;
    double floorLevels = 0;
    int lowerFloorCells = 0;
    bool floorCompleteleyFilled = 0;
    double cellLocationX = 0;
    double cellLocationY = 0;
    double cellLocationZ = 0;
    int levelOfCell = 0;
    bool flagInterface[nEdges] = {};
    int typeInterface[nEdges] = {};
    int neighborIds[nEdges] = {};
  };
  std::vector&lt;data_t&gt; data;

};

int main() {
  std::ios_base::sync_with_stdio(false);
  FloodIsolation isolation;
  clock_t start = clock();
  for (int i = 0; i &lt; 400; ++i) {
    if(i % 100 == 0) {
      std::cout &lt;&lt; i &lt;&lt; "\n";
    }
    isolation.isUpdateNeeded();
  }
  clock_t stop = clock();
  std::cout &lt;&lt; "Time: " &lt;&lt; difftime(stop, start) / 1000 &lt;&lt; "\n";
}
******************************
Normalized:
******************************
Original:
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;



class FloodIsolation {
public:
  FloodIsolation() :
      numberOfCells(20000),
      data(numberOfCells)
  {
  }
  ~FloodIsolation(){
  }

  void isUpdateNeeded() {
    for (int i = 0; i &lt; numberOfCells; ++i) {
       data[i].h = data[i].h + 1;
       data[i].floodedCells = !data[i].floodedCells;
       data[i].floodedCellsTimeInterval = !data[i].floodedCellsTimeInterval;
       data[i].qInflow = data[i].qInflow + 1;
       data[i].qStartTime = data[i].qStartTime + 1;
       data[i].qEndTime = data[i].qEndTime + 1;
       data[i].lowerFloorCells = data[i].lowerFloorCells + 1;
       data[i].cellLocationX = data[i].cellLocationX + 1;
       data[i].cellLocationY = data[i].cellLocationY + 1;
       data[i].cellLocationZ = data[i].cellLocationZ + 1;
       data[i].levelOfCell = data[i].levelOfCell + 1;
       data[i].valueOfCellIds = data[i].valueOfCellIds + 1;
       data[i].h0 = data[i].h0 + 1;
       data[i].vU = data[i].vU + 1;
       data[i].vV = data[i].vV + 1;
       data[i].vUh = data[i].vUh + 1;
       data[i].vVh = data[i].vVh + 1;
       data[i].vUh0 = data[i].vUh0 + 1;
       data[i].vVh0 = data[i].vVh0 + 1;
       data[i].ghh = data[i].ghh + 1;
       data[i].sfx = data[i].sfx + 1;
       data[i].sfy = data[i].sfy + 1;
       data[i].qIn = data[i].qIn + 1;


      for(int j = 0; j &lt; nEdges; ++j) {
        data[i].flagInterface[j] = !data[i].flagInterface[j];
        data[i].typeInterface[j] = data[i].typeInterface[j] + 1;
        data[i].neighborIds[j] = data[i].neighborIds[j] + 1;
      }
    }

  }

private:

  const int numberOfCells;
  static const int nEdges = 6;
  struct data_t {
    bool floodedCells = 0;
    bool floodedCellsTimeInterval = 0;

    double valueOfCellIds = 0;
    double h = 0;

    double h0 = 0;
    double vU = 0;
    double vV = 0;
    double vUh = 0;
    double vVh = 0;
    double vUh0 = 0;
    double vVh0 = 0;
    double ghh = 0;
    double sfx = 0;
    double sfy = 0;
    double qInflow = 0;
    double qStartTime = 0;
    double qEndTime = 0;
    double qIn = 0;
    double nx = 0;
    double ny = 0;
    double floorLevels = 0;
    int lowerFloorCells = 0;
    bool floorCompleteleyFilled = 0;
    double cellLocationX = 0;
    double cellLocationY = 0;
    double cellLocationZ = 0;
    int levelOfCell = 0;
    bool flagInterface[nEdges] = {};
    int typeInterface[nEdges] = {};
    int neighborIds[nEdges] = {};
  };
  std::vector&lt;data_t&gt; data;

};

int main() {
  std::ios_base::sync_with_stdio(false);
  FloodIsolation isolation;
  clock_t start = clock();
  for (int i = 0; i &lt; 400; ++i) {
    if(i % 100 == 0) {
      std::cout &lt;&lt; i &lt;&lt; "\n";
    }
    isolation.isUpdateNeeded();
  }
  clock_t stop = clock();
  std::cout &lt;&lt; "Time: " &lt;&lt; difftime(stop, start) / 1000 &lt;&lt; "\n";
}
******************************
Normalized:
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;



class FloodIsolation {
public:
  FloodIsolation() :
      numberOfCells(20000),
      data(numberOfCells)
  {
  }
  ~FloodIsolation(){
  }

  void isUpdateNeeded() {
    for (int i = 0; i &lt; numberOfCells; ++i) {
       data[i].h = data[i].h + 1;
       data[i].floodedCells = !data[i].floodedCells;
       data[i].floodedCellsTimeInterval = !data[i].floodedCellsTimeInterval;
       data[i].qInflow = data[i].qInflow + 1;
       data[i].qStartTime = data[i].qStartTime + 1;
       data[i].qEndTime = data[i].qEndTime + 1;
       data[i].lowerFloorCells = data[i].lowerFloorCells + 1;
       data[i].cellLocationX = data[i].cellLocationX + 1;
       data[i].cellLocationY = data[i].cellLocationY + 1;
       data[i].cellLocationZ = data[i].cellLocationZ + 1;
       data[i].levelOfCell = data[i].levelOfCell + 1;
       data[i].valueOfCellIds = data[i].valueOfCellIds + 1;
       data[i].h0 = data[i].h0 + 1;
       data[i].vU = data[i].vU + 1;
       data[i].vV = data[i].vV + 1;
       data[i].vUh = data[i].vUh + 1;
       data[i].vVh = data[i].vVh + 1;
       data[i].vUh0 = data[i].vUh0 + 1;
       data[i].vVh0 = data[i].vVh0 + 1;
       data[i].ghh = data[i].ghh + 1;
       data[i].sfx = data[i].sfx + 1;
       data[i].sfy = data[i].sfy + 1;
       data[i].qIn = data[i].qIn + 1;


      for(int j = 0; j &lt; nEdges; ++j) {
        data[i].flagInterface[j] = !data[i].flagInterface[j];
        data[i].typeInterface[j] = data[i].typeInterface[j] + 1;
        data[i].neighborIds[j] = data[i].neighborIds[j] + 1;
      }
    }

  }

private:

  const int numberOfCells;
  static const int nEdges = 6;
  struct data_t {
    bool floodedCells = 0;
    bool floodedCellsTimeInterval = 0;

    double valueOfCellIds = 0;
    double h = 0;

    double h0 = 0;
    double vU = 0;
    double vV = 0;
    double vUh = 0;
    double vVh = 0;
    double vUh0 = 0;
    double vVh0 = 0;
    double ghh = 0;
    double sfx = 0;
    double sfy = 0;
    double qInflow = 0;
    double qStartTime = 0;
    double qEndTime = 0;
    double qIn = 0;
    double nx = 0;
    double ny = 0;
    double floorLevels = 0;
    int lowerFloorCells = 0;
    bool floorCompleteleyFilled = 0;
    double cellLocationX = 0;
    double cellLocationY = 0;
    double cellLocationZ = 0;
    int levelOfCell = 0;
    bool flagInterface[nEdges] = {};
    int typeInterface[nEdges] = {};
    int neighborIds[nEdges] = {};
  };
  std::vector&lt;data_t&gt; data;

};

int main() {
  std::ios_base::sync_with_stdio(false);
  FloodIsolation isolation;
  clock_t start = clock();
  for (int i = 0; i &lt; 400; ++i) {
    if(i % 100 == 0) {
      std::cout &lt;&lt; i &lt;&lt; "\n";
    }
    isolation.isUpdateNeeded();
  }
  clock_t stop = clock();
  std::cout &lt;&lt; "Time: " &lt;&lt; difftime(stop, start) / 1000 &lt;&lt; "\n";
}
******************************
Original:
private static &lt;T&gt; Stream&lt;T&gt; nonEmptyStream(
    Stream&lt;T&gt; stream, Supplier&lt;RuntimeException&gt; e) {

    Spliterator&lt;T&gt; it=stream.spliterator();
    return StreamSupport.stream(new Spliterator&lt;T&gt;() {
        boolean seen;
        public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
            boolean r=it.tryAdvance(action);
            if(!seen &amp;&amp; !r) throw e.get();
            seen=true;
            return r;
        }
        public Spliterator&lt;T&gt; trySplit() { return null; }
        public long estimateSize() { return it.estimateSize(); }
        public int characteristics() { return it.characteristics(); }
    }, false);
}
******************************
Normalized:
******************************
Original:
private static &lt;T&gt; Stream&lt;T&gt; nonEmptyStream(
    Stream&lt;T&gt; stream, Supplier&lt;RuntimeException&gt; e) {

    Spliterator&lt;T&gt; it=stream.spliterator();
    return StreamSupport.stream(new Spliterator&lt;T&gt;() {
        boolean seen;
        public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
            boolean r=it.tryAdvance(action);
            if(!seen &amp;&amp; !r) throw e.get();
            seen=true;
            return r;
        }
        public Spliterator&lt;T&gt; trySplit() { return null; }
        public long estimateSize() { return it.estimateSize(); }
        public int characteristics() { return it.characteristics(); }
    }, false);
}
******************************
Normalized:
private static &lt;T&gt; Stream&lt;T&gt; nonEmptyStream(
    Stream&lt;T&gt; stream, Supplier&lt;RuntimeException&gt; e) {

    Spliterator&lt;T&gt; it=stream.spliterator();
    return StreamSupport.stream(new Spliterator&lt;T&gt;() {
        boolean seen;
        public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
            boolean r=it.tryAdvance(action);
            if(!seen &amp;&amp; !r) throw e.get();
            seen=true;
            return r;
        }
        public Spliterator&lt;T&gt; trySplit() { return null; }
        public long estimateSize() { return it.estimateSize(); }
        public int characteristics() { return it.characteristics(); }
    }, false);
}
******************************
Original:
^[1-9]\d*$
******************************
Normalized:
******************************
Original:
^[1-9]\d*$
******************************
Normalized:
^[1-9]\d*$
******************************
Original:
&lt;Button
        android:id="@+id/header"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="@string/test"
        android:textColor="@color/black"
        android:minHeight="40dip"/&gt;


&lt;style name="Widget.Holo.Button" parent="Widget.Button"&gt;
    &lt;item name="android:background"&gt;@android:drawable/btn_default_holo_dark&lt;/item&gt;
    &lt;item name="android:textAppearance"&gt;?android:attr/textAppearanceMedium&lt;/item&gt;
    &lt;item name="android:textColor"&gt;@android:color/primary_text_holo_dark&lt;/item&gt;
    &lt;item name="android:minHeight"&gt;48dip&lt;/item&gt;
    &lt;item name="android:minWidth"&gt;64dip&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
******************************
Original:
&lt;Button
        android:id="@+id/header"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="@string/test"
        android:textColor="@color/black"
        android:minHeight="40dip"/&gt;


&lt;style name="Widget.Holo.Button" parent="Widget.Button"&gt;
    &lt;item name="android:background"&gt;@android:drawable/btn_default_holo_dark&lt;/item&gt;
    &lt;item name="android:textAppearance"&gt;?android:attr/textAppearanceMedium&lt;/item&gt;
    &lt;item name="android:textColor"&gt;@android:color/primary_text_holo_dark&lt;/item&gt;
    &lt;item name="android:minHeight"&gt;48dip&lt;/item&gt;
    &lt;item name="android:minWidth"&gt;64dip&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
&lt;Button
        android:id="@+id/header"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="@string/test"
        android:textColor="@color/black"
        android:minHeight="40dip"/&gt;


&lt;style name="Widget.Holo.Button" parent="Widget.Button"&gt;
    &lt;item name="android:background"&gt;@android:drawable/btn_default_holo_dark&lt;/item&gt;
    &lt;item name="android:textAppearance"&gt;?android:attr/textAppearanceMedium&lt;/item&gt;
    &lt;item name="android:textColor"&gt;@android:color/primary_text_holo_dark&lt;/item&gt;
    &lt;item name="android:minHeight"&gt;48dip&lt;/item&gt;
    &lt;item name="android:minWidth"&gt;64dip&lt;/item&gt;
&lt;/style&gt;
******************************
Original:
private ArrayList&lt;String&gt; _categories; // Initialize all this stuff

private int getCategoryPos(String category) {
  return _categories.indexOf(category);
}
******************************
Normalized:
******************************
Original:
private ArrayList&lt;String&gt; _categories; // Initialize all this stuff

private int getCategoryPos(String category) {
  return _categories.indexOf(category);
}
******************************
Normalized:
private ArrayList&lt;String&gt; _categories; // Initialize all this stuff

private int getCategoryPos(String category) {
  return _categories.indexOf(category);
}
******************************
Original:
@RequestMapping(value="/orders", method=RequestMethod.GET)
@ResponseBody
public List&lt;Account&gt; accountSummary() {
    return accountManager.getAllAccounts();
}
******************************
Normalized:
******************************
Original:
@RequestMapping(value="/orders", method=RequestMethod.GET)
@ResponseBody
public List&lt;Account&gt; accountSummary() {
    return accountManager.getAllAccounts();
}
******************************
Normalized:
@RequestMapping(value="/orders", method=RequestMethod.GET)
@ResponseBody
public List&lt;Account&gt; accountSummary() {
    return accountManager.getAllAccounts();
}
******************************
Original:
JSONArray jsonarray = new JSONArray(jsonStr);
for (int i = 0; i &lt; jsonarray.length(); i++) {
    JSONObject jsonobject = jsonarray.getJSONObject(i);
    String name = jsonobject.getString("name");
    String url = jsonobject.getString("url");
}
******************************
Normalized:
******************************
Original:
JSONArray jsonarray = new JSONArray(jsonStr);
for (int i = 0; i &lt; jsonarray.length(); i++) {
    JSONObject jsonobject = jsonarray.getJSONObject(i);
    String name = jsonobject.getString("name");
    String url = jsonobject.getString("url");
}
******************************
Normalized:
JSONArray jsonarray = new JSONArray(jsonStr);
for (int i = 0; i &lt; jsonarray.length(); i++) {
    JSONObject jsonobject = jsonarray.getJSONObject(i);
    String name = jsonobject.getString("name");
    String url = jsonobject.getString("url");
}
******************************
Original:
@Entity
@NamedEntityGraph(name = "GroupInfo.detail",
  attributeNodes = @NamedAttributeNode("members"))
public class GroupInfo {

  // default fetch mode is lazy.
  @ManyToMany
  List&lt;GroupMember&gt; members = new ArrayList&lt;GroupMember&gt;();

  …
}

@Repository
public interface GroupRepository extends CrudRepository&lt;GroupInfo, String&gt; {

  @EntityGraph(value = "GroupInfo.detail", type = EntityGraphType.LOAD)
  GroupInfo getByGroupName(String name);

}
******************************
Normalized:
******************************
Original:
@Entity
@NamedEntityGraph(name = "GroupInfo.detail",
  attributeNodes = @NamedAttributeNode("members"))
public class GroupInfo {

  // default fetch mode is lazy.
  @ManyToMany
  List&lt;GroupMember&gt; members = new ArrayList&lt;GroupMember&gt;();

  …
}

@Repository
public interface GroupRepository extends CrudRepository&lt;GroupInfo, String&gt; {

  @EntityGraph(value = "GroupInfo.detail", type = EntityGraphType.LOAD)
  GroupInfo getByGroupName(String name);

}
******************************
Normalized:
@Entity
@NamedEntityGraph(name = "GroupInfo.detail",
  attributeNodes = @NamedAttributeNode("members"))
public class GroupInfo {

  // default fetch mode is lazy.
  @ManyToMany
  List&lt;GroupMember&gt; members = new ArrayList&lt;GroupMember&gt;();

  …
}

@Repository
public interface GroupRepository extends CrudRepository&lt;GroupInfo, String&gt; {

  @EntityGraph(value = "GroupInfo.detail", type = EntityGraphType.LOAD)
  GroupInfo getByGroupName(String name);

}
******************************
Original:
open -a /Applications/IntelliJ\ IDEA\ 12.app/
******************************
Normalized:
******************************
Original:
open -a /Applications/IntelliJ\ IDEA\ 12.app/
******************************
Normalized:
open -a /Applications/IntelliJ\ IDEA\ 12.app/
******************************
Original:
String brandName;

@JsonProperty("brand")
private void unpackNameFromNestedObject(Map&lt;String, String&gt; brand) {
    brandName = brand.get("name");
}
******************************
Normalized:
******************************
Original:
String brandName;

@JsonProperty("brand")
private void unpackNameFromNestedObject(Map&lt;String, String&gt; brand) {
    brandName = brand.get("name");
}
******************************
Normalized:
String brandName;

@JsonProperty("brand")
private void unpackNameFromNestedObject(Map&lt;String, String&gt; brand) {
    brandName = brand.get("name");
}
******************************
Original:
d = D()          // these four computations can happen in any order
b = B()
c = C()
a = A()
sum = a + b      // these two computations can happen in any order
product = c * d
result = sum + product // this has to happen last
******************************
Normalized:
******************************
Original:
d = D()          // these four computations can happen in any order
b = B()
c = C()
a = A()
sum = a + b      // these two computations can happen in any order
product = c * d
result = sum + product // this has to happen last
******************************
Normalized:
d = D()          // these four computations can happen in any order
b = B()
c = C()
a = A()
sum = a + b      // these two computations can happen in any order
product = c * d
result = sum + product // this has to happen last
******************************
Original:
List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
******************************
Normalized:
******************************
Original:
List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
******************************
Normalized:
List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
******************************
Original:
@JsonDeserialize(builder = Address.Builder.class)
******************************
Normalized:
******************************
Original:
@JsonDeserialize(builder = Address.Builder.class)
******************************
Normalized:
@JsonDeserialize(builder = Address.Builder.class)
******************************
Original:
OctalEscape:
    \ OctalDigit
    \ OctalDigit OctalDigit
    \ ZeroToThree OctalDigit OctalDigit

OctalDigit: one of
    0 1 2 3 4 5 6 7

ZeroToThree: one of
    0 1 2 3
******************************
Normalized:
******************************
Original:
OctalEscape:
    \ OctalDigit
    \ OctalDigit OctalDigit
    \ ZeroToThree OctalDigit OctalDigit

OctalDigit: one of
    0 1 2 3 4 5 6 7

ZeroToThree: one of
    0 1 2 3
******************************
Normalized:
OctalEscape:
    \ OctalDigit
    \ OctalDigit OctalDigit
    \ ZeroToThree OctalDigit OctalDigit

OctalDigit: one of
    0 1 2 3 4 5 6 7

ZeroToThree: one of
    0 1 2 3
******************************
Original:
Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full. Compiler has been disabled.
Java HotSpot(TM) 64-Bit Server VM warning: Try increasing the code cache size using -XX:ReservedCodeCacheSize=
Code Cache  [0x000000010958f000, 0x000000010c52f000, 0x000000010c58f000)
 total_blobs=15406 nmethods=14989 adapters=362 free_code_cache=835Kb largest_free_block=449792
******************************
Normalized:
******************************
Original:
Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full. Compiler has been disabled.
Java HotSpot(TM) 64-Bit Server VM warning: Try increasing the code cache size using -XX:ReservedCodeCacheSize=
Code Cache  [0x000000010958f000, 0x000000010c52f000, 0x000000010c58f000)
 total_blobs=15406 nmethods=14989 adapters=362 free_code_cache=835Kb largest_free_block=449792
******************************
Normalized:
Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full. Compiler has been disabled.
Java HotSpot(TM) 64-Bit Server VM warning: Try increasing the code cache size using -XX:ReservedCodeCacheSize=
Code Cache  [0x000000010958f000, 0x000000010c52f000, 0x000000010c58f000)
 total_blobs=15406 nmethods=14989 adapters=362 free_code_cache=835Kb largest_free_block=449792
******************************
Original:
import static java.lang.Math.abs;

public static long roundUp(long num, long divisor) {
    int sign = (num &gt; 0 ? 1 : -1) * (divisor &gt; 0 ? 1 : -1);
    return sign * (abs(num) + abs(divisor) - 1) / abs(divisor);
}
******************************
Normalized:
******************************
Original:
import static java.lang.Math.abs;

public static long roundUp(long num, long divisor) {
    int sign = (num &gt; 0 ? 1 : -1) * (divisor &gt; 0 ? 1 : -1);
    return sign * (abs(num) + abs(divisor) - 1) / abs(divisor);
}
******************************
Normalized:
import static java.lang.Math.abs;

public static long roundUp(long num, long divisor) {
    int sign = (num &gt; 0 ? 1 : -1) * (divisor &gt; 0 ? 1 : -1);
    return sign * (abs(num) + abs(divisor) - 1) / abs(divisor);
}
******************************
Original:
&lt;http&gt;    
    &lt;headers&gt;
        &lt;frame-options policy="SAMEORIGIN"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;
******************************
Normalized:
******************************
Original:
&lt;http&gt;    
    &lt;headers&gt;
        &lt;frame-options policy="SAMEORIGIN"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;
******************************
Normalized:
&lt;http&gt;    
    &lt;headers&gt;
        &lt;frame-options policy="SAMEORIGIN"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;
******************************
Original:
n      0000100...000
-n      1111100...000
 n &amp; -n 0000100...000
******************************
Normalized:
******************************
Original:
n      0000100...000
-n      1111100...000
 n &amp; -n 0000100...000
******************************
Normalized:
n      0000100...000
-n      1111100...000
 n &amp; -n 0000100...000
******************************
Original:
FileOutputStream(File file, boolean append)
******************************
Normalized:
******************************
Original:
FileOutputStream(File file, boolean append)
******************************
Normalized:
FileOutputStream(File file, boolean append)
******************************
Original:
List&lt;Integer&gt; x = new ArrayList&lt;Integer&gt;();
x.add(1);
x.add(2);
******************************
Normalized:
******************************
Original:
List&lt;Integer&gt; x = new ArrayList&lt;Integer&gt;();
x.add(1);
x.add(2);
******************************
Normalized:
List&lt;Integer&gt; x = new ArrayList&lt;Integer&gt;();
x.add(1);
x.add(2);
******************************
Original:
import javax.swing.JOptionPane;
import javax.swing.JFrame;

/*Some piece of code*/
frame.addWindowListener(new java.awt.event.WindowAdapter() {
    @Override
    public void windowClosing(java.awt.event.WindowEvent windowEvent) {
        if (JOptionPane.showConfirmDialog(frame, 
            "Are you sure you want to close this window?", "Close Window?", 
            JOptionPane.YES_NO_OPTION,
            JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION){
            System.exit(0);
        }
    }
});
******************************
Normalized:
******************************
Original:
import javax.swing.JOptionPane;
import javax.swing.JFrame;

/*Some piece of code*/
frame.addWindowListener(new java.awt.event.WindowAdapter() {
    @Override
    public void windowClosing(java.awt.event.WindowEvent windowEvent) {
        if (JOptionPane.showConfirmDialog(frame, 
            "Are you sure you want to close this window?", "Close Window?", 
            JOptionPane.YES_NO_OPTION,
            JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION){
            System.exit(0);
        }
    }
});
******************************
Normalized:
import javax.swing.JOptionPane;
import javax.swing.JFrame;

/*Some piece of code*/
frame.addWindowListener(new java.awt.event.WindowAdapter() {
    @Override
    public void windowClosing(java.awt.event.WindowEvent windowEvent) {
        if (JOptionPane.showConfirmDialog(frame, 
            "Are you sure you want to close this window?", "Close Window?", 
            JOptionPane.YES_NO_OPTION,
            JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION){
            System.exit(0);
        }
    }
});
******************************
Original:
public class RealPayment implements Payment {
   @Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      @Assisted Date startDate,
      @Assisted Money amount) {
     ...
   }
 }
******************************
Normalized:
******************************
Original:
public class RealPayment implements Payment {
   @Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      @Assisted Date startDate,
      @Assisted Money amount) {
     ...
   }
 }
******************************
Normalized:
public class RealPayment implements Payment {
   @Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      @Assisted Date startDate,
      @Assisted Money amount) {
     ...
   }
 }
******************************
Original:
public class Test {
    public static void main(String[] args) {
        int x;
        if (args.length &gt; 0) {
            x = 1;
        } else {
            x = 2;
        }
    }

    public static void main2(String[] args) {
        int x = (args.length &gt; 0) ? 1 : 2;
    }
}
******************************
Normalized:
******************************
Original:
public class Test {
    public static void main(String[] args) {
        int x;
        if (args.length &gt; 0) {
            x = 1;
        } else {
            x = 2;
        }
    }

    public static void main2(String[] args) {
        int x = (args.length &gt; 0) ? 1 : 2;
    }
}
******************************
Normalized:
public class Test {
    public static void main(String[] args) {
        int x;
        if (args.length &gt; 0) {
            x = 1;
        } else {
            x = 2;
        }
    }

    public static void main2(String[] args) {
        int x = (args.length &gt; 0) ? 1 : 2;
    }
}
******************************
Original:
@ComponentScan({"com.my.package.first","com.my.package.second"})
******************************
Normalized:
******************************
Original:
@ComponentScan({"com.my.package.first","com.my.package.second"})
******************************
Normalized:
@ComponentScan({"com.my.package.first","com.my.package.second"})
******************************
Original:
public class Foo&lt;T&gt; 
{
    private Class&lt;T&gt; type;

    public Foo(Class&lt;T&gt; type) { this.type = type; } 
}
******************************
Normalized:
******************************
Original:
public class Foo&lt;T&gt; 
{
    private Class&lt;T&gt; type;

    public Foo(Class&lt;T&gt; type) { this.type = type; } 
}
******************************
Normalized:
public class Foo&lt;T&gt; 
{
    private Class&lt;T&gt; type;

    public Foo(Class&lt;T&gt; type) { this.type = type; } 
}
******************************
Original:
while (true) {
    ....
    if (obj == null) {
        break;
    }
    ....
}
******************************
Normalized:
******************************
Original:
while (true) {
    ....
    if (obj == null) {
        break;
    }
    ....
}
******************************
Normalized:
while (true) {
    ....
    if (obj == null) {
        break;
    }
    ....
}
******************************
Original:
javac dir1/*.java dir2/*.java dir3/dir4/*.java dir3/dir5/*.java dir6/*src/*.java
******************************
Normalized:
******************************
Original:
javac dir1/*.java dir2/*.java dir3/dir4/*.java dir3/dir5/*.java dir6/*src/*.java
******************************
Normalized:
javac dir1/*.java dir2/*.java dir3/dir4/*.java dir3/dir5/*.java dir6/*src/*.java
******************************
Original:
public class Demo {
  private int num = 0;
  /**
  * Access field {@link Demo#num} / {@link #num}  ...
  */
  private void foo() { ... }
...
******************************
Normalized:
******************************
Original:
public class Demo {
  private int num = 0;
  /**
  * Access field {@link Demo#num} / {@link #num}  ...
  */
  private void foo() { ... }
...
******************************
Normalized:
public class Demo {
  private int num = 0;
  /**
  * Access field {@link Demo#num} / {@link #num}  ...
  */
  private void foo() { ... }
...
******************************
Original:
java -XshowSettings:properties -version
******************************
Normalized:
******************************
Original:
java -XshowSettings:properties -version
******************************
Normalized:
java -XshowSettings:properties -version
******************************
Original:
public static &lt;T&gt; T isNull(Class&lt;T&gt; clazz)
******************************
Normalized:
******************************
Original:
public static &lt;T&gt; T isNull(Class&lt;T&gt; clazz)
******************************
Normalized:
public static &lt;T&gt; T isNull(Class&lt;T&gt; clazz)
******************************
Original:
1011 = -3
0011 = +3
******************************
Normalized:
******************************
Original:
1011 = -3
0011 = +3
******************************
Normalized:
1011 = -3
0011 = +3
******************************
Original:
final List&lt;MyObject&gt; list = query.list();
******************************
Normalized:
******************************
Original:
final List&lt;MyObject&gt; list = query.list();
******************************
Normalized:
final List&lt;MyObject&gt; list = query.list();
******************************
Original:
val handler = Handler&lt;String&gt; { println("Hello: $it")}
******************************
Normalized:
******************************
Original:
val handler = Handler&lt;String&gt; { println("Hello: $it")}
******************************
Normalized:
val handler = Handler&lt;String&gt; { println("Hello: $it")}
******************************
Original:
&lt;style name="MyMaterialTheme" parent="MyMaterialTheme.Base"&gt;

&lt;/style&gt;

&lt;style name="MyMaterialTheme.Base" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;
    &lt;item name="windowActionBar"&gt;false&lt;/item&gt;
    &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name="drawerArrowStyle"&gt;@style/DrawerArrowStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="DrawerArrowStyle" parent="@style/Widget.AppCompat.DrawerArrowToggle"&gt;
    &lt;item name="spinBars"&gt;true&lt;/item&gt;
    &lt;item name="color"&gt;@android:color/black&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
******************************
Original:
&lt;style name="MyMaterialTheme" parent="MyMaterialTheme.Base"&gt;

&lt;/style&gt;

&lt;style name="MyMaterialTheme.Base" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;
    &lt;item name="windowActionBar"&gt;false&lt;/item&gt;
    &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name="drawerArrowStyle"&gt;@style/DrawerArrowStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="DrawerArrowStyle" parent="@style/Widget.AppCompat.DrawerArrowToggle"&gt;
    &lt;item name="spinBars"&gt;true&lt;/item&gt;
    &lt;item name="color"&gt;@android:color/black&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
&lt;style name="MyMaterialTheme" parent="MyMaterialTheme.Base"&gt;

&lt;/style&gt;

&lt;style name="MyMaterialTheme.Base" parent="Theme.AppCompat.Light.DarkActionBar"&gt;
    &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;
    &lt;item name="windowActionBar"&gt;false&lt;/item&gt;
    &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name="drawerArrowStyle"&gt;@style/DrawerArrowStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="DrawerArrowStyle" parent="@style/Widget.AppCompat.DrawerArrowToggle"&gt;
    &lt;item name="spinBars"&gt;true&lt;/item&gt;
    &lt;item name="color"&gt;@android:color/black&lt;/item&gt;
&lt;/style&gt;
******************************
Original:
Gson gson = new Gson();
String jsonOutput = "Your JSON String";
Type listType = new TypeToken&lt;List&lt;Post&gt;&gt;(){}.getType();
List&lt;Post&gt; posts = gson.fromJson(jsonOutput, listType);
******************************
Normalized:
******************************
Original:
Gson gson = new Gson();
String jsonOutput = "Your JSON String";
Type listType = new TypeToken&lt;List&lt;Post&gt;&gt;(){}.getType();
List&lt;Post&gt; posts = gson.fromJson(jsonOutput, listType);
******************************
Normalized:
Gson gson = new Gson();
String jsonOutput = "Your JSON String";
Type listType = new TypeToken&lt;List&lt;Post&gt;&gt;(){}.getType();
List&lt;Post&gt; posts = gson.fromJson(jsonOutput, listType);
******************************
Original:
&lt;%@ page pageEncoding="UTF-8" %&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;
&lt;c:set var="language" value="${not empty param.language ? param.language : not empty language ? language : pageContext.request.locale}" scope="session" /&gt;
&lt;fmt:setLocale value="${language}" /&gt;
&lt;fmt:setBundle basename="com.example.i18n.text" /&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="${language}"&gt;
    &lt;head&gt;
        &lt;title&gt;JSP/JSTL i18n demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form&gt;
            &lt;select id="language" name="language" onchange="submit()"&gt;
                &lt;option value="en" ${language == 'en' ? 'selected' : ''}&gt;English&lt;/option&gt;
                &lt;option value="nl" ${language == 'nl' ? 'selected' : ''}&gt;Nederlands&lt;/option&gt;
                &lt;option value="es" ${language == 'es' ? 'selected' : ''}&gt;Español&lt;/option&gt;
            &lt;/select&gt;
        &lt;/form&gt;
        &lt;form method="post"&gt;
            &lt;label for="username"&gt;&lt;fmt:message key="login.label.username" /&gt;:&lt;/label&gt;
            &lt;input type="text" id="username" name="username"&gt;
            &lt;br&gt;
            &lt;label for="password"&gt;&lt;fmt:message key="login.label.password" /&gt;:&lt;/label&gt;
            &lt;input type="password" id="password" name="password"&gt;
            &lt;br&gt;
            &lt;fmt:message key="login.button.submit" var="buttonValue" /&gt;
            &lt;input type="submit" name="submit" value="${buttonValue}"&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
******************************
Normalized:
******************************
Original:
&lt;%@ page pageEncoding="UTF-8" %&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;
&lt;c:set var="language" value="${not empty param.language ? param.language : not empty language ? language : pageContext.request.locale}" scope="session" /&gt;
&lt;fmt:setLocale value="${language}" /&gt;
&lt;fmt:setBundle basename="com.example.i18n.text" /&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="${language}"&gt;
    &lt;head&gt;
        &lt;title&gt;JSP/JSTL i18n demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form&gt;
            &lt;select id="language" name="language" onchange="submit()"&gt;
                &lt;option value="en" ${language == 'en' ? 'selected' : ''}&gt;English&lt;/option&gt;
                &lt;option value="nl" ${language == 'nl' ? 'selected' : ''}&gt;Nederlands&lt;/option&gt;
                &lt;option value="es" ${language == 'es' ? 'selected' : ''}&gt;Español&lt;/option&gt;
            &lt;/select&gt;
        &lt;/form&gt;
        &lt;form method="post"&gt;
            &lt;label for="username"&gt;&lt;fmt:message key="login.label.username" /&gt;:&lt;/label&gt;
            &lt;input type="text" id="username" name="username"&gt;
            &lt;br&gt;
            &lt;label for="password"&gt;&lt;fmt:message key="login.label.password" /&gt;:&lt;/label&gt;
            &lt;input type="password" id="password" name="password"&gt;
            &lt;br&gt;
            &lt;fmt:message key="login.button.submit" var="buttonValue" /&gt;
            &lt;input type="submit" name="submit" value="${buttonValue}"&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
******************************
Normalized:
&lt;%@ page pageEncoding="UTF-8" %&gt;
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;
&lt;c:set var="language" value="${not empty param.language ? param.language : not empty language ? language : pageContext.request.locale}" scope="session" /&gt;
&lt;fmt:setLocale value="${language}" /&gt;
&lt;fmt:setBundle basename="com.example.i18n.text" /&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="${language}"&gt;
    &lt;head&gt;
        &lt;title&gt;JSP/JSTL i18n demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form&gt;
            &lt;select id="language" name="language" onchange="submit()"&gt;
                &lt;option value="en" ${language == 'en' ? 'selected' : ''}&gt;English&lt;/option&gt;
                &lt;option value="nl" ${language == 'nl' ? 'selected' : ''}&gt;Nederlands&lt;/option&gt;
                &lt;option value="es" ${language == 'es' ? 'selected' : ''}&gt;Español&lt;/option&gt;
            &lt;/select&gt;
        &lt;/form&gt;
        &lt;form method="post"&gt;
            &lt;label for="username"&gt;&lt;fmt:message key="login.label.username" /&gt;:&lt;/label&gt;
            &lt;input type="text" id="username" name="username"&gt;
            &lt;br&gt;
            &lt;label for="password"&gt;&lt;fmt:message key="login.label.password" /&gt;:&lt;/label&gt;
            &lt;input type="password" id="password" name="password"&gt;
            &lt;br&gt;
            &lt;fmt:message key="login.button.submit" var="buttonValue" /&gt;
            &lt;input type="submit" name="submit" value="${buttonValue}"&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
******************************
Original:
for (int i = 0; i &lt; size; i++)
   a += b;
   System.out.println("foo");
******************************
Normalized:
******************************
Original:
for (int i = 0; i &lt; size; i++)
   a += b;
   System.out.println("foo");
******************************
Normalized:
for (int i = 0; i &lt; size; i++)
   a += b;
   System.out.println("foo");
******************************
Original:
myObject = new ArrayList&lt;Object&gt;(myTempObject);
******************************
Normalized:
******************************
Original:
myObject = new ArrayList&lt;Object&gt;(myTempObject);
******************************
Normalized:
myObject = new ArrayList&lt;Object&gt;(myTempObject);
******************************
Original:
public class Utilities {

    private class SolarCalendar {

        public String strWeekDay = "";
        public String strMonth = "";

        int date;
        int month;
        int year;

        public SolarCalendar()
        {
            Date MiladiDate = new Date();
            calcSolarCalendar(MiladiDate);
        }

        public SolarCalendar(Date MiladiDate)
        {
            calcSolarCalendar(MiladiDate);
        }

        private void calcSolarCalendar(Date MiladiDate) {

            int ld;

            int miladiYear = MiladiDate.getYear() + 1900;
            int miladiMonth = MiladiDate.getMonth() + 1;
            int miladiDate = MiladiDate.getDate();
            int WeekDay = MiladiDate.getDay();

            int[] buf1 = new int[12];
            int[] buf2 = new int[12];

            buf1[0] = 0;
            buf1[1] = 31;
            buf1[2] = 59;
            buf1[3] = 90;
            buf1[4] = 120;
            buf1[5] = 151;
            buf1[6] = 181;
            buf1[7] = 212;
            buf1[8] = 243;
            buf1[9] = 273;
            buf1[10] = 304;
            buf1[11] = 334;

            buf2[0] = 0;
            buf2[1] = 31;
            buf2[2] = 60;
            buf2[3] = 91;
            buf2[4] = 121;
            buf2[5] = 152;
            buf2[6] = 182;
            buf2[7] = 213;
            buf2[8] = 244;
            buf2[9] = 274;
            buf2[10] = 305;
            buf2[11] = 335;

            if ((miladiYear % 4) != 0) {
                date = buf1[miladiMonth - 1] + miladiDate;

                if (date &gt; 79) {
                    date = date - 79;
                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = date / 31;
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                } else {
                    if ((miladiYear &gt; 1996) &amp;&amp; (miladiYear % 4) == 1) {
                        ld = 11;
                    } else {
                        ld = 10;
                    }
                    date = date + ld;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }
            } else {
                date = buf2[miladiMonth - 1] + miladiDate;

                if (miladiYear &gt;= 1996) {
                    ld = 79;
                } else {
                    ld = 80;
                }
                if (date &gt; ld) {
                    date = date - ld;

                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = (date / 31);
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                }

                else {
                    date = date + 10;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }

            }

            switch (month) {
            case 1:
                strMonth = "فروردين";
                break;
            case 2:
                strMonth = "ارديبهشت";
                break;
            case 3:
                strMonth = "خرداد";
                break;
            case 4:
                strMonth = "تير";
                break;
            case 5:
                strMonth = "مرداد";
                break;
            case 6:
                strMonth = "شهريور";
                break;
            case 7:
                strMonth = "مهر";
                break;
            case 8:
                strMonth = "آبان";
                break;
            case 9:
                strMonth = "آذر";
                break;
            case 10:
                strMonth = "دي";
                break;
            case 11:
                strMonth = "بهمن";
                break;
            case 12:
                strMonth = "اسفند";
                break;
            }

            switch (WeekDay) {

            case 0:
                strWeekDay = "يکشنبه";
                break;
            case 1:
                strWeekDay = "دوشنبه";
                break;
            case 2:
                strWeekDay = "سه شنبه";
                break;
            case 3:
                strWeekDay = "چهارشنبه";
                break;
            case 4:
                strWeekDay = "پنج شنبه";
                break;
            case 5:
                strWeekDay = "جمعه";
                break;
            case 6:
                strWeekDay = "شنبه";
                break;
            }

        }

    }

    public static String getCurrentShamsidate() {
        Locale loc = new Locale("en_US");
        Utilities util = new Utilities();
        SolarCalendar sc = util.new SolarCalendar();
        return String.valueOf(sc.year) + "/" + String.format(loc, "%02d",
                sc.month) + "/" + String.format(loc, "%02d", sc.date);
    }
}
******************************
Normalized:
******************************
Original:
public class Utilities {

    private class SolarCalendar {

        public String strWeekDay = "";
        public String strMonth = "";

        int date;
        int month;
        int year;

        public SolarCalendar()
        {
            Date MiladiDate = new Date();
            calcSolarCalendar(MiladiDate);
        }

        public SolarCalendar(Date MiladiDate)
        {
            calcSolarCalendar(MiladiDate);
        }

        private void calcSolarCalendar(Date MiladiDate) {

            int ld;

            int miladiYear = MiladiDate.getYear() + 1900;
            int miladiMonth = MiladiDate.getMonth() + 1;
            int miladiDate = MiladiDate.getDate();
            int WeekDay = MiladiDate.getDay();

            int[] buf1 = new int[12];
            int[] buf2 = new int[12];

            buf1[0] = 0;
            buf1[1] = 31;
            buf1[2] = 59;
            buf1[3] = 90;
            buf1[4] = 120;
            buf1[5] = 151;
            buf1[6] = 181;
            buf1[7] = 212;
            buf1[8] = 243;
            buf1[9] = 273;
            buf1[10] = 304;
            buf1[11] = 334;

            buf2[0] = 0;
            buf2[1] = 31;
            buf2[2] = 60;
            buf2[3] = 91;
            buf2[4] = 121;
            buf2[5] = 152;
            buf2[6] = 182;
            buf2[7] = 213;
            buf2[8] = 244;
            buf2[9] = 274;
            buf2[10] = 305;
            buf2[11] = 335;

            if ((miladiYear % 4) != 0) {
                date = buf1[miladiMonth - 1] + miladiDate;

                if (date &gt; 79) {
                    date = date - 79;
                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = date / 31;
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                } else {
                    if ((miladiYear &gt; 1996) &amp;&amp; (miladiYear % 4) == 1) {
                        ld = 11;
                    } else {
                        ld = 10;
                    }
                    date = date + ld;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }
            } else {
                date = buf2[miladiMonth - 1] + miladiDate;

                if (miladiYear &gt;= 1996) {
                    ld = 79;
                } else {
                    ld = 80;
                }
                if (date &gt; ld) {
                    date = date - ld;

                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = (date / 31);
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                }

                else {
                    date = date + 10;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }

            }

            switch (month) {
            case 1:
                strMonth = "فروردين";
                break;
            case 2:
                strMonth = "ارديبهشت";
                break;
            case 3:
                strMonth = "خرداد";
                break;
            case 4:
                strMonth = "تير";
                break;
            case 5:
                strMonth = "مرداد";
                break;
            case 6:
                strMonth = "شهريور";
                break;
            case 7:
                strMonth = "مهر";
                break;
            case 8:
                strMonth = "آبان";
                break;
            case 9:
                strMonth = "آذر";
                break;
            case 10:
                strMonth = "دي";
                break;
            case 11:
                strMonth = "بهمن";
                break;
            case 12:
                strMonth = "اسفند";
                break;
            }

            switch (WeekDay) {

            case 0:
                strWeekDay = "يکشنبه";
                break;
            case 1:
                strWeekDay = "دوشنبه";
                break;
            case 2:
                strWeekDay = "سه شنبه";
                break;
            case 3:
                strWeekDay = "چهارشنبه";
                break;
            case 4:
                strWeekDay = "پنج شنبه";
                break;
            case 5:
                strWeekDay = "جمعه";
                break;
            case 6:
                strWeekDay = "شنبه";
                break;
            }

        }

    }

    public static String getCurrentShamsidate() {
        Locale loc = new Locale("en_US");
        Utilities util = new Utilities();
        SolarCalendar sc = util.new SolarCalendar();
        return String.valueOf(sc.year) + "/" + String.format(loc, "%02d",
                sc.month) + "/" + String.format(loc, "%02d", sc.date);
    }
}
******************************
Normalized:
public class Utilities {

    private class SolarCalendar {

        public String strWeekDay = "";
        public String strMonth = "";

        int date;
        int month;
        int year;

        public SolarCalendar()
        {
            Date MiladiDate = new Date();
            calcSolarCalendar(MiladiDate);
        }

        public SolarCalendar(Date MiladiDate)
        {
            calcSolarCalendar(MiladiDate);
        }

        private void calcSolarCalendar(Date MiladiDate) {

            int ld;

            int miladiYear = MiladiDate.getYear() + 1900;
            int miladiMonth = MiladiDate.getMonth() + 1;
            int miladiDate = MiladiDate.getDate();
            int WeekDay = MiladiDate.getDay();

            int[] buf1 = new int[12];
            int[] buf2 = new int[12];

            buf1[0] = 0;
            buf1[1] = 31;
            buf1[2] = 59;
            buf1[3] = 90;
            buf1[4] = 120;
            buf1[5] = 151;
            buf1[6] = 181;
            buf1[7] = 212;
            buf1[8] = 243;
            buf1[9] = 273;
            buf1[10] = 304;
            buf1[11] = 334;

            buf2[0] = 0;
            buf2[1] = 31;
            buf2[2] = 60;
            buf2[3] = 91;
            buf2[4] = 121;
            buf2[5] = 152;
            buf2[6] = 182;
            buf2[7] = 213;
            buf2[8] = 244;
            buf2[9] = 274;
            buf2[10] = 305;
            buf2[11] = 335;

            if ((miladiYear % 4) != 0) {
                date = buf1[miladiMonth - 1] + miladiDate;

                if (date &gt; 79) {
                    date = date - 79;
                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = date / 31;
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                } else {
                    if ((miladiYear &gt; 1996) &amp;&amp; (miladiYear % 4) == 1) {
                        ld = 11;
                    } else {
                        ld = 10;
                    }
                    date = date + ld;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }
            } else {
                date = buf2[miladiMonth - 1] + miladiDate;

                if (miladiYear &gt;= 1996) {
                    ld = 79;
                } else {
                    ld = 80;
                }
                if (date &gt; ld) {
                    date = date - ld;

                    if (date &lt;= 186) {
                        switch (date % 31) {
                        case 0:
                            month = (date / 31);
                            date = 31;
                            break;
                        default:
                            month = (date / 31) + 1;
                            date = (date % 31);
                            break;
                        }
                        year = miladiYear - 621;
                    } else {
                        date = date - 186;

                        switch (date % 30) {
                        case 0:
                            month = (date / 30) + 6;
                            date = 30;
                            break;
                        default:
                            month = (date / 30) + 7;
                            date = (date % 30);
                            break;
                        }
                        year = miladiYear - 621;
                    }
                }

                else {
                    date = date + 10;

                    switch (date % 30) {
                    case 0:
                        month = (date / 30) + 9;
                        date = 30;
                        break;
                    default:
                        month = (date / 30) + 10;
                        date = (date % 30);
                        break;
                    }
                    year = miladiYear - 622;
                }

            }

            switch (month) {
            case 1:
                strMonth = "فروردين";
                break;
            case 2:
                strMonth = "ارديبهشت";
                break;
            case 3:
                strMonth = "خرداد";
                break;
            case 4:
                strMonth = "تير";
                break;
            case 5:
                strMonth = "مرداد";
                break;
            case 6:
                strMonth = "شهريور";
                break;
            case 7:
                strMonth = "مهر";
                break;
            case 8:
                strMonth = "آبان";
                break;
            case 9:
                strMonth = "آذر";
                break;
            case 10:
                strMonth = "دي";
                break;
            case 11:
                strMonth = "بهمن";
                break;
            case 12:
                strMonth = "اسفند";
                break;
            }

            switch (WeekDay) {

            case 0:
                strWeekDay = "يکشنبه";
                break;
            case 1:
                strWeekDay = "دوشنبه";
                break;
            case 2:
                strWeekDay = "سه شنبه";
                break;
            case 3:
                strWeekDay = "چهارشنبه";
                break;
            case 4:
                strWeekDay = "پنج شنبه";
                break;
            case 5:
                strWeekDay = "جمعه";
                break;
            case 6:
                strWeekDay = "شنبه";
                break;
            }

        }

    }

    public static String getCurrentShamsidate() {
        Locale loc = new Locale("en_US");
        Utilities util = new Utilities();
        SolarCalendar sc = util.new SolarCalendar();
        return String.valueOf(sc.year) + "/" + String.format(loc, "%02d",
                sc.month) + "/" + String.format(loc, "%02d", sc.date);
    }
}
******************************
Original:
public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription
******************************
Normalized:
******************************
Original:
public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription
******************************
Normalized:
public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription
******************************
Original:
void method1() {
    synchronized (this) {
        method2()
    }
}

void method2() {
    synchronized (this) {
    }
}
******************************
Normalized:
******************************
Original:
void method1() {
    synchronized (this) {
        method2()
    }
}

void method2() {
    synchronized (this) {
    }
}
******************************
Normalized:
void method1() {
    synchronized (this) {
        method2()
    }
}

void method2() {
    synchronized (this) {
    }
}
******************************
Original:
AnotherClass anotherObjSpy = Mockito.spy(new AnotherClass());
// do stuff -- e.g. anotherObjSpy.foo(...);
verify(anotherObjSpy).codePath1(...);
******************************
Normalized:
******************************
Original:
AnotherClass anotherObjSpy = Mockito.spy(new AnotherClass());
// do stuff -- e.g. anotherObjSpy.foo(...);
verify(anotherObjSpy).codePath1(...);
******************************
Normalized:
AnotherClass anotherObjSpy = Mockito.spy(new AnotherClass());
// do stuff -- e.g. anotherObjSpy.foo(...);
verify(anotherObjSpy).codePath1(...);
******************************
Original:
public class GenericList &lt;T&gt; extends ArrayList&lt;T&gt;
{
     private Class&lt;T&gt; genericType;

     public GenericList(Class&lt;T&gt; c)
     {
          this.genericType = c;
     }

     public Class&lt;T&gt; getGenericType()
     {
          return genericType;
     }
}
******************************
Normalized:
******************************
Original:
public class GenericList &lt;T&gt; extends ArrayList&lt;T&gt;
{
     private Class&lt;T&gt; genericType;

     public GenericList(Class&lt;T&gt; c)
     {
          this.genericType = c;
     }

     public Class&lt;T&gt; getGenericType()
     {
          return genericType;
     }
}
******************************
Normalized:
public class GenericList &lt;T&gt; extends ArrayList&lt;T&gt;
{
     private Class&lt;T&gt; genericType;

     public GenericList(Class&lt;T&gt; c)
     {
          this.genericType = c;
     }

     public Class&lt;T&gt; getGenericType()
     {
          return genericType;
     }
}
******************************
Original:
package hashmaptest;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

public class HashMapTest {

    private static final List&lt;Result&gt; results = new ArrayList&lt;Result&gt;();

    public static void main(String[] args) throws IOException {

        //First entry of each array is the sample collection size, subsequent entries
        //are the hash limits
        final int[][] sampleSizesAndHashLimits = new int[][] {
            {100, 50, 90, 100},
            {1000, 500, 900, 990, 1000},
            {100000, 10000, 90000, 99000, 100000}
        };
        final double[] initialCapacityFactors = new double[] {0.5, 0.75, 1.0, 1.25, 1.5, 2.0};
        final float[] loadFactors = new float[] {0.5f, 0.75f, 1.0f, 1.25f};

        //Doing a warmup run to eliminate JIT influence
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        results.clear();

        //Now for the real thing...
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        Collections.sort(results);

        for(final Result result : results) {
            result.printSummary();
        }

//      ResultVisualizer.visualizeResults(results);

    }

    private static void runTest(final int hashLimit, final int sampleSize,
            final double initCapacityFactor, final float loadFactor) {

        final int initialCapacity = (int)(sampleSize * initCapacityFactor);

        System.out.println("Running test for a sample collection of size " + sampleSize 
            + ", an initial capacity of " + initialCapacity + ", a load factor of "
            + loadFactor + " and keys with a hash code limited to " + hashLimit);
        System.out.println("====================");

        double hashOverload = (((double)sampleSize/hashLimit) - 1.0) * 100.0;

        System.out.println("Hash code overload: " + hashOverload + "%");

        //Generating our sample key collection.
        final List&lt;Key&gt; keys = generateSamples(hashLimit, sampleSize);

        //Generating our value collection
        final List&lt;Object&gt; values = generateValues(sampleSize);

        final HashMap&lt;Key, Object&gt; map = new HashMap&lt;Key, Object&gt;(initialCapacity, loadFactor);

        final long startPut = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.put(keys.get(i), values.get(i));
        }

        final long endPut = System.nanoTime();

        final long putTime = endPut - startPut;
        final long averagePutTime = putTime/(sampleSize/10);

        System.out.println("Time to map all keys to their values: " + putTime + " ns");
        System.out.println("Average put time per 10 entries: " + averagePutTime + " ns");

        final long startGet = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.get(keys.get(i));
        }

        final long endGet = System.nanoTime();

        final long getTime = endGet - startGet;
        final long averageGetTime = getTime/(sampleSize/10);

        System.out.println("Time to get the value for every key: " + getTime + " ns");
        System.out.println("Average get time per 10 entries: " + averageGetTime + " ns");

        System.out.println("");

        final Result result = 
            new Result(sampleSize, initialCapacity, loadFactor, hashOverload, averagePutTime, averageGetTime, hashLimit);

        results.add(result);

        //Haha, what kind of noob explicitly calls for garbage collection?
        System.gc();

        try {
            Thread.sleep(200);
        } catch(final InterruptedException e) {}

    }

    private static List&lt;Key&gt; generateSamples(final int hashLimit, final int sampleSize) {

        final ArrayList&lt;Key&gt; result = new ArrayList&lt;Key&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Key(i, hashLimit));
        }

        return result;

    }

    private static List&lt;Object&gt; generateValues(final int sampleSize) {

        final ArrayList&lt;Object&gt; result = new ArrayList&lt;Object&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Object());
        }

        return result;

    }

    private static class Key {

        private final int hashCode;
        private final int id;

        Key(final int id, final int hashLimit) {

            //Equals implies same hashCode if limit is the same
            //Same hashCode doesn't necessarily implies equals

            this.id = id;
            this.hashCode = id % hashLimit;

        }

        @Override
        public int hashCode() {
            return hashCode;
        }

        @Override
        public boolean equals(final Object o) {
            return ((Key)o).id == this.id;
        }

    }

    static class Result implements Comparable&lt;Result&gt; {

        final int sampleSize;
        final int initialCapacity;
        final float loadFactor;
        final double hashOverloadPercentage;
        final long averagePutTime;
        final long averageGetTime;
        final int hashLimit;

        Result(final int sampleSize, final int initialCapacity, final float loadFactor, 
                final double hashOverloadPercentage, final long averagePutTime, 
                final long averageGetTime, final int hashLimit) {

            this.sampleSize = sampleSize;
            this.initialCapacity = initialCapacity;
            this.loadFactor = loadFactor;
            this.hashOverloadPercentage = hashOverloadPercentage;
            this.averagePutTime = averagePutTime;
            this.averageGetTime = averageGetTime;
            this.hashLimit = hashLimit;

        }

        @Override
        public int compareTo(final Result o) {

            final long putDiff = o.averagePutTime - this.averagePutTime;
            final long getDiff = o.averageGetTime - this.averageGetTime;

            return (int)(putDiff + getDiff);
        }

        void printSummary() {

            System.out.println("" + averagePutTime + " ns per 10 puts, "
                + averageGetTime + " ns per 10 gets, for a load factor of "
                + loadFactor + ", initial capacity of " + initialCapacity
                + " for " + sampleSize + " mappings and " + hashOverloadPercentage 
                + "% hash code overload.");

        }

    }

}
******************************
Normalized:
******************************
Original:
package hashmaptest;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

public class HashMapTest {

    private static final List&lt;Result&gt; results = new ArrayList&lt;Result&gt;();

    public static void main(String[] args) throws IOException {

        //First entry of each array is the sample collection size, subsequent entries
        //are the hash limits
        final int[][] sampleSizesAndHashLimits = new int[][] {
            {100, 50, 90, 100},
            {1000, 500, 900, 990, 1000},
            {100000, 10000, 90000, 99000, 100000}
        };
        final double[] initialCapacityFactors = new double[] {0.5, 0.75, 1.0, 1.25, 1.5, 2.0};
        final float[] loadFactors = new float[] {0.5f, 0.75f, 1.0f, 1.25f};

        //Doing a warmup run to eliminate JIT influence
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        results.clear();

        //Now for the real thing...
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        Collections.sort(results);

        for(final Result result : results) {
            result.printSummary();
        }

//      ResultVisualizer.visualizeResults(results);

    }

    private static void runTest(final int hashLimit, final int sampleSize,
            final double initCapacityFactor, final float loadFactor) {

        final int initialCapacity = (int)(sampleSize * initCapacityFactor);

        System.out.println("Running test for a sample collection of size " + sampleSize 
            + ", an initial capacity of " + initialCapacity + ", a load factor of "
            + loadFactor + " and keys with a hash code limited to " + hashLimit);
        System.out.println("====================");

        double hashOverload = (((double)sampleSize/hashLimit) - 1.0) * 100.0;

        System.out.println("Hash code overload: " + hashOverload + "%");

        //Generating our sample key collection.
        final List&lt;Key&gt; keys = generateSamples(hashLimit, sampleSize);

        //Generating our value collection
        final List&lt;Object&gt; values = generateValues(sampleSize);

        final HashMap&lt;Key, Object&gt; map = new HashMap&lt;Key, Object&gt;(initialCapacity, loadFactor);

        final long startPut = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.put(keys.get(i), values.get(i));
        }

        final long endPut = System.nanoTime();

        final long putTime = endPut - startPut;
        final long averagePutTime = putTime/(sampleSize/10);

        System.out.println("Time to map all keys to their values: " + putTime + " ns");
        System.out.println("Average put time per 10 entries: " + averagePutTime + " ns");

        final long startGet = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.get(keys.get(i));
        }

        final long endGet = System.nanoTime();

        final long getTime = endGet - startGet;
        final long averageGetTime = getTime/(sampleSize/10);

        System.out.println("Time to get the value for every key: " + getTime + " ns");
        System.out.println("Average get time per 10 entries: " + averageGetTime + " ns");

        System.out.println("");

        final Result result = 
            new Result(sampleSize, initialCapacity, loadFactor, hashOverload, averagePutTime, averageGetTime, hashLimit);

        results.add(result);

        //Haha, what kind of noob explicitly calls for garbage collection?
        System.gc();

        try {
            Thread.sleep(200);
        } catch(final InterruptedException e) {}

    }

    private static List&lt;Key&gt; generateSamples(final int hashLimit, final int sampleSize) {

        final ArrayList&lt;Key&gt; result = new ArrayList&lt;Key&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Key(i, hashLimit));
        }

        return result;

    }

    private static List&lt;Object&gt; generateValues(final int sampleSize) {

        final ArrayList&lt;Object&gt; result = new ArrayList&lt;Object&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Object());
        }

        return result;

    }

    private static class Key {

        private final int hashCode;
        private final int id;

        Key(final int id, final int hashLimit) {

            //Equals implies same hashCode if limit is the same
            //Same hashCode doesn't necessarily implies equals

            this.id = id;
            this.hashCode = id % hashLimit;

        }

        @Override
        public int hashCode() {
            return hashCode;
        }

        @Override
        public boolean equals(final Object o) {
            return ((Key)o).id == this.id;
        }

    }

    static class Result implements Comparable&lt;Result&gt; {

        final int sampleSize;
        final int initialCapacity;
        final float loadFactor;
        final double hashOverloadPercentage;
        final long averagePutTime;
        final long averageGetTime;
        final int hashLimit;

        Result(final int sampleSize, final int initialCapacity, final float loadFactor, 
                final double hashOverloadPercentage, final long averagePutTime, 
                final long averageGetTime, final int hashLimit) {

            this.sampleSize = sampleSize;
            this.initialCapacity = initialCapacity;
            this.loadFactor = loadFactor;
            this.hashOverloadPercentage = hashOverloadPercentage;
            this.averagePutTime = averagePutTime;
            this.averageGetTime = averageGetTime;
            this.hashLimit = hashLimit;

        }

        @Override
        public int compareTo(final Result o) {

            final long putDiff = o.averagePutTime - this.averagePutTime;
            final long getDiff = o.averageGetTime - this.averageGetTime;

            return (int)(putDiff + getDiff);
        }

        void printSummary() {

            System.out.println("" + averagePutTime + " ns per 10 puts, "
                + averageGetTime + " ns per 10 gets, for a load factor of "
                + loadFactor + ", initial capacity of " + initialCapacity
                + " for " + sampleSize + " mappings and " + hashOverloadPercentage 
                + "% hash code overload.");

        }

    }

}
******************************
Normalized:
package hashmaptest;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

public class HashMapTest {

    private static final List&lt;Result&gt; results = new ArrayList&lt;Result&gt;();

    public static void main(String[] args) throws IOException {

        //First entry of each array is the sample collection size, subsequent entries
        //are the hash limits
        final int[][] sampleSizesAndHashLimits = new int[][] {
            {100, 50, 90, 100},
            {1000, 500, 900, 990, 1000},
            {100000, 10000, 90000, 99000, 100000}
        };
        final double[] initialCapacityFactors = new double[] {0.5, 0.75, 1.0, 1.25, 1.5, 2.0};
        final float[] loadFactors = new float[] {0.5f, 0.75f, 1.0f, 1.25f};

        //Doing a warmup run to eliminate JIT influence
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        results.clear();

        //Now for the real thing...
        for(int[] sizeAndLimits : sampleSizesAndHashLimits) {
            int size = sizeAndLimits[0];
            for(int i = 1; i &lt; sizeAndLimits.length; ++i) {
                int limit = sizeAndLimits[i];
                for(double initCapacityFactor : initialCapacityFactors) {
                    for(float loadFactor : loadFactors) {
                        runTest(limit, size, initCapacityFactor, loadFactor);
                    }
                }
            }

        }

        Collections.sort(results);

        for(final Result result : results) {
            result.printSummary();
        }

//      ResultVisualizer.visualizeResults(results);

    }

    private static void runTest(final int hashLimit, final int sampleSize,
            final double initCapacityFactor, final float loadFactor) {

        final int initialCapacity = (int)(sampleSize * initCapacityFactor);

        System.out.println("Running test for a sample collection of size " + sampleSize 
            + ", an initial capacity of " + initialCapacity + ", a load factor of "
            + loadFactor + " and keys with a hash code limited to " + hashLimit);
        System.out.println("====================");

        double hashOverload = (((double)sampleSize/hashLimit) - 1.0) * 100.0;

        System.out.println("Hash code overload: " + hashOverload + "%");

        //Generating our sample key collection.
        final List&lt;Key&gt; keys = generateSamples(hashLimit, sampleSize);

        //Generating our value collection
        final List&lt;Object&gt; values = generateValues(sampleSize);

        final HashMap&lt;Key, Object&gt; map = new HashMap&lt;Key, Object&gt;(initialCapacity, loadFactor);

        final long startPut = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.put(keys.get(i), values.get(i));
        }

        final long endPut = System.nanoTime();

        final long putTime = endPut - startPut;
        final long averagePutTime = putTime/(sampleSize/10);

        System.out.println("Time to map all keys to their values: " + putTime + " ns");
        System.out.println("Average put time per 10 entries: " + averagePutTime + " ns");

        final long startGet = System.nanoTime();

        for(int i = 0; i &lt; sampleSize; ++i) {
            map.get(keys.get(i));
        }

        final long endGet = System.nanoTime();

        final long getTime = endGet - startGet;
        final long averageGetTime = getTime/(sampleSize/10);

        System.out.println("Time to get the value for every key: " + getTime + " ns");
        System.out.println("Average get time per 10 entries: " + averageGetTime + " ns");

        System.out.println("");

        final Result result = 
            new Result(sampleSize, initialCapacity, loadFactor, hashOverload, averagePutTime, averageGetTime, hashLimit);

        results.add(result);

        //Haha, what kind of noob explicitly calls for garbage collection?
        System.gc();

        try {
            Thread.sleep(200);
        } catch(final InterruptedException e) {}

    }

    private static List&lt;Key&gt; generateSamples(final int hashLimit, final int sampleSize) {

        final ArrayList&lt;Key&gt; result = new ArrayList&lt;Key&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Key(i, hashLimit));
        }

        return result;

    }

    private static List&lt;Object&gt; generateValues(final int sampleSize) {

        final ArrayList&lt;Object&gt; result = new ArrayList&lt;Object&gt;(sampleSize);

        for(int i = 0; i &lt; sampleSize; ++i) {
            result.add(new Object());
        }

        return result;

    }

    private static class Key {

        private final int hashCode;
        private final int id;

        Key(final int id, final int hashLimit) {

            //Equals implies same hashCode if limit is the same
            //Same hashCode doesn't necessarily implies equals

            this.id = id;
            this.hashCode = id % hashLimit;

        }

        @Override
        public int hashCode() {
            return hashCode;
        }

        @Override
        public boolean equals(final Object o) {
            return ((Key)o).id == this.id;
        }

    }

    static class Result implements Comparable&lt;Result&gt; {

        final int sampleSize;
        final int initialCapacity;
        final float loadFactor;
        final double hashOverloadPercentage;
        final long averagePutTime;
        final long averageGetTime;
        final int hashLimit;

        Result(final int sampleSize, final int initialCapacity, final float loadFactor, 
                final double hashOverloadPercentage, final long averagePutTime, 
                final long averageGetTime, final int hashLimit) {

            this.sampleSize = sampleSize;
            this.initialCapacity = initialCapacity;
            this.loadFactor = loadFactor;
            this.hashOverloadPercentage = hashOverloadPercentage;
            this.averagePutTime = averagePutTime;
            this.averageGetTime = averageGetTime;
            this.hashLimit = hashLimit;

        }

        @Override
        public int compareTo(final Result o) {

            final long putDiff = o.averagePutTime - this.averagePutTime;
            final long getDiff = o.averageGetTime - this.averageGetTime;

            return (int)(putDiff + getDiff);
        }

        void printSummary() {

            System.out.println("" + averagePutTime + " ns per 10 puts, "
                + averageGetTime + " ns per 10 gets, for a load factor of "
                + loadFactor + ", initial capacity of " + initialCapacity
                + " for " + sampleSize + " mappings and " + hashOverloadPercentage 
                + "% hash code overload.");

        }

    }

}
******************************
Original:
StringBuilder sb = new StringBuilder();
for (int i = 0; i &lt; 500; i ++) {
    sb.append(i);
}
******************************
Normalized:
******************************
Original:
StringBuilder sb = new StringBuilder();
for (int i = 0; i &lt; 500; i ++) {
    sb.append(i);
}
******************************
Normalized:
StringBuilder sb = new StringBuilder();
for (int i = 0; i &lt; 500; i ++) {
    sb.append(i);
}
******************************
Original:
arrayList.set(index i,String replaceElement);
******************************
Normalized:
******************************
Original:
arrayList.set(index i,String replaceElement);
******************************
Normalized:
arrayList.set(index i,String replaceElement);
******************************
Original:
&lt;properties&gt;
  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
******************************
Normalized:
******************************
Original:
&lt;properties&gt;
  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
******************************
Normalized:
&lt;properties&gt;
  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
******************************
Original:
public class RetryTest {
    public class Retry implements TestRule {
        private int retryCount;

        public Retry(int retryCount) {
            this.retryCount = retryCount;
        }

        public Statement apply(Statement base, Description description) {
            return statement(base, description);
        }

        private Statement statement(final Statement base, final Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    Throwable caughtThrowable = null;

                    // implement retry logic here
                    for (int i = 0; i &lt; retryCount; i++) {
                        try {
                            base.evaluate();
                            return;
                        } catch (Throwable t) {
                            caughtThrowable = t;
                            System.err.println(description.getDisplayName() + ": run " + (i+1) + " failed");
                        }
                    }
                    System.err.println(description.getDisplayName() + ": giving up after " + retryCount + " failures");
                    throw caughtThrowable;
                }
            };
        }
    }

    @Rule
    public Retry retry = new Retry(3);

    @Test
    public void test1() {
    }

    @Test
    public void test2() {
        Object o = null;
        o.equals("foo");
    }
}
******************************
Normalized:
******************************
Original:
public class RetryTest {
    public class Retry implements TestRule {
        private int retryCount;

        public Retry(int retryCount) {
            this.retryCount = retryCount;
        }

        public Statement apply(Statement base, Description description) {
            return statement(base, description);
        }

        private Statement statement(final Statement base, final Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    Throwable caughtThrowable = null;

                    // implement retry logic here
                    for (int i = 0; i &lt; retryCount; i++) {
                        try {
                            base.evaluate();
                            return;
                        } catch (Throwable t) {
                            caughtThrowable = t;
                            System.err.println(description.getDisplayName() + ": run " + (i+1) + " failed");
                        }
                    }
                    System.err.println(description.getDisplayName() + ": giving up after " + retryCount + " failures");
                    throw caughtThrowable;
                }
            };
        }
    }

    @Rule
    public Retry retry = new Retry(3);

    @Test
    public void test1() {
    }

    @Test
    public void test2() {
        Object o = null;
        o.equals("foo");
    }
}
******************************
Normalized:
public class RetryTest {
    public class Retry implements TestRule {
        private int retryCount;

        public Retry(int retryCount) {
            this.retryCount = retryCount;
        }

        public Statement apply(Statement base, Description description) {
            return statement(base, description);
        }

        private Statement statement(final Statement base, final Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    Throwable caughtThrowable = null;

                    // implement retry logic here
                    for (int i = 0; i &lt; retryCount; i++) {
                        try {
                            base.evaluate();
                            return;
                        } catch (Throwable t) {
                            caughtThrowable = t;
                            System.err.println(description.getDisplayName() + ": run " + (i+1) + " failed");
                        }
                    }
                    System.err.println(description.getDisplayName() + ": giving up after " + retryCount + " failures");
                    throw caughtThrowable;
                }
            };
        }
    }

    @Rule
    public Retry retry = new Retry(3);

    @Test
    public void test1() {
    }

    @Test
    public void test2() {
        Object o = null;
        o.equals("foo");
    }
}
******************************
Original:
Set&lt;Integer&gt; s; //contains your Integers
...
Set&lt;Integer&gt; temp = new Set&lt;Integer&gt;();
for(Integer i : s)
    temp.add(i+1);
s.clear();
s.addAll(temp);
******************************
Normalized:
******************************
Original:
Set&lt;Integer&gt; s; //contains your Integers
...
Set&lt;Integer&gt; temp = new Set&lt;Integer&gt;();
for(Integer i : s)
    temp.add(i+1);
s.clear();
s.addAll(temp);
******************************
Normalized:
Set&lt;Integer&gt; s; //contains your Integers
...
Set&lt;Integer&gt; temp = new Set&lt;Integer&gt;();
for(Integer i : s)
    temp.add(i+1);
s.clear();
s.addAll(temp);
******************************
Original:
Future&lt;T&gt; future = ConcurrentUtils.constantFuture(T myValue);
******************************
Normalized:
******************************
Original:
Future&lt;T&gt; future = ConcurrentUtils.constantFuture(T myValue);
******************************
Normalized:
Future&lt;T&gt; future = ConcurrentUtils.constantFuture(T myValue);
******************************
Original:
final EditText edittext = (EditText) findViewById(R.id.edittext);
edittext.setOnKeyListener(new View.OnKeyListener() {
    public boolean onKey(View v, int keyCode, KeyEvent event) {
        if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; keyCode == KeyEvent.KEYCODE_ENTER) {
            Toast.makeText(HelloFormStuff.this, edittext.getText(), Toast.LENGTH_SHORT).show();
            return true;
        }
        return false;
    }
});
******************************
Normalized:
******************************
Original:
final EditText edittext = (EditText) findViewById(R.id.edittext);
edittext.setOnKeyListener(new View.OnKeyListener() {
    public boolean onKey(View v, int keyCode, KeyEvent event) {
        if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; keyCode == KeyEvent.KEYCODE_ENTER) {
            Toast.makeText(HelloFormStuff.this, edittext.getText(), Toast.LENGTH_SHORT).show();
            return true;
        }
        return false;
    }
});
******************************
Normalized:
final EditText edittext = (EditText) findViewById(R.id.edittext);
edittext.setOnKeyListener(new View.OnKeyListener() {
    public boolean onKey(View v, int keyCode, KeyEvent event) {
        if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; keyCode == KeyEvent.KEYCODE_ENTER) {
            Toast.makeText(HelloFormStuff.this, edittext.getText(), Toast.LENGTH_SHORT).show();
            return true;
        }
        return false;
    }
});
******************************
Original:
&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;otherOutputDir&lt;/id&gt;
        &lt;build&gt;
            &lt;directory&gt;yourDirectory&lt;/directory&gt;
        &lt;/build&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
******************************
Normalized:
******************************
Original:
&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;otherOutputDir&lt;/id&gt;
        &lt;build&gt;
            &lt;directory&gt;yourDirectory&lt;/directory&gt;
        &lt;/build&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
******************************
Normalized:
&lt;profiles&gt;
    &lt;profile&gt;
        &lt;id&gt;otherOutputDir&lt;/id&gt;
        &lt;build&gt;
            &lt;directory&gt;yourDirectory&lt;/directory&gt;
        &lt;/build&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
******************************
Original:
...10110110
******************************
Normalized:
******************************
Original:
...10110110
******************************
Normalized:
...10110110
******************************
Original:
@ManyToMany(fetch = FetchType.EAGER)
******************************
Normalized:
******************************
Original:
@ManyToMany(fetch = FetchType.EAGER)
******************************
Normalized:
@ManyToMany(fetch = FetchType.EAGER)
******************************
Original:
(IDLjava/lang/Thread;)Ljava/lang/Object;
******************************
Normalized:
******************************
Original:
(IDLjava/lang/Thread;)Ljava/lang/Object;
******************************
Normalized:
(IDLjava/lang/Thread;)Ljava/lang/Object;
******************************
Original:
$ mvn dependency:copy-dependencies -DoutputDirectory=OUTPUT_DIR
******************************
Normalized:
******************************
Original:
$ mvn dependency:copy-dependencies -DoutputDirectory=OUTPUT_DIR
******************************
Normalized:
$ mvn dependency:copy-dependencies -DoutputDirectory=OUTPUT_DIR
******************************
Original:
(?:\u{D A}|(?!\u{D A})[\u{A}-\u{D}\u{85}\u{2028}\u{2029}]
******************************
Normalized:
******************************
Original:
(?:\u{D A}|(?!\u{D A})[\u{A}-\u{D}\u{85}\u{2028}\u{2029}]
******************************
Normalized:
(?:\u{D A}|(?!\u{D A})[\u{A}-\u{D}\u{85}\u{2028}\u{2029}]
******************************
Original:
module org.example.foo {
    requires java.xml.bind;
}
******************************
Normalized:
******************************
Original:
module org.example.foo {
    requires java.xml.bind;
}
******************************
Normalized:
module org.example.foo {
    requires java.xml.bind;
}
******************************
Original:
public class CompletionServiceTest {

        class CalcResult {
             long result ;

             CalcResult(long l) {
                 result = l;
             }
        }

        class CallableTask implements Callable&lt;CalcResult&gt; {
            String taskName ;
            long  input1 ;
            int input2 ;

            CallableTask(String name , long v1 , int v2 ) {
                taskName = name;
                input1 = v1;
                input2 = v2 ;
            }

            public CalcResult call() throws Exception {
                System.out.println(" Task " + taskName + " Started -----");
                for(int i=0;i&lt;input2 ;i++) {
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        System.out.println(" Task " + taskName + " Interrupted !! ");
                        e.printStackTrace();
                    }
                    input1 += i;
                }
                System.out.println(" Task " + taskName + " Completed @@@@@@");
                return new CalcResult(input1) ;
            }

        }

        public void test(){
            ExecutorService taskExecutor = Executors.newFixedThreadPool(3);
            CompletionService&lt;CalcResult&gt; taskCompletionService = new ExecutorCompletionService&lt;CalcResult&gt;(taskExecutor);

            int submittedTasks = 5;
            for (int i=0;i&lt; submittedTasks;i++) {
                taskCompletionService.submit(new CallableTask (
                        String.valueOf(i), 
                            (i * 10), 
                            ((i * 10) + 10  )
                        ));
               System.out.println("Task " + String.valueOf(i) + "subitted");
            }
            for (int tasksHandled=0;tasksHandled&lt;submittedTasks;tasksHandled++) {
                try {
                    System.out.println("trying to take from Completion service");
                    Future&lt;CalcResult&gt; result = taskCompletionService.take();
                    System.out.println("result for a task availble in queue.Trying to get()");
                    // above call blocks till atleast one task is completed and results availble for it
                    // but we dont have to worry which one

                    // process the result here by doing result.get()
                    CalcResult l = result.get();
                    System.out.println("Task " + String.valueOf(tasksHandled) + "Completed - results obtained : " + String.valueOf(l.result));

                } catch (InterruptedException e) {
                    // Something went wrong with a task submitted
                    System.out.println("Error Interrupted exception");
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    // Something went wrong with the result
                    e.printStackTrace();
                    System.out.println("Error get() threw exception");
                }
            }
        }
    }
******************************
Normalized:
******************************
Original:
public class CompletionServiceTest {

        class CalcResult {
             long result ;

             CalcResult(long l) {
                 result = l;
             }
        }

        class CallableTask implements Callable&lt;CalcResult&gt; {
            String taskName ;
            long  input1 ;
            int input2 ;

            CallableTask(String name , long v1 , int v2 ) {
                taskName = name;
                input1 = v1;
                input2 = v2 ;
            }

            public CalcResult call() throws Exception {
                System.out.println(" Task " + taskName + " Started -----");
                for(int i=0;i&lt;input2 ;i++) {
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        System.out.println(" Task " + taskName + " Interrupted !! ");
                        e.printStackTrace();
                    }
                    input1 += i;
                }
                System.out.println(" Task " + taskName + " Completed @@@@@@");
                return new CalcResult(input1) ;
            }

        }

        public void test(){
            ExecutorService taskExecutor = Executors.newFixedThreadPool(3);
            CompletionService&lt;CalcResult&gt; taskCompletionService = new ExecutorCompletionService&lt;CalcResult&gt;(taskExecutor);

            int submittedTasks = 5;
            for (int i=0;i&lt; submittedTasks;i++) {
                taskCompletionService.submit(new CallableTask (
                        String.valueOf(i), 
                            (i * 10), 
                            ((i * 10) + 10  )
                        ));
               System.out.println("Task " + String.valueOf(i) + "subitted");
            }
            for (int tasksHandled=0;tasksHandled&lt;submittedTasks;tasksHandled++) {
                try {
                    System.out.println("trying to take from Completion service");
                    Future&lt;CalcResult&gt; result = taskCompletionService.take();
                    System.out.println("result for a task availble in queue.Trying to get()");
                    // above call blocks till atleast one task is completed and results availble for it
                    // but we dont have to worry which one

                    // process the result here by doing result.get()
                    CalcResult l = result.get();
                    System.out.println("Task " + String.valueOf(tasksHandled) + "Completed - results obtained : " + String.valueOf(l.result));

                } catch (InterruptedException e) {
                    // Something went wrong with a task submitted
                    System.out.println("Error Interrupted exception");
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    // Something went wrong with the result
                    e.printStackTrace();
                    System.out.println("Error get() threw exception");
                }
            }
        }
    }
******************************
Normalized:
public class CompletionServiceTest {

        class CalcResult {
             long result ;

             CalcResult(long l) {
                 result = l;
             }
        }

        class CallableTask implements Callable&lt;CalcResult&gt; {
            String taskName ;
            long  input1 ;
            int input2 ;

            CallableTask(String name , long v1 , int v2 ) {
                taskName = name;
                input1 = v1;
                input2 = v2 ;
            }

            public CalcResult call() throws Exception {
                System.out.println(" Task " + taskName + " Started -----");
                for(int i=0;i&lt;input2 ;i++) {
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        System.out.println(" Task " + taskName + " Interrupted !! ");
                        e.printStackTrace();
                    }
                    input1 += i;
                }
                System.out.println(" Task " + taskName + " Completed @@@@@@");
                return new CalcResult(input1) ;
            }

        }

        public void test(){
            ExecutorService taskExecutor = Executors.newFixedThreadPool(3);
            CompletionService&lt;CalcResult&gt; taskCompletionService = new ExecutorCompletionService&lt;CalcResult&gt;(taskExecutor);

            int submittedTasks = 5;
            for (int i=0;i&lt; submittedTasks;i++) {
                taskCompletionService.submit(new CallableTask (
                        String.valueOf(i), 
                            (i * 10), 
                            ((i * 10) + 10  )
                        ));
               System.out.println("Task " + String.valueOf(i) + "subitted");
            }
            for (int tasksHandled=0;tasksHandled&lt;submittedTasks;tasksHandled++) {
                try {
                    System.out.println("trying to take from Completion service");
                    Future&lt;CalcResult&gt; result = taskCompletionService.take();
                    System.out.println("result for a task availble in queue.Trying to get()");
                    // above call blocks till atleast one task is completed and results availble for it
                    // but we dont have to worry which one

                    // process the result here by doing result.get()
                    CalcResult l = result.get();
                    System.out.println("Task " + String.valueOf(tasksHandled) + "Completed - results obtained : " + String.valueOf(l.result));

                } catch (InterruptedException e) {
                    // Something went wrong with a task submitted
                    System.out.println("Error Interrupted exception");
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    // Something went wrong with the result
                    e.printStackTrace();
                    System.out.println("Error get() threw exception");
                }
            }
        }
    }
******************************
Original:
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/*")
public class MyApplication extends Application {
    ...
}
******************************
Normalized:
******************************
Original:
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/*")
public class MyApplication extends Application {
    ...
}
******************************
Normalized:
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/*")
public class MyApplication extends Application {
    ...
}
******************************
Original:
List&lt;Integer&gt; idList = students.stream().map(Student::getId).collect(Collectors.toList());
******************************
Normalized:
******************************
Original:
List&lt;Integer&gt; idList = students.stream().map(Student::getId).collect(Collectors.toList());
******************************
Normalized:
List&lt;Integer&gt; idList = students.stream().map(Student::getId).collect(Collectors.toList());
******************************
Original:
Collectors.toMap(p -&gt; p.getLast(), Function.identity())
******************************
Normalized:
******************************
Original:
Collectors.toMap(p -&gt; p.getLast(), Function.identity())
******************************
Normalized:
Collectors.toMap(p -&gt; p.getLast(), Function.identity())
******************************
Original:
for(int k = 0; k &lt; strings.length; k++){
   // something
}
******************************
Normalized:
******************************
Original:
for(int k = 0; k &lt; strings.length; k++){
   // something
}
******************************
Normalized:
for(int k = 0; k &lt; strings.length; k++){
   // something
}
******************************
Original:
public void writeToParcel(Parcel out, int flags) {
    out.writeString(_mac);
    out.writeString(_pan);
    out.writeInt(_band);
    out.writeSerializable(_lqis);
    out.writeTypedList(_devices);
}

private ZigBeeNetwork(Parcel in) {
    _mac = in.readString();
    _pan = in.readString();
    _band = in.readInt();
    _lqis = (ArrayList&lt;Integer&gt;) in.readSerializable();
    in.readTypedList(_devices, ZigBeeDev.CREATOR);
}
******************************
Normalized:
******************************
Original:
public void writeToParcel(Parcel out, int flags) {
    out.writeString(_mac);
    out.writeString(_pan);
    out.writeInt(_band);
    out.writeSerializable(_lqis);
    out.writeTypedList(_devices);
}

private ZigBeeNetwork(Parcel in) {
    _mac = in.readString();
    _pan = in.readString();
    _band = in.readInt();
    _lqis = (ArrayList&lt;Integer&gt;) in.readSerializable();
    in.readTypedList(_devices, ZigBeeDev.CREATOR);
}
******************************
Normalized:
public void writeToParcel(Parcel out, int flags) {
    out.writeString(_mac);
    out.writeString(_pan);
    out.writeInt(_band);
    out.writeSerializable(_lqis);
    out.writeTypedList(_devices);
}

private ZigBeeNetwork(Parcel in) {
    _mac = in.readString();
    _pan = in.readString();
    _band = in.readInt();
    _lqis = (ArrayList&lt;Integer&gt;) in.readSerializable();
    in.readTypedList(_devices, ZigBeeDev.CREATOR);
}
******************************
Original:
@Test(expected=IncorrectArgumentForSetter.class)
public void testSetterForeignWord("") throws Exception {
  card.setForeignWord("");
}
******************************
Normalized:
******************************
Original:
@Test(expected=IncorrectArgumentForSetter.class)
public void testSetterForeignWord("") throws Exception {
  card.setForeignWord("");
}
******************************
Normalized:
@Test(expected=IncorrectArgumentForSetter.class)
public void testSetterForeignWord("") throws Exception {
  card.setForeignWord("");
}
******************************
Original:
jboss-as-7
 |
 |---&gt; standalone
 |      |----&gt; lib
 |      |----&gt; configuration
 |      |----&gt; deployments
 |      
 |---&gt; domain
 |....
******************************
Normalized:
******************************
Original:
jboss-as-7
 |
 |---&gt; standalone
 |      |----&gt; lib
 |      |----&gt; configuration
 |      |----&gt; deployments
 |      
 |---&gt; domain
 |....
******************************
Normalized:
jboss-as-7
 |
 |---&gt; standalone
 |      |----&gt; lib
 |      |----&gt; configuration
 |      |----&gt; deployments
 |      
 |---&gt; domain
 |....
******************************
Original:
@ 16   org.sample.IntStr::inlineSideEffect (25 bytes)   force inline by CompilerOracle
   @ 4   java.lang.StringBuilder::&lt;init&gt; (7 bytes)   inline (hot)
   @ 18   java.lang.StringBuilder::append (8 bytes)   already compiled into a big method
   @ 21   java.lang.StringBuilder::toString (17 bytes)   inline (hot)
******************************
Normalized:
******************************
Original:
@ 16   org.sample.IntStr::inlineSideEffect (25 bytes)   force inline by CompilerOracle
   @ 4   java.lang.StringBuilder::&lt;init&gt; (7 bytes)   inline (hot)
   @ 18   java.lang.StringBuilder::append (8 bytes)   already compiled into a big method
   @ 21   java.lang.StringBuilder::toString (17 bytes)   inline (hot)
******************************
Normalized:
@ 16   org.sample.IntStr::inlineSideEffect (25 bytes)   force inline by CompilerOracle
   @ 4   java.lang.StringBuilder::&lt;init&gt; (7 bytes)   inline (hot)
   @ 18   java.lang.StringBuilder::append (8 bytes)   already compiled into a big method
   @ 21   java.lang.StringBuilder::toString (17 bytes)   inline (hot)
******************************
Original:
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
}
******************************
Normalized:
******************************
Original:
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
}
******************************
Normalized:
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
}
******************************
Original:
@Controller
@RequestMapping(value = "/adminservice")
@Secured("ROLE_ADMIN")
public class AdminServiceController {
******************************
Normalized:
******************************
Original:
@Controller
@RequestMapping(value = "/adminservice")
@Secured("ROLE_ADMIN")
public class AdminServiceController {
******************************
Normalized:
@Controller
@RequestMapping(value = "/adminservice")
@Secured("ROLE_ADMIN")
public class AdminServiceController {
******************************
Original:
public void add(int index, E element)
******************************
Normalized:
******************************
Original:
public void add(int index, E element)
******************************
Normalized:
public void add(int index, E element)
******************************
Original:
dataList = dataList.subList(30, 38 &gt; dataList.size() ? dataList.size() : 38);
******************************
Normalized:
******************************
Original:
dataList = dataList.subList(30, 38 &gt; dataList.size() ? dataList.size() : 38);
******************************
Normalized:
dataList = dataList.subList(30, 38 &gt; dataList.size() ? dataList.size() : 38);
******************************
Original:
String item;

for(int x = 0; x &lt; 10; x++)
{
    // Linear search.
    if(array[x].equals("Item I am looking for"))
    {
       //you've found the item. Let's stop.
       item = array[x];
       break; 
    }
}
******************************
Normalized:
******************************
Original:
String item;

for(int x = 0; x &lt; 10; x++)
{
    // Linear search.
    if(array[x].equals("Item I am looking for"))
    {
       //you've found the item. Let's stop.
       item = array[x];
       break; 
    }
}
******************************
Normalized:
String item;

for(int x = 0; x &lt; 10; x++)
{
    // Linear search.
    if(array[x].equals("Item I am looking for"))
    {
       //you've found the item. Let's stop.
       item = array[x];
       break; 
    }
}
******************************
Original:
public void scheduleAtFixedRate(TimerTask task,
                                long delay,
                                long period)
******************************
Normalized:
******************************
Original:
public void scheduleAtFixedRate(TimerTask task,
                                long delay,
                                long period)
******************************
Normalized:
public void scheduleAtFixedRate(TimerTask task,
                                long delay,
                                long period)
******************************
Original:
@GeneratedValue(strategy = GenerationType.IDENTITY)
******************************
Normalized:
******************************
Original:
@GeneratedValue(strategy = GenerationType.IDENTITY)
******************************
Normalized:
@GeneratedValue(strategy = GenerationType.IDENTITY)
******************************
Original:
ZonedDateTime now = ZonedDateTime.now(ZoneId.of("America/Los_Angeles"));
ZonedDateTime nextRun = now.withHour(5).withMinute(0).withSecond(0);
if(now.compareTo(nextRun) &gt; 0)
    nextRun = nextRun.plusDays(1);

Duration duration = Duration.between(now, nextRun);
long initalDelay = duration.getSeconds();

ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);            
scheduler.scheduleAtFixedRate(new MyRunnableTask(),
    initalDelay,
    TimeUnit.DAYS.toSeconds(1),
    TimeUnit.SECONDS);
******************************
Normalized:
******************************
Original:
ZonedDateTime now = ZonedDateTime.now(ZoneId.of("America/Los_Angeles"));
ZonedDateTime nextRun = now.withHour(5).withMinute(0).withSecond(0);
if(now.compareTo(nextRun) &gt; 0)
    nextRun = nextRun.plusDays(1);

Duration duration = Duration.between(now, nextRun);
long initalDelay = duration.getSeconds();

ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);            
scheduler.scheduleAtFixedRate(new MyRunnableTask(),
    initalDelay,
    TimeUnit.DAYS.toSeconds(1),
    TimeUnit.SECONDS);
******************************
Normalized:
ZonedDateTime now = ZonedDateTime.now(ZoneId.of("America/Los_Angeles"));
ZonedDateTime nextRun = now.withHour(5).withMinute(0).withSecond(0);
if(now.compareTo(nextRun) &gt; 0)
    nextRun = nextRun.plusDays(1);

Duration duration = Duration.between(now, nextRun);
long initalDelay = duration.getSeconds();

ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);            
scheduler.scheduleAtFixedRate(new MyRunnableTask(),
    initalDelay,
    TimeUnit.DAYS.toSeconds(1),
    TimeUnit.SECONDS);
******************************
Original:
\p{L}+
******************************
Normalized:
******************************
Original:
\p{L}+
******************************
Normalized:
\p{L}+
******************************
Original:
Class&lt;?&gt; beanClass = beanDefinition.getClass();
Object bean = beanClass.newInstance();
if (bean instanceof ApplicationContextAware) {
    ((ApplicationContextAware) bean).setApplicationContext(ctx);
}
******************************
Normalized:
******************************
Original:
Class&lt;?&gt; beanClass = beanDefinition.getClass();
Object bean = beanClass.newInstance();
if (bean instanceof ApplicationContextAware) {
    ((ApplicationContextAware) bean).setApplicationContext(ctx);
}
******************************
Normalized:
Class&lt;?&gt; beanClass = beanDefinition.getClass();
Object bean = beanClass.newInstance();
if (bean instanceof ApplicationContextAware) {
    ((ApplicationContextAware) bean).setApplicationContext(ctx);
}
******************************
Original:
Observable
   .from(modifications)
   .flatmap( (data1) -&gt; { 
       return op1(data1)
           ...
           .flatmap( (data2) -&gt; { 
               // I can access data1 here
               return op2(data2);
           })
   });
******************************
Normalized:
******************************
Original:
Observable
   .from(modifications)
   .flatmap( (data1) -&gt; { 
       return op1(data1)
           ...
           .flatmap( (data2) -&gt; { 
               // I can access data1 here
               return op2(data2);
           })
   });
******************************
Normalized:
Observable
   .from(modifications)
   .flatmap( (data1) -&gt; { 
       return op1(data1)
           ...
           .flatmap( (data2) -&gt; { 
               // I can access data1 here
               return op2(data2);
           })
   });
******************************
Original:
class A implements ICallback {
     MyObject o;
     B b = new B(this, someParameter);

     @Override
     public void callback(MyObject o){
           this.o = o;
     }
}

class B {
     ICallback ic;
     B(ICallback ic, someParameter){
         this.ic = ic;
     }

    new Thread(new Runnable(){
         public void run(){
             // some calculation
             ic.callback(myObject)
         }
    }).start(); 
}

interface ICallback{
    public void callback(MyObject o);
}
******************************
Normalized:
******************************
Original:
class A implements ICallback {
     MyObject o;
     B b = new B(this, someParameter);

     @Override
     public void callback(MyObject o){
           this.o = o;
     }
}

class B {
     ICallback ic;
     B(ICallback ic, someParameter){
         this.ic = ic;
     }

    new Thread(new Runnable(){
         public void run(){
             // some calculation
             ic.callback(myObject)
         }
    }).start(); 
}

interface ICallback{
    public void callback(MyObject o);
}
******************************
Normalized:
class A implements ICallback {
     MyObject o;
     B b = new B(this, someParameter);

     @Override
     public void callback(MyObject o){
           this.o = o;
     }
}

class B {
     ICallback ic;
     B(ICallback ic, someParameter){
         this.ic = ic;
     }

    new Thread(new Runnable(){
         public void run(){
             // some calculation
             ic.callback(myObject)
         }
    }).start(); 
}

interface ICallback{
    public void callback(MyObject o);
}
******************************
Original:
&lt;import resource="classpath:spring-config.xml" /&gt;
******************************
Normalized:
******************************
Original:
&lt;import resource="classpath:spring-config.xml" /&gt;
******************************
Normalized:
&lt;import resource="classpath:spring-config.xml" /&gt;
******************************
Original:
Optional&lt;&gt; opt = dao.find();

opt.ifPresentOrElse(obj -&gt; obj.setAvailable(true),
                    () -&gt; logger.error("…"));
******************************
Normalized:
******************************
Original:
Optional&lt;&gt; opt = dao.find();

opt.ifPresentOrElse(obj -&gt; obj.setAvailable(true),
                    () -&gt; logger.error("…"));
******************************
Normalized:
Optional&lt;&gt; opt = dao.find();

opt.ifPresentOrElse(obj -&gt; obj.setAvailable(true),
                    () -&gt; logger.error("…"));
******************************
Original:
PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:*.java");

Path filename = ...;
if (matcher.matches(filename)) {
    System.out.println(filename);
}
******************************
Normalized:
******************************
Original:
PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:*.java");

Path filename = ...;
if (matcher.matches(filename)) {
    System.out.println(filename);
}
******************************
Normalized:
PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:*.java");

Path filename = ...;
if (matcher.matches(filename)) {
    System.out.println(filename);
}
******************************
Original:
final class Either&lt;L,R&gt;
{
    public static &lt;L,R&gt; Either&lt;L,R&gt; left(L value) {
        return new Either&lt;&gt;(Optional.of(value), Optional.empty());
    }
    public static &lt;L,R&gt; Either&lt;L,R&gt; right(R value) {
        return new Either&lt;&gt;(Optional.empty(), Optional.of(value));
    }
    private final Optional&lt;L&gt; left;
    private final Optional&lt;R&gt; right;
    private Either(Optional&lt;L&gt; l, Optional&lt;R&gt; r) {
      left=l;
      right=r;
    }
    public &lt;T&gt; T map(
        Function&lt;? super L, ? extends T&gt; lFunc,
        Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return left.&lt;T&gt;map(lFunc).orElseGet(()-&gt;right.map(rFunc).get());
    }
    public &lt;T&gt; Either&lt;T,R&gt; mapLeft(Function&lt;? super L, ? extends T&gt; lFunc)
    {
        return new Either&lt;&gt;(left.map(lFunc),right);
    }
    public &lt;T&gt; Either&lt;L,T&gt; mapRight(Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return new Either&lt;&gt;(left, right.map(rFunc));
    }
    public void apply(Consumer&lt;? super L&gt; lFunc, Consumer&lt;? super R&gt; rFunc)
    {
        left.ifPresent(lFunc);
        right.ifPresent(rFunc);
    }
}
******************************
Normalized:
******************************
Original:
final class Either&lt;L,R&gt;
{
    public static &lt;L,R&gt; Either&lt;L,R&gt; left(L value) {
        return new Either&lt;&gt;(Optional.of(value), Optional.empty());
    }
    public static &lt;L,R&gt; Either&lt;L,R&gt; right(R value) {
        return new Either&lt;&gt;(Optional.empty(), Optional.of(value));
    }
    private final Optional&lt;L&gt; left;
    private final Optional&lt;R&gt; right;
    private Either(Optional&lt;L&gt; l, Optional&lt;R&gt; r) {
      left=l;
      right=r;
    }
    public &lt;T&gt; T map(
        Function&lt;? super L, ? extends T&gt; lFunc,
        Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return left.&lt;T&gt;map(lFunc).orElseGet(()-&gt;right.map(rFunc).get());
    }
    public &lt;T&gt; Either&lt;T,R&gt; mapLeft(Function&lt;? super L, ? extends T&gt; lFunc)
    {
        return new Either&lt;&gt;(left.map(lFunc),right);
    }
    public &lt;T&gt; Either&lt;L,T&gt; mapRight(Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return new Either&lt;&gt;(left, right.map(rFunc));
    }
    public void apply(Consumer&lt;? super L&gt; lFunc, Consumer&lt;? super R&gt; rFunc)
    {
        left.ifPresent(lFunc);
        right.ifPresent(rFunc);
    }
}
******************************
Normalized:
final class Either&lt;L,R&gt;
{
    public static &lt;L,R&gt; Either&lt;L,R&gt; left(L value) {
        return new Either&lt;&gt;(Optional.of(value), Optional.empty());
    }
    public static &lt;L,R&gt; Either&lt;L,R&gt; right(R value) {
        return new Either&lt;&gt;(Optional.empty(), Optional.of(value));
    }
    private final Optional&lt;L&gt; left;
    private final Optional&lt;R&gt; right;
    private Either(Optional&lt;L&gt; l, Optional&lt;R&gt; r) {
      left=l;
      right=r;
    }
    public &lt;T&gt; T map(
        Function&lt;? super L, ? extends T&gt; lFunc,
        Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return left.&lt;T&gt;map(lFunc).orElseGet(()-&gt;right.map(rFunc).get());
    }
    public &lt;T&gt; Either&lt;T,R&gt; mapLeft(Function&lt;? super L, ? extends T&gt; lFunc)
    {
        return new Either&lt;&gt;(left.map(lFunc),right);
    }
    public &lt;T&gt; Either&lt;L,T&gt; mapRight(Function&lt;? super R, ? extends T&gt; rFunc)
    {
        return new Either&lt;&gt;(left, right.map(rFunc));
    }
    public void apply(Consumer&lt;? super L&gt; lFunc, Consumer&lt;? super R&gt; rFunc)
    {
        left.ifPresent(lFunc);
        right.ifPresent(rFunc);
    }
}
******************************
Original:
Foo[] array = ...;
List&lt;Foo&gt; list = new ArrayList&lt;Foo&gt;(Arrays.asList(array));
******************************
Normalized:
******************************
Original:
Foo[] array = ...;
List&lt;Foo&gt; list = new ArrayList&lt;Foo&gt;(Arrays.asList(array));
******************************
Normalized:
Foo[] array = ...;
List&lt;Foo&gt; list = new ArrayList&lt;Foo&gt;(Arrays.asList(array));
******************************
Original:
first:
for( int i = 0; i &lt; 10; i++) {
  second:
  for(int j = 0; j &lt; 5; j ++ )
  {
    break xxx;
  }
}

third:
for( int a = 0; a &lt; 10; a++) {

}
******************************
Normalized:
******************************
Original:
first:
for( int i = 0; i &lt; 10; i++) {
  second:
  for(int j = 0; j &lt; 5; j ++ )
  {
    break xxx;
  }
}

third:
for( int a = 0; a &lt; 10; a++) {

}
******************************
Normalized:
first:
for( int i = 0; i &lt; 10; i++) {
  second:
  for(int j = 0; j &lt; 5; j ++ )
  {
    break xxx;
  }
}

third:
for( int a = 0; a &lt; 10; a++) {

}
******************************
Original:
private final CompositeDisposable disposables = new CompositeDisposable();


// adding an Observable to the disposable
disposables.add(sampleObservable()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeWith(new DisposableObserver&lt;String&gt;() {
                    @Override
                    public void onComplete() {
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(String value) {
                    }
                }));

    static Observable&lt;String&gt; sampleObservable() {
        return Observable.defer(new Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() {
            @Override
            public ObservableSource&lt;? extends String&gt; call() throws Exception {
                // Do some long running operation
                SystemClock.sleep(2000);
                return Observable.just("one", "two", "three", "four", "five");
            }
        });
    }                


// Using clear will clear all, but can accept new disposable
disposables.clear(); 
// Using dispose will clear all and set isDisposed = true, so it will not accept any new disposable
disposables.dispose();
******************************
Normalized:
******************************
Original:
private final CompositeDisposable disposables = new CompositeDisposable();


// adding an Observable to the disposable
disposables.add(sampleObservable()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeWith(new DisposableObserver&lt;String&gt;() {
                    @Override
                    public void onComplete() {
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(String value) {
                    }
                }));

    static Observable&lt;String&gt; sampleObservable() {
        return Observable.defer(new Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() {
            @Override
            public ObservableSource&lt;? extends String&gt; call() throws Exception {
                // Do some long running operation
                SystemClock.sleep(2000);
                return Observable.just("one", "two", "three", "four", "five");
            }
        });
    }                


// Using clear will clear all, but can accept new disposable
disposables.clear(); 
// Using dispose will clear all and set isDisposed = true, so it will not accept any new disposable
disposables.dispose();
******************************
Normalized:
private final CompositeDisposable disposables = new CompositeDisposable();


// adding an Observable to the disposable
disposables.add(sampleObservable()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribeWith(new DisposableObserver&lt;String&gt;() {
                    @Override
                    public void onComplete() {
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(String value) {
                    }
                }));

    static Observable&lt;String&gt; sampleObservable() {
        return Observable.defer(new Callable&lt;ObservableSource&lt;? extends String&gt;&gt;() {
            @Override
            public ObservableSource&lt;? extends String&gt; call() throws Exception {
                // Do some long running operation
                SystemClock.sleep(2000);
                return Observable.just("one", "two", "three", "four", "five");
            }
        });
    }                


// Using clear will clear all, but can accept new disposable
disposables.clear(); 
// Using dispose will clear all and set isDisposed = true, so it will not accept any new disposable
disposables.dispose();
******************************
Original:
public void setShapeValue(int shapeValue){
  if(shapeValue &lt; 100){
    //do something here like throw exception.
  }
}
******************************
Normalized:
******************************
Original:
public void setShapeValue(int shapeValue){
  if(shapeValue &lt; 100){
    //do something here like throw exception.
  }
}
******************************
Normalized:
public void setShapeValue(int shapeValue){
  if(shapeValue &lt; 100){
    //do something here like throw exception.
  }
}
******************************
Original:
[req]
req_extensions = v3_req

[ v3_req ]
subjectAltName=IP:10.0.0.1
# or subjectAltName=DNS:www.example.com
******************************
Normalized:
******************************
Original:
[req]
req_extensions = v3_req

[ v3_req ]
subjectAltName=IP:10.0.0.1
# or subjectAltName=DNS:www.example.com
******************************
Normalized:
[req]
req_extensions = v3_req

[ v3_req ]
subjectAltName=IP:10.0.0.1
# or subjectAltName=DNS:www.example.com
******************************
Original:
List&lt;T&gt; list = Collections.list(enumeration);
******************************
Normalized:
******************************
Original:
List&lt;T&gt; list = Collections.list(enumeration);
******************************
Normalized:
List&lt;T&gt; list = Collections.list(enumeration);
******************************
Original:
public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {
    list.sort(null);
}
******************************
Normalized:
******************************
Original:
public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {
    list.sort(null);
}
******************************
Normalized:
public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {
    list.sort(null);
}
******************************
Original:
public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(
    Function&lt;? super T, ? extends K&gt; keyMapper, 
    Function&lt;? super T, ? extends U&gt; valueMapper) 
{
    return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new);
}
******************************
Normalized:
******************************
Original:
public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(
    Function&lt;? super T, ? extends K&gt; keyMapper, 
    Function&lt;? super T, ? extends U&gt; valueMapper) 
{
    return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new);
}
******************************
Normalized:
public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(
    Function&lt;? super T, ? extends K&gt; keyMapper, 
    Function&lt;? super T, ? extends U&gt; valueMapper) 
{
    return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new);
}
******************************
Original:
&lt;javac ...&gt;
    &lt;compilerarg value="-Xlint"/&gt;
  &lt;/javac&gt;
******************************
Normalized:
******************************
Original:
&lt;javac ...&gt;
    &lt;compilerarg value="-Xlint"/&gt;
  &lt;/javac&gt;
******************************
Normalized:
&lt;javac ...&gt;
    &lt;compilerarg value="-Xlint"/&gt;
  &lt;/javac&gt;
******************************
Original:
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE roles SYSTEM "roles.dtd"&gt;
&lt;roles&gt;
    &lt;role1&gt;User&lt;/role1&gt;
    &lt;role2&gt;Author&lt;/role2&gt;
    &lt;role3&gt;Admin&lt;/role3&gt;
    &lt;role4/&gt;
&lt;/roles&gt;
******************************
Normalized:
******************************
Original:
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE roles SYSTEM "roles.dtd"&gt;
&lt;roles&gt;
    &lt;role1&gt;User&lt;/role1&gt;
    &lt;role2&gt;Author&lt;/role2&gt;
    &lt;role3&gt;Admin&lt;/role3&gt;
    &lt;role4/&gt;
&lt;/roles&gt;
******************************
Normalized:
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE roles SYSTEM "roles.dtd"&gt;
&lt;roles&gt;
    &lt;role1&gt;User&lt;/role1&gt;
    &lt;role2&gt;Author&lt;/role2&gt;
    &lt;role3&gt;Admin&lt;/role3&gt;
    &lt;role4/&gt;
&lt;/roles&gt;
******************************
Original:
if (1 / x &gt; 0)
    // +0 here
else
    // -0 here
******************************
Normalized:
******************************
Original:
if (1 / x &gt; 0)
    // +0 here
else
    // -0 here
******************************
Normalized:
if (1 / x &gt; 0)
    // +0 here
else
    // -0 here
******************************
Original:
log4j.rootLogger=TRACE, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.debugLog=org.apache.log4j.FileAppender
log4j.appender.debugLog.File=logs/debug.log
log4j.appender.debugLog.layout=org.apache.log4j.PatternLayout
log4j.appender.debugLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.reportsLog=org.apache.log4j.FileAppender
log4j.appender.reportsLog.File=logs/reports.log
log4j.appender.reportsLog.layout=org.apache.log4j.PatternLayout
log4j.appender.reportsLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.category.debugLogger=TRACE, debugLog
log4j.additivity.debugLogger=false

log4j.category.reportsLogger=DEBUG, reportsLog
log4j.additivity.reportsLogger=false
******************************
Normalized:
******************************
Original:
log4j.rootLogger=TRACE, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.debugLog=org.apache.log4j.FileAppender
log4j.appender.debugLog.File=logs/debug.log
log4j.appender.debugLog.layout=org.apache.log4j.PatternLayout
log4j.appender.debugLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.reportsLog=org.apache.log4j.FileAppender
log4j.appender.reportsLog.File=logs/reports.log
log4j.appender.reportsLog.layout=org.apache.log4j.PatternLayout
log4j.appender.reportsLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.category.debugLogger=TRACE, debugLog
log4j.additivity.debugLogger=false

log4j.category.reportsLogger=DEBUG, reportsLog
log4j.additivity.reportsLogger=false
******************************
Normalized:
log4j.rootLogger=TRACE, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.debugLog=org.apache.log4j.FileAppender
log4j.appender.debugLog.File=logs/debug.log
log4j.appender.debugLog.layout=org.apache.log4j.PatternLayout
log4j.appender.debugLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.appender.reportsLog=org.apache.log4j.FileAppender
log4j.appender.reportsLog.File=logs/reports.log
log4j.appender.reportsLog.layout=org.apache.log4j.PatternLayout
log4j.appender.reportsLog.layout.ConversionPattern=%d [%24F:%t:%L] - %m%n

log4j.category.debugLogger=TRACE, debugLog
log4j.additivity.debugLogger=false

log4j.category.reportsLogger=DEBUG, reportsLog
log4j.additivity.reportsLogger=false
******************************
Original:
@Override
final void forEachWithCancel(Spliterator&lt;P_OUT&gt; spliterator, Sink&lt;P_OUT&gt; sink) {
    do { } while (!sink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(sink));
}
******************************
Normalized:
******************************
Original:
@Override
final void forEachWithCancel(Spliterator&lt;P_OUT&gt; spliterator, Sink&lt;P_OUT&gt; sink) {
    do { } while (!sink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(sink));
}
******************************
Normalized:
@Override
final void forEachWithCancel(Spliterator&lt;P_OUT&gt; spliterator, Sink&lt;P_OUT&gt; sink) {
    do { } while (!sink.cancellationRequested() &amp;&amp; spliterator.tryAdvance(sink));
}
******************************
Original:
IntPredicate neg = x -&gt; x &lt;- x;
System.out.println(neg.test(4));   // false
System.out.println(neg.test(0));   // false
System.out.println(neg.test(-4));  // true
******************************
Normalized:
******************************
Original:
IntPredicate neg = x -&gt; x &lt;- x;
System.out.println(neg.test(4));   // false
System.out.println(neg.test(0));   // false
System.out.println(neg.test(-4));  // true
******************************
Normalized:
IntPredicate neg = x -&gt; x &lt;- x;
System.out.println(neg.test(4));   // false
System.out.println(neg.test(0));   // false
System.out.println(neg.test(-4));  // true
******************************
Original:
Runnable r1=null;
    for(int i=0; i&lt;2; i++) {
        Runnable r2=System::gc;
        if(r1==null) r1=r2;
        else System.out.println(r1==r2? "shared": "unshared");
    }
******************************
Normalized:
******************************
Original:
Runnable r1=null;
    for(int i=0; i&lt;2; i++) {
        Runnable r2=System::gc;
        if(r1==null) r1=r2;
        else System.out.println(r1==r2? "shared": "unshared");
    }
******************************
Normalized:
Runnable r1=null;
    for(int i=0; i&lt;2; i++) {
        Runnable r2=System::gc;
        if(r1==null) r1=r2;
        else System.out.println(r1==r2? "shared": "unshared");
    }
******************************
Original:
char c = /* whatever */;

switch(c) {
    case 'a':
    case 'A':
        //get the 'A' image;
        break;
    case 'b':
    case 'B':
        //get the 'B' image;
        break;
    // (...)
    case 'z':
    case 'Z':
        //get the 'Z' image;
        break;
}
******************************
Normalized:
******************************
Original:
char c = /* whatever */;

switch(c) {
    case 'a':
    case 'A':
        //get the 'A' image;
        break;
    case 'b':
    case 'B':
        //get the 'B' image;
        break;
    // (...)
    case 'z':
    case 'Z':
        //get the 'Z' image;
        break;
}
******************************
Normalized:
char c = /* whatever */;

switch(c) {
    case 'a':
    case 'A':
        //get the 'A' image;
        break;
    case 'b':
    case 'B':
        //get the 'B' image;
        break;
    // (...)
    case 'z':
    case 'Z':
        //get the 'Z' image;
        break;
}
******************************
Original:
mvn -o install
******************************
Normalized:
******************************
Original:
mvn -o install
******************************
Normalized:
mvn -o install
******************************
Original:
InputStream is = entity.getContent();

.... process the input stream ....

is.close();       // releases all resources
******************************
Normalized:
******************************
Original:
InputStream is = entity.getContent();

.... process the input stream ....

is.close();       // releases all resources
******************************
Normalized:
InputStream is = entity.getContent();

.... process the input stream ....

is.close();       // releases all resources
******************************
Original:
public boolean retryingFindClick(By by) {
    boolean result = false;
    int attempts = 0;
    while(attempts &lt; 2) {
        try {
            driver.findElement(by).click();
            result = true;
            break;
        } catch(StaleElementException e) {
        }
        attempts++;
    }
    return result;
}
******************************
Normalized:
******************************
Original:
public boolean retryingFindClick(By by) {
    boolean result = false;
    int attempts = 0;
    while(attempts &lt; 2) {
        try {
            driver.findElement(by).click();
            result = true;
            break;
        } catch(StaleElementException e) {
        }
        attempts++;
    }
    return result;
}
******************************
Normalized:
public boolean retryingFindClick(By by) {
    boolean result = false;
    int attempts = 0;
    while(attempts &lt; 2) {
        try {
            driver.findElement(by).click();
            result = true;
            break;
        } catch(StaleElementException e) {
        }
        attempts++;
    }
    return result;
}
******************************
Original:
public static void main(String[] args) throws SAXException, IOException,
        ParserConfigurationException, TransformerException {

    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory
        .newInstance();
    DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
    Document document = docBuilder.parse(new File("document.xml"));
    doSomething(document.getDocumentElement());
}

public static void doSomething(Node node) {
    // do something with the current node instead of System.out
    System.out.println(node.getNodeName());

    NodeList nodeList = node.getChildNodes();
    for (int i = 0; i &lt; nodeList.getLength(); i++) {
        Node currentNode = nodeList.item(i);
        if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
            //calls this method for all the children which is Element
            doSomething(currentNode);
        }
    }
}
******************************
Normalized:
******************************
Original:
public static void main(String[] args) throws SAXException, IOException,
        ParserConfigurationException, TransformerException {

    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory
        .newInstance();
    DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
    Document document = docBuilder.parse(new File("document.xml"));
    doSomething(document.getDocumentElement());
}

public static void doSomething(Node node) {
    // do something with the current node instead of System.out
    System.out.println(node.getNodeName());

    NodeList nodeList = node.getChildNodes();
    for (int i = 0; i &lt; nodeList.getLength(); i++) {
        Node currentNode = nodeList.item(i);
        if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
            //calls this method for all the children which is Element
            doSomething(currentNode);
        }
    }
}
******************************
Normalized:
public static void main(String[] args) throws SAXException, IOException,
        ParserConfigurationException, TransformerException {

    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory
        .newInstance();
    DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
    Document document = docBuilder.parse(new File("document.xml"));
    doSomething(document.getDocumentElement());
}

public static void doSomething(Node node) {
    // do something with the current node instead of System.out
    System.out.println(node.getNodeName());

    NodeList nodeList = node.getChildNodes();
    for (int i = 0; i &lt; nodeList.getLength(); i++) {
        Node currentNode = nodeList.item(i);
        if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
            //calls this method for all the children which is Element
            doSomething(currentNode);
        }
    }
}
******************************
Original:
List&lt;V&gt; al = new ArrayList&lt;V&gt;(hashMapVar.values());
******************************
Normalized:
******************************
Original:
List&lt;V&gt; al = new ArrayList&lt;V&gt;(hashMapVar.values());
******************************
Normalized:
List&lt;V&gt; al = new ArrayList&lt;V&gt;(hashMapVar.values());
******************************
Original:
List&lt;Foo&gt; list = createItSomehow();
Random random = new Random();
Foo foo = list.get(random.nextInt(list.size()));
******************************
Normalized:
******************************
Original:
List&lt;Foo&gt; list = createItSomehow();
Random random = new Random();
Foo foo = list.get(random.nextInt(list.size()));
******************************
Normalized:
List&lt;Foo&gt; list = createItSomehow();
Random random = new Random();
Foo foo = list.get(random.nextInt(list.size()));
******************************
Original:
void callback(int val) {
    JNIEnv * g_env;
    // double check it's all ok
    int getEnvStat = g_vm-&gt;GetEnv((void **)&amp;g_env, JNI_VERSION_1_6);
    if (getEnvStat == JNI_EDETACHED) {
        std::cout &lt;&lt; "GetEnv: not attached" &lt;&lt; std::endl;
        if (g_vm-&gt;AttachCurrentThread((void **) &amp;g_env, NULL) != 0) {
            std::cout &lt;&lt; "Failed to attach" &lt;&lt; std::endl;
        }
    } else if (getEnvStat == JNI_OK) {
        //
    } else if (getEnvStat == JNI_EVERSION) {
        std::cout &lt;&lt; "GetEnv: version not supported" &lt;&lt; std::endl;
    }

    g_env-&gt;CallVoidMethod(g_obj, g_mid, val);

    if (g_env-&gt;ExceptionCheck()) {
        g_env-&gt;ExceptionDescribe();
    }

    g_vm-&gt;DetachCurrentThread();
}
******************************
Normalized:
******************************
Original:
void callback(int val) {
    JNIEnv * g_env;
    // double check it's all ok
    int getEnvStat = g_vm-&gt;GetEnv((void **)&amp;g_env, JNI_VERSION_1_6);
    if (getEnvStat == JNI_EDETACHED) {
        std::cout &lt;&lt; "GetEnv: not attached" &lt;&lt; std::endl;
        if (g_vm-&gt;AttachCurrentThread((void **) &amp;g_env, NULL) != 0) {
            std::cout &lt;&lt; "Failed to attach" &lt;&lt; std::endl;
        }
    } else if (getEnvStat == JNI_OK) {
        //
    } else if (getEnvStat == JNI_EVERSION) {
        std::cout &lt;&lt; "GetEnv: version not supported" &lt;&lt; std::endl;
    }

    g_env-&gt;CallVoidMethod(g_obj, g_mid, val);

    if (g_env-&gt;ExceptionCheck()) {
        g_env-&gt;ExceptionDescribe();
    }

    g_vm-&gt;DetachCurrentThread();
}
******************************
Normalized:
void callback(int val) {
    JNIEnv * g_env;
    // double check it's all ok
    int getEnvStat = g_vm-&gt;GetEnv((void **)&amp;g_env, JNI_VERSION_1_6);
    if (getEnvStat == JNI_EDETACHED) {
        std::cout &lt;&lt; "GetEnv: not attached" &lt;&lt; std::endl;
        if (g_vm-&gt;AttachCurrentThread((void **) &amp;g_env, NULL) != 0) {
            std::cout &lt;&lt; "Failed to attach" &lt;&lt; std::endl;
        }
    } else if (getEnvStat == JNI_OK) {
        //
    } else if (getEnvStat == JNI_EVERSION) {
        std::cout &lt;&lt; "GetEnv: version not supported" &lt;&lt; std::endl;
    }

    g_env-&gt;CallVoidMethod(g_obj, g_mid, val);

    if (g_env-&gt;ExceptionCheck()) {
        g_env-&gt;ExceptionDescribe();
    }

    g_vm-&gt;DetachCurrentThread();
}
******************************
Original:
&lt;dependency&gt;
    &lt;groupId&gt;postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;version&gt;VERSION&lt;/version&gt;
&lt;/dependency&gt;
******************************
Normalized:
******************************
Original:
&lt;dependency&gt;
    &lt;groupId&gt;postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;version&gt;VERSION&lt;/version&gt;
&lt;/dependency&gt;
******************************
Normalized:
&lt;dependency&gt;
    &lt;groupId&gt;postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;version&gt;VERSION&lt;/version&gt;
&lt;/dependency&gt;
******************************
Original:
byte[] bytes = new byte[10];
Byte[] byteObjects = new Byte[bytes.length];

int i=0;    
// Associating Byte array values with bytes. (byte[] to Byte[])
for(byte b: bytes)
   byteObjects[i++] = b;  // Autoboxing.

....

int j=0;
// Unboxing Byte values. (Byte[] to byte[])
for(Byte b: byteObjects)
    bytes[j++] = b.byteValue();
******************************
Normalized:
******************************
Original:
byte[] bytes = new byte[10];
Byte[] byteObjects = new Byte[bytes.length];

int i=0;    
// Associating Byte array values with bytes. (byte[] to Byte[])
for(byte b: bytes)
   byteObjects[i++] = b;  // Autoboxing.

....

int j=0;
// Unboxing Byte values. (Byte[] to byte[])
for(Byte b: byteObjects)
    bytes[j++] = b.byteValue();
******************************
Normalized:
byte[] bytes = new byte[10];
Byte[] byteObjects = new Byte[bytes.length];

int i=0;    
// Associating Byte array values with bytes. (byte[] to Byte[])
for(byte b: bytes)
   byteObjects[i++] = b;  // Autoboxing.

....

int j=0;
// Unboxing Byte values. (Byte[] to byte[])
for(Byte b: byteObjects)
    bytes[j++] = b.byteValue();
******************************
Original:
val arrayOfZeros = IntArray(size) //equivalent in Java: new int[size]
val numbersFromOne = IntArray(size) { it + 1 }
val myInts = intArrayOf(1, 1, 2, 3, 5, 8, 13, 21)
******************************
Normalized:
******************************
Original:
val arrayOfZeros = IntArray(size) //equivalent in Java: new int[size]
val numbersFromOne = IntArray(size) { it + 1 }
val myInts = intArrayOf(1, 1, 2, 3, 5, 8, 13, 21)
******************************
Normalized:
val arrayOfZeros = IntArray(size) //equivalent in Java: new int[size]
val numbersFromOne = IntArray(size) { it + 1 }
val myInts = intArrayOf(1, 1, 2, 3, 5, 8, 13, 21)
******************************
Original:
&lt;FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:id="@+id/root_view"&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText1"
        android:layout_height="fill_parent"&gt;
    &lt;/EditText&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText2"
        android:layout_height="fill_parent"&gt;
        &lt;requestFocus&gt;&lt;/requestFocus&gt;
    &lt;/EditText&gt;

&lt;/FrameLayout&gt;
******************************
Normalized:
******************************
Original:
&lt;FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:id="@+id/root_view"&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText1"
        android:layout_height="fill_parent"&gt;
    &lt;/EditText&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText2"
        android:layout_height="fill_parent"&gt;
        &lt;requestFocus&gt;&lt;/requestFocus&gt;
    &lt;/EditText&gt;

&lt;/FrameLayout&gt;
******************************
Normalized:
&lt;FrameLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:id="@+id/root_view"&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText1"
        android:layout_height="fill_parent"&gt;
    &lt;/EditText&gt;

    &lt;EditText
        android:layout_width="fill_parent"
        android:id="@+id/editText2"
        android:layout_height="fill_parent"&gt;
        &lt;requestFocus&gt;&lt;/requestFocus&gt;
    &lt;/EditText&gt;

&lt;/FrameLayout&gt;
******************************
Original:
public boolean AndSC(int x, int value, int y) {
    return value &gt;= x &amp;&amp; value &lt;= y;
}

public boolean AndNonSC(int x, int value, int y) {
    return value &gt;= x &amp; value &lt;= y;
}
******************************
Normalized:
******************************
Original:
public boolean AndSC(int x, int value, int y) {
    return value &gt;= x &amp;&amp; value &lt;= y;
}

public boolean AndNonSC(int x, int value, int y) {
    return value &gt;= x &amp; value &lt;= y;
}
******************************
Normalized:
public boolean AndSC(int x, int value, int y) {
    return value &gt;= x &amp;&amp; value &lt;= y;
}

public boolean AndNonSC(int x, int value, int y) {
    return value &gt;= x &amp; value &lt;= y;
}
******************************
Original:
&lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt;
******************************
Normalized:
******************************
Original:
&lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt;
******************************
Normalized:
&lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt;
******************************
Original:
sudo apt-get install openjdk-11-jdk
******************************
Normalized:
******************************
Original:
sudo apt-get install openjdk-11-jdk
******************************
Normalized:
sudo apt-get install openjdk-11-jdk
******************************
Original:
@Configuration
@EnableScheduling
public class SpringConfiguration {

    @Bean(destroyMethod = "shutdown")
    public Executor taskScheduler() {
        return Executors.newScheduledThreadPool(5);
    }
    ...
******************************
Normalized:
******************************
Original:
@Configuration
@EnableScheduling
public class SpringConfiguration {

    @Bean(destroyMethod = "shutdown")
    public Executor taskScheduler() {
        return Executors.newScheduledThreadPool(5);
    }
    ...
******************************
Normalized:
@Configuration
@EnableScheduling
public class SpringConfiguration {

    @Bean(destroyMethod = "shutdown")
    public Executor taskScheduler() {
        return Executors.newScheduledThreadPool(5);
    }
    ...
******************************
Original:
@Autowired
private Item&lt;String&gt; strItem; // Injects the stringItem bean

@Autowired
private Item&lt;Integer&gt; intItem; // Injects the integerItem bean
******************************
Normalized:
******************************
Original:
@Autowired
private Item&lt;String&gt; strItem; // Injects the stringItem bean

@Autowired
private Item&lt;Integer&gt; intItem; // Injects the integerItem bean
******************************
Normalized:
@Autowired
private Item&lt;String&gt; strItem; // Injects the stringItem bean

@Autowired
private Item&lt;Integer&gt; intItem; // Injects the integerItem bean
******************************
Original:
Project
| src
| | main
|   | java
|     | [your source code]
|   | resources
|     | META-INF
|       | services
|         | [your service files]
******************************
Normalized:
******************************
Original:
Project
| src
| | main
|   | java
|     | [your source code]
|   | resources
|     | META-INF
|       | services
|         | [your service files]
******************************
Normalized:
Project
| src
| | main
|   | java
|     | [your source code]
|   | resources
|     | META-INF
|       | services
|         | [your service files]
******************************
Original:
import org.springframework.batch.item.ItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("foo-reader")
@Scope("step")
public final class MyReader implements ItemReader&lt;MyData&gt; {
  @Override
  public MyData read() throws Exception {
    //...
  }

  @Value("#{jobParameters['fileName']}")
  public void setFileName(final String name) {
    //...
  }
}
******************************
Normalized:
******************************
Original:
import org.springframework.batch.item.ItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("foo-reader")
@Scope("step")
public final class MyReader implements ItemReader&lt;MyData&gt; {
  @Override
  public MyData read() throws Exception {
    //...
  }

  @Value("#{jobParameters['fileName']}")
  public void setFileName(final String name) {
    //...
  }
}
******************************
Normalized:
import org.springframework.batch.item.ItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component("foo-reader")
@Scope("step")
public final class MyReader implements ItemReader&lt;MyData&gt; {
  @Override
  public MyData read() throws Exception {
    //...
  }

  @Value("#{jobParameters['fileName']}")
  public void setFileName(final String name) {
    //...
  }
}
******************************
Original:
Object[] array;
for(Object o : array) { }
Iterable&lt;Object&gt; list;
for(Object o : list) { }
Iterator&lt;Object&gt; iter;
while(iter.hasNext()) { Object o = iter.next(); }
******************************
Normalized:
******************************
Original:
Object[] array;
for(Object o : array) { }
Iterable&lt;Object&gt; list;
for(Object o : list) { }
Iterator&lt;Object&gt; iter;
while(iter.hasNext()) { Object o = iter.next(); }
******************************
Normalized:
Object[] array;
for(Object o : array) { }
Iterable&lt;Object&gt; list;
for(Object o : list) { }
Iterator&lt;Object&gt; iter;
while(iter.hasNext()) { Object o = iter.next(); }
******************************
Original:
import java.text.Normalizer;

public static String stripAccents(String s) 
{
    s = Normalizer.normalize(s, Normalizer.Form.NFD);
    s = s.replaceAll("[\\p{InCombiningDiacriticalMarks}]", "");
    return s;
}
******************************
Normalized:
******************************
Original:
import java.text.Normalizer;

public static String stripAccents(String s) 
{
    s = Normalizer.normalize(s, Normalizer.Form.NFD);
    s = s.replaceAll("[\\p{InCombiningDiacriticalMarks}]", "");
    return s;
}
******************************
Normalized:
import java.text.Normalizer;

public static String stripAccents(String s) 
{
    s = Normalizer.normalize(s, Normalizer.Form.NFD);
    s = s.replaceAll("[\\p{InCombiningDiacriticalMarks}]", "");
    return s;
}
******************************
Original:
public class CustomJsonDateDeserializer extends JsonDeserializer&lt;Date&gt;
{
    @Override
    public Date deserialize(JsonParser jsonParser,
            DeserializationContext deserializationContext) throws IOException, JsonProcessingException {

        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
        String date = jsonParser.getText();
        try {
            return format.parse(date);
        } catch (ParseException e) {
            throw new RuntimeException(e);
        }

    }

}
******************************
Normalized:
******************************
Original:
public class CustomJsonDateDeserializer extends JsonDeserializer&lt;Date&gt;
{
    @Override
    public Date deserialize(JsonParser jsonParser,
            DeserializationContext deserializationContext) throws IOException, JsonProcessingException {

        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
        String date = jsonParser.getText();
        try {
            return format.parse(date);
        } catch (ParseException e) {
            throw new RuntimeException(e);
        }

    }

}
******************************
Normalized:
public class CustomJsonDateDeserializer extends JsonDeserializer&lt;Date&gt;
{
    @Override
    public Date deserialize(JsonParser jsonParser,
            DeserializationContext deserializationContext) throws IOException, JsonProcessingException {

        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
        String date = jsonParser.getText();
        try {
            return format.parse(date);
        } catch (ParseException e) {
            throw new RuntimeException(e);
        }

    }

}
******************************
Original:
00 00 00 00 =&gt; (byte) 0
00 00 00 01 =&gt; (byte) 1
00 00 00 10 =&gt; (byte) 2
...
01 11 11 11 =&gt; (byte) Byte.MAX_VALUE
******************************
Normalized:
******************************
Original:
00 00 00 00 =&gt; (byte) 0
00 00 00 01 =&gt; (byte) 1
00 00 00 10 =&gt; (byte) 2
...
01 11 11 11 =&gt; (byte) Byte.MAX_VALUE
******************************
Normalized:
00 00 00 00 =&gt; (byte) 0
00 00 00 01 =&gt; (byte) 1
00 00 00 10 =&gt; (byte) 2
...
01 11 11 11 =&gt; (byte) Byte.MAX_VALUE
******************************
Original:
!StringUtils.isAlphanumeric(String)
******************************
Normalized:
******************************
Original:
!StringUtils.isAlphanumeric(String)
******************************
Normalized:
!StringUtils.isAlphanumeric(String)
******************************
Original:
#
# Build stage
#
FROM maven:3.6.0-jdk-11-slim AS build
COPY src /home/app/src
COPY pom.xml /home/app
RUN mvn -f /home/app/pom.xml clean package

#
# Package stage
#
FROM openjdk:11-jre-slim
COPY --from=build /home/app/target/demo-0.0.1-SNAPSHOT.jar /usr/local/lib/demo.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","/usr/local/lib/demo.jar"]
******************************
Normalized:
******************************
Original:
#
# Build stage
#
FROM maven:3.6.0-jdk-11-slim AS build
COPY src /home/app/src
COPY pom.xml /home/app
RUN mvn -f /home/app/pom.xml clean package

#
# Package stage
#
FROM openjdk:11-jre-slim
COPY --from=build /home/app/target/demo-0.0.1-SNAPSHOT.jar /usr/local/lib/demo.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","/usr/local/lib/demo.jar"]
******************************
Normalized:
#
# Build stage
#
FROM maven:3.6.0-jdk-11-slim AS build
COPY src /home/app/src
COPY pom.xml /home/app
RUN mvn -f /home/app/pom.xml clean package

#
# Package stage
#
FROM openjdk:11-jre-slim
COPY --from=build /home/app/target/demo-0.0.1-SNAPSHOT.jar /usr/local/lib/demo.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","/usr/local/lib/demo.jar"]
******************************
Original:
set.removeIf(item -&gt; {
    if (!item.qualify())
        return false;
    item.operate();
    return true;
});
******************************
Normalized:
******************************
Original:
set.removeIf(item -&gt; {
    if (!item.qualify())
        return false;
    item.operate();
    return true;
});
******************************
Normalized:
set.removeIf(item -&gt; {
    if (!item.qualify())
        return false;
    item.operate();
    return true;
});
******************************
Original:
List&lt;String&gt; numbers = Arrays.asList("zero", "one", "two");
ListIterator&lt;String&gt; it = numbers.listIterator();
while (it.hasNext()) {
    System.out.println(it.nextIndex() + " " + it.next());
}
******************************
Normalized:
******************************
Original:
List&lt;String&gt; numbers = Arrays.asList("zero", "one", "two");
ListIterator&lt;String&gt; it = numbers.listIterator();
while (it.hasNext()) {
    System.out.println(it.nextIndex() + " " + it.next());
}
******************************
Normalized:
List&lt;String&gt; numbers = Arrays.asList("zero", "one", "two");
ListIterator&lt;String&gt; it = numbers.listIterator();
while (it.hasNext()) {
    System.out.println(it.nextIndex() + " " + it.next());
}
******************************
Original:
public class MyAdapter extends Adapter {
     private Context context;

     public MyAdapter(Context context) {
          this.context = context;     
     }

     public View getView(...){
         View v;
         v.setOnClickListener(new OnClickListener() {
             void onClick() {
                 context.startActivity(...);
             }
         });
     }
}
******************************
Normalized:
******************************
Original:
public class MyAdapter extends Adapter {
     private Context context;

     public MyAdapter(Context context) {
          this.context = context;     
     }

     public View getView(...){
         View v;
         v.setOnClickListener(new OnClickListener() {
             void onClick() {
                 context.startActivity(...);
             }
         });
     }
}
******************************
Normalized:
public class MyAdapter extends Adapter {
     private Context context;

     public MyAdapter(Context context) {
          this.context = context;     
     }

     public View getView(...){
         View v;
         v.setOnClickListener(new OnClickListener() {
             void onClick() {
                 context.startActivity(...);
             }
         });
     }
}
******************************
Original:
sudo apt-get install openjdk-11-jdk
******************************
Normalized:
******************************
Original:
sudo apt-get install openjdk-11-jdk
******************************
Normalized:
sudo apt-get install openjdk-11-jdk
******************************
Original:
double[] target = new double[doubles.size()];
 for (int i = 0; i &lt; target.length; i++) {
    target[i] = doubles.get(i).doubleValue();  // java 1.4 style
    // or:
    target[i] = doubles.get(i);                // java 1.5+ style (outboxing)
 }
******************************
Normalized:
******************************
Original:
double[] target = new double[doubles.size()];
 for (int i = 0; i &lt; target.length; i++) {
    target[i] = doubles.get(i).doubleValue();  // java 1.4 style
    // or:
    target[i] = doubles.get(i);                // java 1.5+ style (outboxing)
 }
******************************
Normalized:
double[] target = new double[doubles.size()];
 for (int i = 0; i &lt; target.length; i++) {
    target[i] = doubles.get(i).doubleValue();  // java 1.4 style
    // or:
    target[i] = doubles.get(i);                // java 1.5+ style (outboxing)
 }
******************************
Original:
List&lt;Email&gt; findByEmailIdInAndPincodeIn(List&lt;String&gt; emails, List&lt;String&gt; pinCodes);
******************************
Normalized:
******************************
Original:
List&lt;Email&gt; findByEmailIdInAndPincodeIn(List&lt;String&gt; emails, List&lt;String&gt; pinCodes);
******************************
Normalized:
List&lt;Email&gt; findByEmailIdInAndPincodeIn(List&lt;String&gt; emails, List&lt;String&gt; pinCodes);
******************************
Original:
.andExpect(jsonPath("$.password").doesNotExist())
******************************
Normalized:
******************************
Original:
.andExpect(jsonPath("$.password").doesNotExist())
******************************
Normalized:
.andExpect(jsonPath("$.password").doesNotExist())
******************************
Original:
class SomethingSyncd {
    @Synchronized fun syncFoo() {

    }

    val myLock = Any()

    fun foo() {
        synchronized(myLock) {
            // ... code
        }
    }

    @Volatile var thing = mapOf(...)
}
******************************
Normalized:
******************************
Original:
class SomethingSyncd {
    @Synchronized fun syncFoo() {

    }

    val myLock = Any()

    fun foo() {
        synchronized(myLock) {
            // ... code
        }
    }

    @Volatile var thing = mapOf(...)
}
******************************
Normalized:
class SomethingSyncd {
    @Synchronized fun syncFoo() {

    }

    val myLock = Any()

    fun foo() {
        synchronized(myLock) {
            // ... code
        }
    }

    @Volatile var thing = mapOf(...)
}
******************************
Original:
private fun &lt;T&gt; anyObject(): T {
    Mockito.anyObject&lt;T&gt;()
    return uninitialized()
}

private fun &lt;T&gt; uninitialized(): T = null as T

@Test
fun myTest() {
    `when`(mockedBackend).login(anyObject())).thenAnswer { ... }
}
******************************
Normalized:
******************************
Original:
private fun &lt;T&gt; anyObject(): T {
    Mockito.anyObject&lt;T&gt;()
    return uninitialized()
}

private fun &lt;T&gt; uninitialized(): T = null as T

@Test
fun myTest() {
    `when`(mockedBackend).login(anyObject())).thenAnswer { ... }
}
******************************
Normalized:
private fun &lt;T&gt; anyObject(): T {
    Mockito.anyObject&lt;T&gt;()
    return uninitialized()
}

private fun &lt;T&gt; uninitialized(): T = null as T

@Test
fun myTest() {
    `when`(mockedBackend).login(anyObject())).thenAnswer { ... }
}
******************************
Original:
public final class SupplierUtils {
    private SupplierUtils() {
    }

    public static &lt;T&gt; Supplier&lt;T&gt; wrap(Callable&lt;T&gt; callable) {
        return () -&gt; {
            try {
                return callable.call();
            }
            catch (RuntimeException e) {
                throw e;
            }
            catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
}

public class JdbcConnectionPool extends ObjectPool&lt;Connection&gt; {

    public JdbcConnectionPool(int maxConnections, String url) {
        super(SupplierUtils.wrap(() -&gt; DriverManager.getConnection(url)), maxConnections);
    }
}
******************************
Normalized:
******************************
Original:
public final class SupplierUtils {
    private SupplierUtils() {
    }

    public static &lt;T&gt; Supplier&lt;T&gt; wrap(Callable&lt;T&gt; callable) {
        return () -&gt; {
            try {
                return callable.call();
            }
            catch (RuntimeException e) {
                throw e;
            }
            catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
}

public class JdbcConnectionPool extends ObjectPool&lt;Connection&gt; {

    public JdbcConnectionPool(int maxConnections, String url) {
        super(SupplierUtils.wrap(() -&gt; DriverManager.getConnection(url)), maxConnections);
    }
}
******************************
Normalized:
public final class SupplierUtils {
    private SupplierUtils() {
    }

    public static &lt;T&gt; Supplier&lt;T&gt; wrap(Callable&lt;T&gt; callable) {
        return () -&gt; {
            try {
                return callable.call();
            }
            catch (RuntimeException e) {
                throw e;
            }
            catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
}

public class JdbcConnectionPool extends ObjectPool&lt;Connection&gt; {

    public JdbcConnectionPool(int maxConnections, String url) {
        super(SupplierUtils.wrap(() -&gt; DriverManager.getConnection(url)), maxConnections);
    }
}
******************************
Original:
/**
 * This resolver handles command objects annotated with @SupportsAnnotationParameterResolution
 * that are passed as parameters to controller methods.
 * 
 * It parses @CommandPerameter annotations on command objects to
 * populate the Binder with the appropriate values (that is, the filed names
 * corresponding to the GET parameters)
 * 
 * In order to achieve this, small pieces of code are copied from spring-mvc
 * classes (indicated in-place). The alternative to the copied lines would be to
 * have a decorator around the Binder, but that would be more tedious, and still
 * some methods would need to be copied.
 * 
 * @author bozho
 * 
 */
public class AnnotationServletModelAttributeResolver extends ServletModelAttributeMethodProcessor {

    /**
     * A map caching annotation definitions of command objects (@CommandParameter-to-fieldname mappings)
     */
    private ConcurrentMap&lt;Class&lt;?&gt;, Map&lt;String, String&gt;&gt; definitionsCache = Maps.newConcurrentMap();

    public AnnotationServletModelAttributeResolver(boolean annotationNotRequired) {
        super(annotationNotRequired);
    }

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        if (parameter.getParameterType().isAnnotationPresent(SupportsAnnotationParameterResolution.class)) {
            return true;
        }
        return false;
    }

    @Override
    protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
        ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);
        ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
        bind(servletRequest, servletBinder);
    }

    @SuppressWarnings("unchecked")
    public void bind(ServletRequest request, ServletRequestDataBinder binder) {
        Map&lt;String, ?&gt; propertyValues = parsePropertyValues(request, binder);
        MutablePropertyValues mpvs = new MutablePropertyValues(propertyValues);
        MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);
        if (multipartRequest != null) {
            bindMultipart(multipartRequest.getMultiFileMap(), mpvs);
        }

        // two lines copied from ExtendedServletRequestDataBinder
        String attr = HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;
        mpvs.addPropertyValues((Map&lt;String, String&gt;) request.getAttribute(attr));
        binder.bind(mpvs);
    }

    private Map&lt;String, ?&gt; parsePropertyValues(ServletRequest request, ServletRequestDataBinder binder) {

        // similar to WebUtils.getParametersStartingWith(..) (prefixes not supported)
        Map&lt;String, Object&gt; params = Maps.newTreeMap();
        Assert.notNull(request, "Request must not be null");
        Enumeration&lt;?&gt; paramNames = request.getParameterNames();
        Map&lt;String, String&gt; parameterMappings = getParameterMappings(binder);
        while (paramNames != null &amp;&amp; paramNames.hasMoreElements()) {
            String paramName = (String) paramNames.nextElement();
            String[] values = request.getParameterValues(paramName);

            String fieldName = parameterMappings.get(paramName);
            // no annotation exists, use the default - the param name=field name
            if (fieldName == null) {
                fieldName = paramName;
            }

            if (values == null || values.length == 0) {
                // Do nothing, no values found at all.
            } else if (values.length &gt; 1) {
                params.put(fieldName, values);
            } else {
                params.put(fieldName, values[0]);
            }
        }

        return params;
    }

    /**
     * Gets a mapping between request parameter names and field names.
     * If no annotation is specified, no entry is added
     * @return
     */
    private Map&lt;String, String&gt; getParameterMappings(ServletRequestDataBinder binder) {
        Class&lt;?&gt; targetClass = binder.getTarget().getClass();
        Map&lt;String, String&gt; map = definitionsCache.get(targetClass);
        if (map == null) {
            Field[] fields = targetClass.getDeclaredFields();
            map = Maps.newHashMapWithExpectedSize(fields.length);
            for (Field field : fields) {
                CommandParameter annotation = field.getAnnotation(CommandParameter.class);
                if (annotation != null &amp;&amp; !annotation.value().isEmpty()) {
                    map.put(annotation.value(), field.getName());
                }
            }
            definitionsCache.putIfAbsent(targetClass, map);
            return map;
        } else {
            return map;
        }
    }

    /**
     * Copied from WebDataBinder.
     * 
     * @param multipartFiles
     * @param mpvs
     */
    protected void bindMultipart(Map&lt;String, List&lt;MultipartFile&gt;&gt; multipartFiles, MutablePropertyValues mpvs) {
        for (Map.Entry&lt;String, List&lt;MultipartFile&gt;&gt; entry : multipartFiles.entrySet()) {
            String key = entry.getKey();
            List&lt;MultipartFile&gt; values = entry.getValue();
            if (values.size() == 1) {
                MultipartFile value = values.get(0);
                if (!value.isEmpty()) {
                    mpvs.add(key, value);
                }
            } else {
                mpvs.add(key, values);
            }
        }
    }
}
******************************
Normalized:
******************************
Original:
/**
 * This resolver handles command objects annotated with @SupportsAnnotationParameterResolution
 * that are passed as parameters to controller methods.
 * 
 * It parses @CommandPerameter annotations on command objects to
 * populate the Binder with the appropriate values (that is, the filed names
 * corresponding to the GET parameters)
 * 
 * In order to achieve this, small pieces of code are copied from spring-mvc
 * classes (indicated in-place). The alternative to the copied lines would be to
 * have a decorator around the Binder, but that would be more tedious, and still
 * some methods would need to be copied.
 * 
 * @author bozho
 * 
 */
public class AnnotationServletModelAttributeResolver extends ServletModelAttributeMethodProcessor {

    /**
     * A map caching annotation definitions of command objects (@CommandParameter-to-fieldname mappings)
     */
    private ConcurrentMap&lt;Class&lt;?&gt;, Map&lt;String, String&gt;&gt; definitionsCache = Maps.newConcurrentMap();

    public AnnotationServletModelAttributeResolver(boolean annotationNotRequired) {
        super(annotationNotRequired);
    }

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        if (parameter.getParameterType().isAnnotationPresent(SupportsAnnotationParameterResolution.class)) {
            return true;
        }
        return false;
    }

    @Override
    protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
        ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);
        ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
        bind(servletRequest, servletBinder);
    }

    @SuppressWarnings("unchecked")
    public void bind(ServletRequest request, ServletRequestDataBinder binder) {
        Map&lt;String, ?&gt; propertyValues = parsePropertyValues(request, binder);
        MutablePropertyValues mpvs = new MutablePropertyValues(propertyValues);
        MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);
        if (multipartRequest != null) {
            bindMultipart(multipartRequest.getMultiFileMap(), mpvs);
        }

        // two lines copied from ExtendedServletRequestDataBinder
        String attr = HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;
        mpvs.addPropertyValues((Map&lt;String, String&gt;) request.getAttribute(attr));
        binder.bind(mpvs);
    }

    private Map&lt;String, ?&gt; parsePropertyValues(ServletRequest request, ServletRequestDataBinder binder) {

        // similar to WebUtils.getParametersStartingWith(..) (prefixes not supported)
        Map&lt;String, Object&gt; params = Maps.newTreeMap();
        Assert.notNull(request, "Request must not be null");
        Enumeration&lt;?&gt; paramNames = request.getParameterNames();
        Map&lt;String, String&gt; parameterMappings = getParameterMappings(binder);
        while (paramNames != null &amp;&amp; paramNames.hasMoreElements()) {
            String paramName = (String) paramNames.nextElement();
            String[] values = request.getParameterValues(paramName);

            String fieldName = parameterMappings.get(paramName);
            // no annotation exists, use the default - the param name=field name
            if (fieldName == null) {
                fieldName = paramName;
            }

            if (values == null || values.length == 0) {
                // Do nothing, no values found at all.
            } else if (values.length &gt; 1) {
                params.put(fieldName, values);
            } else {
                params.put(fieldName, values[0]);
            }
        }

        return params;
    }

    /**
     * Gets a mapping between request parameter names and field names.
     * If no annotation is specified, no entry is added
     * @return
     */
    private Map&lt;String, String&gt; getParameterMappings(ServletRequestDataBinder binder) {
        Class&lt;?&gt; targetClass = binder.getTarget().getClass();
        Map&lt;String, String&gt; map = definitionsCache.get(targetClass);
        if (map == null) {
            Field[] fields = targetClass.getDeclaredFields();
            map = Maps.newHashMapWithExpectedSize(fields.length);
            for (Field field : fields) {
                CommandParameter annotation = field.getAnnotation(CommandParameter.class);
                if (annotation != null &amp;&amp; !annotation.value().isEmpty()) {
                    map.put(annotation.value(), field.getName());
                }
            }
            definitionsCache.putIfAbsent(targetClass, map);
            return map;
        } else {
            return map;
        }
    }

    /**
     * Copied from WebDataBinder.
     * 
     * @param multipartFiles
     * @param mpvs
     */
    protected void bindMultipart(Map&lt;String, List&lt;MultipartFile&gt;&gt; multipartFiles, MutablePropertyValues mpvs) {
        for (Map.Entry&lt;String, List&lt;MultipartFile&gt;&gt; entry : multipartFiles.entrySet()) {
            String key = entry.getKey();
            List&lt;MultipartFile&gt; values = entry.getValue();
            if (values.size() == 1) {
                MultipartFile value = values.get(0);
                if (!value.isEmpty()) {
                    mpvs.add(key, value);
                }
            } else {
                mpvs.add(key, values);
            }
        }
    }
}
******************************
Normalized:
/**
 * This resolver handles command objects annotated with @SupportsAnnotationParameterResolution
 * that are passed as parameters to controller methods.
 * 
 * It parses @CommandPerameter annotations on command objects to
 * populate the Binder with the appropriate values (that is, the filed names
 * corresponding to the GET parameters)
 * 
 * In order to achieve this, small pieces of code are copied from spring-mvc
 * classes (indicated in-place). The alternative to the copied lines would be to
 * have a decorator around the Binder, but that would be more tedious, and still
 * some methods would need to be copied.
 * 
 * @author bozho
 * 
 */
public class AnnotationServletModelAttributeResolver extends ServletModelAttributeMethodProcessor {

    /**
     * A map caching annotation definitions of command objects (@CommandParameter-to-fieldname mappings)
     */
    private ConcurrentMap&lt;Class&lt;?&gt;, Map&lt;String, String&gt;&gt; definitionsCache = Maps.newConcurrentMap();

    public AnnotationServletModelAttributeResolver(boolean annotationNotRequired) {
        super(annotationNotRequired);
    }

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        if (parameter.getParameterType().isAnnotationPresent(SupportsAnnotationParameterResolution.class)) {
            return true;
        }
        return false;
    }

    @Override
    protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
        ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);
        ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
        bind(servletRequest, servletBinder);
    }

    @SuppressWarnings("unchecked")
    public void bind(ServletRequest request, ServletRequestDataBinder binder) {
        Map&lt;String, ?&gt; propertyValues = parsePropertyValues(request, binder);
        MutablePropertyValues mpvs = new MutablePropertyValues(propertyValues);
        MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);
        if (multipartRequest != null) {
            bindMultipart(multipartRequest.getMultiFileMap(), mpvs);
        }

        // two lines copied from ExtendedServletRequestDataBinder
        String attr = HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE;
        mpvs.addPropertyValues((Map&lt;String, String&gt;) request.getAttribute(attr));
        binder.bind(mpvs);
    }

    private Map&lt;String, ?&gt; parsePropertyValues(ServletRequest request, ServletRequestDataBinder binder) {

        // similar to WebUtils.getParametersStartingWith(..) (prefixes not supported)
        Map&lt;String, Object&gt; params = Maps.newTreeMap();
        Assert.notNull(request, "Request must not be null");
        Enumeration&lt;?&gt; paramNames = request.getParameterNames();
        Map&lt;String, String&gt; parameterMappings = getParameterMappings(binder);
        while (paramNames != null &amp;&amp; paramNames.hasMoreElements()) {
            String paramName = (String) paramNames.nextElement();
            String[] values = request.getParameterValues(paramName);

            String fieldName = parameterMappings.get(paramName);
            // no annotation exists, use the default - the param name=field name
            if (fieldName == null) {
                fieldName = paramName;
            }

            if (values == null || values.length == 0) {
                // Do nothing, no values found at all.
            } else if (values.length &gt; 1) {
                params.put(fieldName, values);
            } else {
                params.put(fieldName, values[0]);
            }
        }

        return params;
    }

    /**
     * Gets a mapping between request parameter names and field names.
     * If no annotation is specified, no entry is added
     * @return
     */
    private Map&lt;String, String&gt; getParameterMappings(ServletRequestDataBinder binder) {
        Class&lt;?&gt; targetClass = binder.getTarget().getClass();
        Map&lt;String, String&gt; map = definitionsCache.get(targetClass);
        if (map == null) {
            Field[] fields = targetClass.getDeclaredFields();
            map = Maps.newHashMapWithExpectedSize(fields.length);
            for (Field field : fields) {
                CommandParameter annotation = field.getAnnotation(CommandParameter.class);
                if (annotation != null &amp;&amp; !annotation.value().isEmpty()) {
                    map.put(annotation.value(), field.getName());
                }
            }
            definitionsCache.putIfAbsent(targetClass, map);
            return map;
        } else {
            return map;
        }
    }

    /**
     * Copied from WebDataBinder.
     * 
     * @param multipartFiles
     * @param mpvs
     */
    protected void bindMultipart(Map&lt;String, List&lt;MultipartFile&gt;&gt; multipartFiles, MutablePropertyValues mpvs) {
        for (Map.Entry&lt;String, List&lt;MultipartFile&gt;&gt; entry : multipartFiles.entrySet()) {
            String key = entry.getKey();
            List&lt;MultipartFile&gt; values = entry.getValue();
            if (values.size() == 1) {
                MultipartFile value = values.get(0);
                if (!value.isEmpty()) {
                    mpvs.add(key, value);
                }
            } else {
                mpvs.add(key, values);
            }
        }
    }
}
******************************
Original:
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:id="@+id/mainLayout"
  android:descendantFocusability="beforeDescendants"
  android:focusableInTouchMode="true" &gt;

    &lt;EditText
        android:id="@+id/password"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@+id/changePass"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="167dp"
        android:ems="10"
        android:imeOptions="flagNoExtractUi"
        android:inputType="textPassword"
        android:maxLength="30" &gt;
    &lt;/EditText&gt;

&lt;/RelativeLayout&gt;
******************************
Normalized:
******************************
Original:
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:id="@+id/mainLayout"
  android:descendantFocusability="beforeDescendants"
  android:focusableInTouchMode="true" &gt;

    &lt;EditText
        android:id="@+id/password"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@+id/changePass"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="167dp"
        android:ems="10"
        android:imeOptions="flagNoExtractUi"
        android:inputType="textPassword"
        android:maxLength="30" &gt;
    &lt;/EditText&gt;

&lt;/RelativeLayout&gt;
******************************
Normalized:
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
  android:id="@+id/mainLayout"
  android:descendantFocusability="beforeDescendants"
  android:focusableInTouchMode="true" &gt;

    &lt;EditText
        android:id="@+id/password"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@+id/changePass"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="167dp"
        android:ems="10"
        android:imeOptions="flagNoExtractUi"
        android:inputType="textPassword"
        android:maxLength="30" &gt;
    &lt;/EditText&gt;

&lt;/RelativeLayout&gt;
******************************
Original:
[Desktop Entry]                                                                 
Encoding=UTF-8
Name=IntelliJ IDEA
Comment=IntelliJ IDEA
Exec=/opt/ideaIC-14.1.2/bin/idea.sh
Icon=/opt/ideaIC-14.1.2/bin/idea.png
Terminal=false
StartupNotify=true
Type=Application
******************************
Normalized:
******************************
Original:
[Desktop Entry]                                                                 
Encoding=UTF-8
Name=IntelliJ IDEA
Comment=IntelliJ IDEA
Exec=/opt/ideaIC-14.1.2/bin/idea.sh
Icon=/opt/ideaIC-14.1.2/bin/idea.png
Terminal=false
StartupNotify=true
Type=Application
******************************
Normalized:
[Desktop Entry]                                                                 
Encoding=UTF-8
Name=IntelliJ IDEA
Comment=IntelliJ IDEA
Exec=/opt/ideaIC-14.1.2/bin/idea.sh
Icon=/opt/ideaIC-14.1.2/bin/idea.png
Terminal=false
StartupNotify=true
Type=Application
******************************
Original:
Throwable getRootCause(Throwable throwable)
******************************
Normalized:
******************************
Original:
Throwable getRootCause(Throwable throwable)
******************************
Normalized:
Throwable getRootCause(Throwable throwable)
******************************
Original:
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.1&lt;/version&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;download-sources&lt;/id&gt;
        &lt;goals&gt;
          &lt;goal&gt;sources&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
  &lt;/plugin&gt;
******************************
Normalized:
******************************
Original:
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.1&lt;/version&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;download-sources&lt;/id&gt;
        &lt;goals&gt;
          &lt;goal&gt;sources&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
  &lt;/plugin&gt;
******************************
Normalized:
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.1.1&lt;/version&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;download-sources&lt;/id&gt;
        &lt;goals&gt;
          &lt;goal&gt;sources&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
  &lt;/plugin&gt;
******************************
Original:
&lt;li&gt;&lt;a href="#{request.contextPath}/index.xhtml"&gt;Home&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#{request.contextPath}/about_us.xhtml"&gt;About us&lt;/a&gt;&lt;/li&gt;
******************************
Normalized:
******************************
Original:
&lt;li&gt;&lt;a href="#{request.contextPath}/index.xhtml"&gt;Home&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#{request.contextPath}/about_us.xhtml"&gt;About us&lt;/a&gt;&lt;/li&gt;
******************************
Normalized:
&lt;li&gt;&lt;a href="#{request.contextPath}/index.xhtml"&gt;Home&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#{request.contextPath}/about_us.xhtml"&gt;About us&lt;/a&gt;&lt;/li&gt;
******************************
Original:
&lt;servlet&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        &lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;
            org.package.YouConfigurationAnnotatedClass
        &lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
******************************
Normalized:
******************************
Original:
&lt;servlet&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        &lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;
            org.package.YouConfigurationAnnotatedClass
        &lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
******************************
Normalized:
&lt;servlet&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        &lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;
            org.package.YouConfigurationAnnotatedClass
        &lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
******************************
Original:
&lt;target name="compile1"&gt; 
  &lt;mkdir dir="./build/reports"/&gt; 
  &lt;jrc 
    srcdir="./reports"
    destdir="./build/reports"
    tempdir="./build/reports"
    keepjava="true"
    xmlvalidation="true"&gt;
   &lt;classpath refid="runClasspath"/&gt;
   &lt;include name="**/*.jrxml"/&gt;
  &lt;/jrc&gt;
&lt;/target&gt;
******************************
Normalized:
******************************
Original:
&lt;target name="compile1"&gt; 
  &lt;mkdir dir="./build/reports"/&gt; 
  &lt;jrc 
    srcdir="./reports"
    destdir="./build/reports"
    tempdir="./build/reports"
    keepjava="true"
    xmlvalidation="true"&gt;
   &lt;classpath refid="runClasspath"/&gt;
   &lt;include name="**/*.jrxml"/&gt;
  &lt;/jrc&gt;
&lt;/target&gt;
******************************
Normalized:
&lt;target name="compile1"&gt; 
  &lt;mkdir dir="./build/reports"/&gt; 
  &lt;jrc 
    srcdir="./reports"
    destdir="./build/reports"
    tempdir="./build/reports"
    keepjava="true"
    xmlvalidation="true"&gt;
   &lt;classpath refid="runClasspath"/&gt;
   &lt;include name="**/*.jrxml"/&gt;
  &lt;/jrc&gt;
&lt;/target&gt;
******************************
Original:
List&lt;List&lt;String&gt;&gt; first = list1.stream().map(Arrays::asList).collect(toList());
List&lt;List&lt;String&gt;&gt; second = list2.stream().map(Arrays::asList).collect(toList());
return first.equals(second);
******************************
Normalized:
******************************
Original:
List&lt;List&lt;String&gt;&gt; first = list1.stream().map(Arrays::asList).collect(toList());
List&lt;List&lt;String&gt;&gt; second = list2.stream().map(Arrays::asList).collect(toList());
return first.equals(second);
******************************
Normalized:
List&lt;List&lt;String&gt;&gt; first = list1.stream().map(Arrays::asList).collect(toList());
List&lt;List&lt;String&gt;&gt; second = list2.stream().map(Arrays::asList).collect(toList());
return first.equals(second);
******************************
Original:
&lt;c:if test="${content.contentType.name ne 'MCE'}"&gt;
    &lt;%-- snip --%&gt;
&lt;/c:if&gt;
******************************
Normalized:
******************************
Original:
&lt;c:if test="${content.contentType.name ne 'MCE'}"&gt;
    &lt;%-- snip --%&gt;
&lt;/c:if&gt;
******************************
Normalized:
&lt;c:if test="${content.contentType.name ne 'MCE'}"&gt;
    &lt;%-- snip --%&gt;
&lt;/c:if&gt;
******************************
Original:
Your keystore contains 1 entry

myalias, Feb 15, 2012, PrivateKeyEntry, 
Certificate fingerprint (MD5): xxxxxxxx
******************************
Normalized:
******************************
Original:
Your keystore contains 1 entry

myalias, Feb 15, 2012, PrivateKeyEntry, 
Certificate fingerprint (MD5): xxxxxxxx
******************************
Normalized:
Your keystore contains 1 entry

myalias, Feb 15, 2012, PrivateKeyEntry, 
Certificate fingerprint (MD5): xxxxxxxx
******************************
Original:
GOTO --&gt;JAVA--Compiler---&gt; and change compiler level to `1.5` instead of `1.6`
******************************
Normalized:
******************************
Original:
GOTO --&gt;JAVA--Compiler---&gt; and change compiler level to `1.5` instead of `1.6`
******************************
Normalized:
GOTO --&gt;JAVA--Compiler---&gt; and change compiler level to `1.5` instead of `1.6`
******************************
Original:
try{
    int i = Integer.parseInt(input);
} catch(NumberFormatException ex){ // handle your exception
    ...
}
******************************
Normalized:
******************************
Original:
try{
    int i = Integer.parseInt(input);
} catch(NumberFormatException ex){ // handle your exception
    ...
}
******************************
Normalized:
try{
    int i = Integer.parseInt(input);
} catch(NumberFormatException ex){ // handle your exception
    ...
}
******************************
Original:
0x021dd753: test   %eax,0x180100      ;   {poll}
  0x021dd759: cmp    $0x0,%ecx
  0x021dd75c: je     0x021dd748         ;*ifeq
                                        ; - Test$1::run@7 (line 13)
  0x021dd75e: cmp    $0x0,%edx
  0x021dd761: jne    0x021dd788         ;*ifne
                                        ; - Test$1::run@13 (line 17)
  0x021dd767: nop    
  0x021dd768: jmp    0x021dd7b8         ;   {no_reloc}
  0x021dd76d: xchg   %ax,%ax
  0x021dd770: jmp    0x021dd7d2         ; implicit exception: dispatches to 0x021dd7c2
  0x021dd775: nop                       ;*getstatic out
                                        ; - Test$1::run@16 (line 18)
  0x021dd776: cmp    (%ecx),%eax        ; implicit exception: dispatches to 0x021dd7dc
  0x021dd778: mov    $0x39239500,%edx   ;*invokevirtual println
******************************
Normalized:
******************************
Original:
0x021dd753: test   %eax,0x180100      ;   {poll}
  0x021dd759: cmp    $0x0,%ecx
  0x021dd75c: je     0x021dd748         ;*ifeq
                                        ; - Test$1::run@7 (line 13)
  0x021dd75e: cmp    $0x0,%edx
  0x021dd761: jne    0x021dd788         ;*ifne
                                        ; - Test$1::run@13 (line 17)
  0x021dd767: nop    
  0x021dd768: jmp    0x021dd7b8         ;   {no_reloc}
  0x021dd76d: xchg   %ax,%ax
  0x021dd770: jmp    0x021dd7d2         ; implicit exception: dispatches to 0x021dd7c2
  0x021dd775: nop                       ;*getstatic out
                                        ; - Test$1::run@16 (line 18)
  0x021dd776: cmp    (%ecx),%eax        ; implicit exception: dispatches to 0x021dd7dc
  0x021dd778: mov    $0x39239500,%edx   ;*invokevirtual println
******************************
Normalized:
0x021dd753: test   %eax,0x180100      ;   {poll}
  0x021dd759: cmp    $0x0,%ecx
  0x021dd75c: je     0x021dd748         ;*ifeq
                                        ; - Test$1::run@7 (line 13)
  0x021dd75e: cmp    $0x0,%edx
  0x021dd761: jne    0x021dd788         ;*ifne
                                        ; - Test$1::run@13 (line 17)
  0x021dd767: nop    
  0x021dd768: jmp    0x021dd7b8         ;   {no_reloc}
  0x021dd76d: xchg   %ax,%ax
  0x021dd770: jmp    0x021dd7d2         ; implicit exception: dispatches to 0x021dd7c2
  0x021dd775: nop                       ;*getstatic out
                                        ; - Test$1::run@16 (line 18)
  0x021dd776: cmp    (%ecx),%eax        ; implicit exception: dispatches to 0x021dd7dc
  0x021dd778: mov    $0x39239500,%edx   ;*invokevirtual println
******************************
Original:
final Path path = FileSystems.getDefault().getPath(System.getProperty("user.home"), "Desktop");
System.out.println(path);
try (final WatchService watchService = FileSystems.getDefault().newWatchService()) {
    final WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);
    while (true) {
        final WatchKey wk = watchService.take();
        for (WatchEvent&lt;?&gt; event : wk.pollEvents()) {
            //we only register "ENTRY_MODIFY" so the context is always a Path.
            final Path changed = (Path) event.context();
            System.out.println(changed);
            if (changed.endsWith("myFile.txt")) {
                System.out.println("My file has changed");
            }
        }
        // reset the key
        boolean valid = wk.reset();
        if (!valid) {
            System.out.println("Key has been unregisterede");
        }
    }
}
******************************
Normalized:
******************************
Original:
final Path path = FileSystems.getDefault().getPath(System.getProperty("user.home"), "Desktop");
System.out.println(path);
try (final WatchService watchService = FileSystems.getDefault().newWatchService()) {
    final WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);
    while (true) {
        final WatchKey wk = watchService.take();
        for (WatchEvent&lt;?&gt; event : wk.pollEvents()) {
            //we only register "ENTRY_MODIFY" so the context is always a Path.
            final Path changed = (Path) event.context();
            System.out.println(changed);
            if (changed.endsWith("myFile.txt")) {
                System.out.println("My file has changed");
            }
        }
        // reset the key
        boolean valid = wk.reset();
        if (!valid) {
            System.out.println("Key has been unregisterede");
        }
    }
}
******************************
Normalized:
final Path path = FileSystems.getDefault().getPath(System.getProperty("user.home"), "Desktop");
System.out.println(path);
try (final WatchService watchService = FileSystems.getDefault().newWatchService()) {
    final WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);
    while (true) {
        final WatchKey wk = watchService.take();
        for (WatchEvent&lt;?&gt; event : wk.pollEvents()) {
            //we only register "ENTRY_MODIFY" so the context is always a Path.
            final Path changed = (Path) event.context();
            System.out.println(changed);
            if (changed.endsWith("myFile.txt")) {
                System.out.println("My file has changed");
            }
        }
        // reset the key
        boolean valid = wk.reset();
        if (!valid) {
            System.out.println("Key has been unregisterede");
        }
    }
}
******************************
Original:
Map&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();

// Add Items to the TreeMap
map.put(1, "One");
map.put(2, "Two");
map.put(3, "Three");

// Iterate over them
for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {
    System.out.println(entry.getKey() + " =&gt; " + entry.getValue());
}
******************************
Normalized:
******************************
Original:
Map&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();

// Add Items to the TreeMap
map.put(1, "One");
map.put(2, "Two");
map.put(3, "Three");

// Iterate over them
for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {
    System.out.println(entry.getKey() + " =&gt; " + entry.getValue());
}
******************************
Normalized:
Map&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();

// Add Items to the TreeMap
map.put(1, "One");
map.put(2, "Two");
map.put(3, "Three");

// Iterate over them
for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {
    System.out.println(entry.getKey() + " =&gt; " + entry.getValue());
}
******************************
Original:
EnumSet largeSize
******************************
Normalized:
******************************
Original:
EnumSet largeSize
******************************
Normalized:
EnumSet largeSize
******************************
Original:
@OneToMany
@JoinColumn(name="TXTHEAD_CODE")
private Set&lt;Text&gt; text;
******************************
Normalized:
******************************
Original:
@OneToMany
@JoinColumn(name="TXTHEAD_CODE")
private Set&lt;Text&gt; text;
******************************
Normalized:
@OneToMany
@JoinColumn(name="TXTHEAD_CODE")
private Set&lt;Text&gt; text;
******************************
Original:
&lt;mvc:resources mapping="/static/**" location="/static/" /&gt;
******************************
Normalized:
******************************
Original:
&lt;mvc:resources mapping="/static/**" location="/static/" /&gt;
******************************
Normalized:
&lt;mvc:resources mapping="/static/**" location="/static/" /&gt;
******************************
Original:
IntStream.iterate(0, i -&gt; i + 2);
******************************
Normalized:
******************************
Original:
IntStream.iterate(0, i -&gt; i + 2);
******************************
Normalized:
IntStream.iterate(0, i -&gt; i + 2);
******************************
Original:
gcc -I/usr/lib/jvm/jdk1.7.0_07/include
******************************
Normalized:
******************************
Original:
gcc -I/usr/lib/jvm/jdk1.7.0_07/include
******************************
Normalized:
gcc -I/usr/lib/jvm/jdk1.7.0_07/include
******************************
Original:
// parent entity has simple primary key

@Entity
public class Employee {
   @Id long empId;
   String name;
   ...
} 

// dependent entity uses EmbeddedId for composite key

@Embeddable
public class DependentId {
   String name;
   long empid;   // corresponds to primary key type of Employee
}

@Entity
public class Dependent {
   @EmbeddedId DependentId id;
    ...
   @MapsId("empid")  //  maps the empid attribute of embedded id
   @ManyToOne Employee emp;
}
******************************
Normalized:
******************************
Original:
// parent entity has simple primary key

@Entity
public class Employee {
   @Id long empId;
   String name;
   ...
} 

// dependent entity uses EmbeddedId for composite key

@Embeddable
public class DependentId {
   String name;
   long empid;   // corresponds to primary key type of Employee
}

@Entity
public class Dependent {
   @EmbeddedId DependentId id;
    ...
   @MapsId("empid")  //  maps the empid attribute of embedded id
   @ManyToOne Employee emp;
}
******************************
Normalized:
// parent entity has simple primary key

@Entity
public class Employee {
   @Id long empId;
   String name;
   ...
} 

// dependent entity uses EmbeddedId for composite key

@Embeddable
public class DependentId {
   String name;
   long empid;   // corresponds to primary key type of Employee
}

@Entity
public class Dependent {
   @EmbeddedId DependentId id;
    ...
   @MapsId("empid")  //  maps the empid attribute of embedded id
   @ManyToOne Employee emp;
}
******************************
Original:
//Import all needed packages
package general;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipUtils {

    private List &lt;String&gt; fileList;
    private static final String OUTPUT_ZIP_FILE = "Folder.zip";
    private static final String SOURCE_FOLDER = "D:\\Reports"; // SourceFolder path

    public ZipUtils() {
        fileList = new ArrayList &lt; String &gt; ();
    }

    public static void main(String[] args) {
        ZipUtils appZip = new ZipUtils();
        appZip.generateFileList(new File(SOURCE_FOLDER));
        appZip.zipIt(OUTPUT_ZIP_FILE);
    }

    public void zipIt(String zipFile) {
        byte[] buffer = new byte[1024];
        String source = new File(SOURCE_FOLDER).getName();
        FileOutputStream fos = null;
        ZipOutputStream zos = null;
        try {
            fos = new FileOutputStream(zipFile);
            zos = new ZipOutputStream(fos);

            System.out.println("Output to Zip : " + zipFile);
            FileInputStream in = null;

            for (String file: this.fileList) {
                System.out.println("File Added : " + file);
                ZipEntry ze = new ZipEntry(source + File.separator + file);
                zos.putNextEntry(ze);
                try {
                    in = new FileInputStream(SOURCE_FOLDER + File.separator + file);
                    int len;
                    while ((len = in .read(buffer)) &gt; 0) {
                        zos.write(buffer, 0, len);
                    }
                } finally {
                    in.close();
                }
            }

            zos.closeEntry();
            System.out.println("Folder successfully compressed");

        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            try {
                zos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public void generateFileList(File node) {
        // add file only
        if (node.isFile()) {
            fileList.add(generateZipEntry(node.toString()));
        }

        if (node.isDirectory()) {
            String[] subNote = node.list();
            for (String filename: subNote) {
                generateFileList(new File(node, filename));
            }
        }
    }

    private String generateZipEntry(String file) {
        return file.substring(SOURCE_FOLDER.length() + 1, file.length());
    }
}
******************************
Normalized:
******************************
Original:
//Import all needed packages
package general;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipUtils {

    private List &lt;String&gt; fileList;
    private static final String OUTPUT_ZIP_FILE = "Folder.zip";
    private static final String SOURCE_FOLDER = "D:\\Reports"; // SourceFolder path

    public ZipUtils() {
        fileList = new ArrayList &lt; String &gt; ();
    }

    public static void main(String[] args) {
        ZipUtils appZip = new ZipUtils();
        appZip.generateFileList(new File(SOURCE_FOLDER));
        appZip.zipIt(OUTPUT_ZIP_FILE);
    }

    public void zipIt(String zipFile) {
        byte[] buffer = new byte[1024];
        String source = new File(SOURCE_FOLDER).getName();
        FileOutputStream fos = null;
        ZipOutputStream zos = null;
        try {
            fos = new FileOutputStream(zipFile);
            zos = new ZipOutputStream(fos);

            System.out.println("Output to Zip : " + zipFile);
            FileInputStream in = null;

            for (String file: this.fileList) {
                System.out.println("File Added : " + file);
                ZipEntry ze = new ZipEntry(source + File.separator + file);
                zos.putNextEntry(ze);
                try {
                    in = new FileInputStream(SOURCE_FOLDER + File.separator + file);
                    int len;
                    while ((len = in .read(buffer)) &gt; 0) {
                        zos.write(buffer, 0, len);
                    }
                } finally {
                    in.close();
                }
            }

            zos.closeEntry();
            System.out.println("Folder successfully compressed");

        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            try {
                zos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public void generateFileList(File node) {
        // add file only
        if (node.isFile()) {
            fileList.add(generateZipEntry(node.toString()));
        }

        if (node.isDirectory()) {
            String[] subNote = node.list();
            for (String filename: subNote) {
                generateFileList(new File(node, filename));
            }
        }
    }

    private String generateZipEntry(String file) {
        return file.substring(SOURCE_FOLDER.length() + 1, file.length());
    }
}
******************************
Normalized:
//Import all needed packages
package general;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipUtils {

    private List &lt;String&gt; fileList;
    private static final String OUTPUT_ZIP_FILE = "Folder.zip";
    private static final String SOURCE_FOLDER = "D:\\Reports"; // SourceFolder path

    public ZipUtils() {
        fileList = new ArrayList &lt; String &gt; ();
    }

    public static void main(String[] args) {
        ZipUtils appZip = new ZipUtils();
        appZip.generateFileList(new File(SOURCE_FOLDER));
        appZip.zipIt(OUTPUT_ZIP_FILE);
    }

    public void zipIt(String zipFile) {
        byte[] buffer = new byte[1024];
        String source = new File(SOURCE_FOLDER).getName();
        FileOutputStream fos = null;
        ZipOutputStream zos = null;
        try {
            fos = new FileOutputStream(zipFile);
            zos = new ZipOutputStream(fos);

            System.out.println("Output to Zip : " + zipFile);
            FileInputStream in = null;

            for (String file: this.fileList) {
                System.out.println("File Added : " + file);
                ZipEntry ze = new ZipEntry(source + File.separator + file);
                zos.putNextEntry(ze);
                try {
                    in = new FileInputStream(SOURCE_FOLDER + File.separator + file);
                    int len;
                    while ((len = in .read(buffer)) &gt; 0) {
                        zos.write(buffer, 0, len);
                    }
                } finally {
                    in.close();
                }
            }

            zos.closeEntry();
            System.out.println("Folder successfully compressed");

        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            try {
                zos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public void generateFileList(File node) {
        // add file only
        if (node.isFile()) {
            fileList.add(generateZipEntry(node.toString()));
        }

        if (node.isDirectory()) {
            String[] subNote = node.list();
            for (String filename: subNote) {
                generateFileList(new File(node, filename));
            }
        }
    }

    private String generateZipEntry(String file) {
        return file.substring(SOURCE_FOLDER.length() + 1, file.length());
    }
}
******************************
Original:
public enum Month {
    JANUARY, FEBRUARY, ...
}
******************************
Normalized:
******************************
Original:
public enum Month {
    JANUARY, FEBRUARY, ...
}
******************************
Normalized:
public enum Month {
    JANUARY, FEBRUARY, ...
}
******************************
Original:
ext {
    ver = [
        guava: '14.0.1'
    ]
}
******************************
Normalized:
******************************
Original:
ext {
    ver = [
        guava: '14.0.1'
    ]
}
******************************
Normalized:
ext {
    ver = [
        guava: '14.0.1'
    ]
}
******************************
Original:
private static long gcd(long a, long b)
{
    while (b &gt; 0)
    {
        long temp = b;
        b = a % b; // % is remainder
        a = temp;
    }
    return a;
}

private static long gcd(long[] input)
{
    long result = input[0];
    for(int i = 1; i &lt; input.length; i++) result = gcd(result, input[i]);
    return result;
}
******************************
Normalized:
******************************
Original:
private static long gcd(long a, long b)
{
    while (b &gt; 0)
    {
        long temp = b;
        b = a % b; // % is remainder
        a = temp;
    }
    return a;
}

private static long gcd(long[] input)
{
    long result = input[0];
    for(int i = 1; i &lt; input.length; i++) result = gcd(result, input[i]);
    return result;
}
******************************
Normalized:
private static long gcd(long a, long b)
{
    while (b &gt; 0)
    {
        long temp = b;
        b = a % b; // % is remainder
        a = temp;
    }
    return a;
}

private static long gcd(long[] input)
{
    long result = input[0];
    for(int i = 1; i &lt; input.length; i++) result = gcd(result, input[i]);
    return result;
}
******************************
Original:
$ sudo apt-get install libxtst6:i386
******************************
Normalized:
******************************
Original:
$ sudo apt-get install libxtst6:i386
******************************
Normalized:
$ sudo apt-get install libxtst6:i386
******************************
Original:
public class Helper {

        public static boolean isAppRunning(final Context context, final String packageName) {
            final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            final List&lt;ActivityManager.RunningAppProcessInfo&gt; procInfos = activityManager.getRunningAppProcesses();
            if (procInfos != null)
            {
                for (final ActivityManager.RunningAppProcessInfo processInfo : procInfos) {
                    if (processInfo.processName.equals(packageName)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
******************************
Normalized:
******************************
Original:
public class Helper {

        public static boolean isAppRunning(final Context context, final String packageName) {
            final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            final List&lt;ActivityManager.RunningAppProcessInfo&gt; procInfos = activityManager.getRunningAppProcesses();
            if (procInfos != null)
            {
                for (final ActivityManager.RunningAppProcessInfo processInfo : procInfos) {
                    if (processInfo.processName.equals(packageName)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
******************************
Normalized:
public class Helper {

        public static boolean isAppRunning(final Context context, final String packageName) {
            final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            final List&lt;ActivityManager.RunningAppProcessInfo&gt; procInfos = activityManager.getRunningAppProcesses();
            if (procInfos != null)
            {
                for (final ActivityManager.RunningAppProcessInfo processInfo : procInfos) {
                    if (processInfo.processName.equals(packageName)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
******************************
Original:
# Set root logger level to DEBUG and its only appender to A1.
log4j.rootLogger=DEBUG, A1

# A1 is set to be a ConsoleAppender.
log4j.appender.A1=org.apache.log4j.ConsoleAppender

# A1 uses PatternLayout.
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n

# An alternative logging format:
# log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1} - %m%n
******************************
Normalized:
******************************
Original:
# Set root logger level to DEBUG and its only appender to A1.
log4j.rootLogger=DEBUG, A1

# A1 is set to be a ConsoleAppender.
log4j.appender.A1=org.apache.log4j.ConsoleAppender

# A1 uses PatternLayout.
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n

# An alternative logging format:
# log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1} - %m%n
******************************
Normalized:
# Set root logger level to DEBUG and its only appender to A1.
log4j.rootLogger=DEBUG, A1

# A1 is set to be a ConsoleAppender.
log4j.appender.A1=org.apache.log4j.ConsoleAppender

# A1 uses PatternLayout.
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n

# An alternative logging format:
# log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1} - %m%n
******************************
Original:
public class MyComparator implements Comparator&lt;Integer&gt; {
   public int compare(Integer a, Integer b) {
      //
   }
}
******************************
Normalized:
******************************
Original:
public class MyComparator implements Comparator&lt;Integer&gt; {
   public int compare(Integer a, Integer b) {
      //
   }
}
******************************
Normalized:
public class MyComparator implements Comparator&lt;Integer&gt; {
   public int compare(Integer a, Integer b) {
      //
   }
}
******************************
Original:
public InputField(String labelText, Class&lt;W&gt; clazz)
{
    super(new String[] {labelText}, clazz);
}
******************************
Normalized:
******************************
Original:
public InputField(String labelText, Class&lt;W&gt; clazz)
{
    super(new String[] {labelText}, clazz);
}
******************************
Normalized:
public InputField(String labelText, Class&lt;W&gt; clazz)
{
    super(new String[] {labelText}, clazz);
}
******************************
Original:
private Object actuallyT;

public &lt;T&gt; List&lt;T&gt; magicalListGetter(Class&lt;T&gt; klazz) {
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    list.add(klazz.cast(actuallyT));
    try {
        list.add(klazz.getConstructor().newInstance()); // If default constructor
    } ...
    return list;
}
******************************
Normalized:
******************************
Original:
private Object actuallyT;

public &lt;T&gt; List&lt;T&gt; magicalListGetter(Class&lt;T&gt; klazz) {
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    list.add(klazz.cast(actuallyT));
    try {
        list.add(klazz.getConstructor().newInstance()); // If default constructor
    } ...
    return list;
}
******************************
Normalized:
private Object actuallyT;

public &lt;T&gt; List&lt;T&gt; magicalListGetter(Class&lt;T&gt; klazz) {
    List&lt;T&gt; list = new ArrayList&lt;&gt;();
    list.add(klazz.cast(actuallyT));
    try {
        list.add(klazz.getConstructor().newInstance()); // If default constructor
    } ...
    return list;
}
******************************
Original:
@Component
public class ImagesPurgeJob implements Job {

    private Logger logger = Logger.getLogger(this.getClass());

    @Value("${jobs.mediafiles.imagesPurgeJob.enable}")
    private boolean imagesPurgeJobEnable;

    @Override
    @Transactional(readOnly=true)
    @Scheduled(cron = "${jobs.mediafiles.imagesPurgeJob.schedule}")
    public void execute() {

         //Do something
        //can use DAO or other autowired beans here
        if(imagesPurgeJobEnable){

            Do your conditional job here...

        }
    }
}
******************************
Normalized:
******************************
Original:
@Component
public class ImagesPurgeJob implements Job {

    private Logger logger = Logger.getLogger(this.getClass());

    @Value("${jobs.mediafiles.imagesPurgeJob.enable}")
    private boolean imagesPurgeJobEnable;

    @Override
    @Transactional(readOnly=true)
    @Scheduled(cron = "${jobs.mediafiles.imagesPurgeJob.schedule}")
    public void execute() {

         //Do something
        //can use DAO or other autowired beans here
        if(imagesPurgeJobEnable){

            Do your conditional job here...

        }
    }
}
******************************
Normalized:
@Component
public class ImagesPurgeJob implements Job {

    private Logger logger = Logger.getLogger(this.getClass());

    @Value("${jobs.mediafiles.imagesPurgeJob.enable}")
    private boolean imagesPurgeJobEnable;

    @Override
    @Transactional(readOnly=true)
    @Scheduled(cron = "${jobs.mediafiles.imagesPurgeJob.schedule}")
    public void execute() {

         //Do something
        //can use DAO or other autowired beans here
        if(imagesPurgeJobEnable){

            Do your conditional job here...

        }
    }
}
******************************
Original:
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
******************************
Normalized:
******************************
Original:
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
******************************
Normalized:
&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
******************************
Original:
@RunWith(Parameterized.class)
 @ContextConfiguration(classes = {ApplicationConfigTest.class})
 public class ServiceTest {

     private TestContextManager testContextManager;

     @Before
     public void setUpContext() throws Exception {
         //this is where the magic happens, we actually do "by hand" what the spring runner would do for us,
        // read the JavaDoc for the class bellow to know exactly what it does, the method names are quite accurate though
       this.testContextManager = new TestContextManager(getClass());
       this.testContextManager.prepareTestInstance(this);
     }
     ...
 }
******************************
Normalized:
******************************
Original:
@RunWith(Parameterized.class)
 @ContextConfiguration(classes = {ApplicationConfigTest.class})
 public class ServiceTest {

     private TestContextManager testContextManager;

     @Before
     public void setUpContext() throws Exception {
         //this is where the magic happens, we actually do "by hand" what the spring runner would do for us,
        // read the JavaDoc for the class bellow to know exactly what it does, the method names are quite accurate though
       this.testContextManager = new TestContextManager(getClass());
       this.testContextManager.prepareTestInstance(this);
     }
     ...
 }
******************************
Normalized:
@RunWith(Parameterized.class)
 @ContextConfiguration(classes = {ApplicationConfigTest.class})
 public class ServiceTest {

     private TestContextManager testContextManager;

     @Before
     public void setUpContext() throws Exception {
         //this is where the magic happens, we actually do "by hand" what the spring runner would do for us,
        // read the JavaDoc for the class bellow to know exactly what it does, the method names are quite accurate though
       this.testContextManager = new TestContextManager(getClass());
       this.testContextManager.prepareTestInstance(this);
     }
     ...
 }
******************************
Original:
@SuppressWarnings("WeakerAccess")
******************************
Normalized:
******************************
Original:
@SuppressWarnings("WeakerAccess")
******************************
Normalized:
@SuppressWarnings("WeakerAccess")
******************************
Original:
-vm
C:\Program Files\Java\jdk1.6.0_07\bin\
******************************
Normalized:
******************************
Original:
-vm
C:\Program Files\Java\jdk1.6.0_07\bin\
******************************
Normalized:
-vm
C:\Program Files\Java\jdk1.6.0_07\bin\
******************************
Original:
final List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
list = new ArrayList&lt;Integer&gt;(); // Since `list' is final, this won't compile
******************************
Normalized:
******************************
Original:
final List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
list = new ArrayList&lt;Integer&gt;(); // Since `list' is final, this won't compile
******************************
Normalized:
final List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
list = new ArrayList&lt;Integer&gt;(); // Since `list' is final, this won't compile
******************************
Original:
JarFile jarFile = new JarFile(pathToJar);
Enumeration&lt;JarEntry&gt; e = jarFile.entries();

URL[] urls = { new URL("jar:file:" + pathToJar+"!/") };
URLClassLoader cl = URLClassLoader.newInstance(urls);

while (e.hasMoreElements()) {
    JarEntry je = e.nextElement();
    if(je.isDirectory() || !je.getName().endsWith(".class")){
        continue;
    }
    // -6 because of .class
    String className = je.getName().substring(0,je.getName().length()-6);
    className = className.replace('/', '.');
    Class c = cl.loadClass(className);

}
******************************
Normalized:
******************************
Original:
JarFile jarFile = new JarFile(pathToJar);
Enumeration&lt;JarEntry&gt; e = jarFile.entries();

URL[] urls = { new URL("jar:file:" + pathToJar+"!/") };
URLClassLoader cl = URLClassLoader.newInstance(urls);

while (e.hasMoreElements()) {
    JarEntry je = e.nextElement();
    if(je.isDirectory() || !je.getName().endsWith(".class")){
        continue;
    }
    // -6 because of .class
    String className = je.getName().substring(0,je.getName().length()-6);
    className = className.replace('/', '.');
    Class c = cl.loadClass(className);

}
******************************
Normalized:
JarFile jarFile = new JarFile(pathToJar);
Enumeration&lt;JarEntry&gt; e = jarFile.entries();

URL[] urls = { new URL("jar:file:" + pathToJar+"!/") };
URLClassLoader cl = URLClassLoader.newInstance(urls);

while (e.hasMoreElements()) {
    JarEntry je = e.nextElement();
    if(je.isDirectory() || !je.getName().endsWith(".class")){
        continue;
    }
    // -6 because of .class
    String className = je.getName().substring(0,je.getName().length()-6);
    className = className.replace('/', '.');
    Class c = cl.loadClass(className);

}
******************************
Original:
// All exception handling omitted!
Class&lt;?&gt; enclosingClass = Class.forName("com.mycompany.Mother");
Object enclosingInstance = enclosingClass.newInstance();

Class&lt;?&gt; innerClass = Class.forName("com.mycompany.Mother$Child");
Constructor&lt;?&gt; ctor = innerClass.getDeclaredConstructor(enclosingClass);

Object innerInstance = ctor.newInstance(enclosingInstance);
******************************
Normalized:
******************************
Original:
// All exception handling omitted!
Class&lt;?&gt; enclosingClass = Class.forName("com.mycompany.Mother");
Object enclosingInstance = enclosingClass.newInstance();

Class&lt;?&gt; innerClass = Class.forName("com.mycompany.Mother$Child");
Constructor&lt;?&gt; ctor = innerClass.getDeclaredConstructor(enclosingClass);

Object innerInstance = ctor.newInstance(enclosingInstance);
******************************
Normalized:
// All exception handling omitted!
Class&lt;?&gt; enclosingClass = Class.forName("com.mycompany.Mother");
Object enclosingInstance = enclosingClass.newInstance();

Class&lt;?&gt; innerClass = Class.forName("com.mycompany.Mother$Child");
Constructor&lt;?&gt; ctor = innerClass.getDeclaredConstructor(enclosingClass);

Object innerInstance = ctor.newInstance(enclosingInstance);
******************************
Original:
private static final Consumer&lt;Object&gt; NOOP = whatever -&gt; {};
******************************
Normalized:
******************************
Original:
private static final Consumer&lt;Object&gt; NOOP = whatever -&gt; {};
******************************
Normalized:
private static final Consumer&lt;Object&gt; NOOP = whatever -&gt; {};
******************************
Original:
&lt;bean id="transactionManager1"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory1" /&gt;
    &lt;qualifier value="account"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionManager2"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory2" /&gt;
    &lt;qualifier value="businessData"/&gt;
&lt;/bean&gt;
******************************
Normalized:
******************************
Original:
&lt;bean id="transactionManager1"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory1" /&gt;
    &lt;qualifier value="account"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionManager2"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory2" /&gt;
    &lt;qualifier value="businessData"/&gt;
&lt;/bean&gt;
******************************
Normalized:
&lt;bean id="transactionManager1"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory1" /&gt;
    &lt;qualifier value="account"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionManager2"
    class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory2" /&gt;
    &lt;qualifier value="businessData"/&gt;
&lt;/bean&gt;
******************************
Original:
// Get file from file name
File file = new File("U:\intranet_root\intranet\R1112B2.zip");

// Get length of file in bytes
long fileSizeInBytes = file.length();
// Convert the bytes to Kilobytes (1 KB = 1024 Bytes)
long fileSizeInKB = fileSizeInBytes / 1024;
// Convert the KB to MegaBytes (1 MB = 1024 KBytes)
long fileSizeInMB = fileSizeInKB / 1024;

if (fileSizeInMB &gt; 27) {
  ...
}
******************************
Normalized:
******************************
Original:
// Get file from file name
File file = new File("U:\intranet_root\intranet\R1112B2.zip");

// Get length of file in bytes
long fileSizeInBytes = file.length();
// Convert the bytes to Kilobytes (1 KB = 1024 Bytes)
long fileSizeInKB = fileSizeInBytes / 1024;
// Convert the KB to MegaBytes (1 MB = 1024 KBytes)
long fileSizeInMB = fileSizeInKB / 1024;

if (fileSizeInMB &gt; 27) {
  ...
}
******************************
Normalized:
// Get file from file name
File file = new File("U:\intranet_root\intranet\R1112B2.zip");

// Get length of file in bytes
long fileSizeInBytes = file.length();
// Convert the bytes to Kilobytes (1 KB = 1024 Bytes)
long fileSizeInKB = fileSizeInBytes / 1024;
// Convert the KB to MegaBytes (1 MB = 1024 KBytes)
long fileSizeInMB = fileSizeInKB / 1024;

if (fileSizeInMB &gt; 27) {
  ...
}
******************************
Original:
[{A,1},{B,1},{C,2}]
******************************
Normalized:
******************************
Original:
[{A,1},{B,1},{C,2}]
******************************
Normalized:
[{A,1},{B,1},{C,2}]
******************************
Original:
grammar Math;

compileUnit
    :   expr EOF
    ;

expr
    :   '(' expr ')'                         # parensExpr
    |   op=('+'|'-') expr                    # unaryExpr
    |   left=expr op=('*'|'/') right=expr    # infixExpr
    |   left=expr op=('+'|'-') right=expr    # infixExpr
    |   func=ID '(' expr ')'                 # funcExpr
    |   value=NUM                            # numberExpr
    ;

OP_ADD: '+';
OP_SUB: '-';
OP_MUL: '*';
OP_DIV: '/';

NUM :   [0-9]+ ('.' [0-9]+)? ([eE] [+-]? [0-9]+)?;
ID  :   [a-zA-Z]+;
WS  :   [ \t\r\n] -&gt; channel(HIDDEN);
******************************
Normalized:
******************************
Original:
grammar Math;

compileUnit
    :   expr EOF
    ;

expr
    :   '(' expr ')'                         # parensExpr
    |   op=('+'|'-') expr                    # unaryExpr
    |   left=expr op=('*'|'/') right=expr    # infixExpr
    |   left=expr op=('+'|'-') right=expr    # infixExpr
    |   func=ID '(' expr ')'                 # funcExpr
    |   value=NUM                            # numberExpr
    ;

OP_ADD: '+';
OP_SUB: '-';
OP_MUL: '*';
OP_DIV: '/';

NUM :   [0-9]+ ('.' [0-9]+)? ([eE] [+-]? [0-9]+)?;
ID  :   [a-zA-Z]+;
WS  :   [ \t\r\n] -&gt; channel(HIDDEN);
******************************
Normalized:
grammar Math;

compileUnit
    :   expr EOF
    ;

expr
    :   '(' expr ')'                         # parensExpr
    |   op=('+'|'-') expr                    # unaryExpr
    |   left=expr op=('*'|'/') right=expr    # infixExpr
    |   left=expr op=('+'|'-') right=expr    # infixExpr
    |   func=ID '(' expr ')'                 # funcExpr
    |   value=NUM                            # numberExpr
    ;

OP_ADD: '+';
OP_SUB: '-';
OP_MUL: '*';
OP_DIV: '/';

NUM :   [0-9]+ ('.' [0-9]+)? ([eE] [+-]? [0-9]+)?;
ID  :   [a-zA-Z]+;
WS  :   [ \t\r\n] -&gt; channel(HIDDEN);
******************************
Original:
byte[] one = getBytesForOne();
byte[] two = getBytesForTwo();
byte[] combined = new byte[one.length + two.length];

for (int i = 0; i &lt; combined.length; ++i)
{
    combined[i] = i &lt; one.length ? one[i] : two[i - one.length];
}
******************************
Normalized:
******************************
Original:
byte[] one = getBytesForOne();
byte[] two = getBytesForTwo();
byte[] combined = new byte[one.length + two.length];

for (int i = 0; i &lt; combined.length; ++i)
{
    combined[i] = i &lt; one.length ? one[i] : two[i - one.length];
}
******************************
Normalized:
byte[] one = getBytesForOne();
byte[] two = getBytesForTwo();
byte[] combined = new byte[one.length + two.length];

for (int i = 0; i &lt; combined.length; ++i)
{
    combined[i] = i &lt; one.length ? one[i] : two[i - one.length];
}
******************************
Original:
&lt;string name="meatShootingMessage"&gt;You shot %1$d pounds of meat!&lt;/string&gt;  


int numPoundsMeat = 123;
String strMeatFormat = getResources().getString(R.string.meatShootingMessage, numPoundsMeat);
******************************
Normalized:
******************************
Original:
&lt;string name="meatShootingMessage"&gt;You shot %1$d pounds of meat!&lt;/string&gt;  


int numPoundsMeat = 123;
String strMeatFormat = getResources().getString(R.string.meatShootingMessage, numPoundsMeat);
******************************
Normalized:
&lt;string name="meatShootingMessage"&gt;You shot %1$d pounds of meat!&lt;/string&gt;  


int numPoundsMeat = 123;
String strMeatFormat = getResources().getString(R.string.meatShootingMessage, numPoundsMeat);
******************************
Original:
class MyClass {
    companion object {
        public const val FOO = 1

    }
}
******************************
Normalized:
******************************
Original:
class MyClass {
    companion object {
        public const val FOO = 1

    }
}
******************************
Normalized:
class MyClass {
    companion object {
        public const val FOO = 1

    }
}
******************************
Original:
Set&lt;String&gt; users = new HashSet&lt;&gt;(Arrays.asList("Alice", "Bob"));

System.out.println(users.contains("Alice"));
// -&gt; prints true

System.out.println(users.contains("Jack"));
// -&gt; prints false
******************************
Normalized:
******************************
Original:
Set&lt;String&gt; users = new HashSet&lt;&gt;(Arrays.asList("Alice", "Bob"));

System.out.println(users.contains("Alice"));
// -&gt; prints true

System.out.println(users.contains("Jack"));
// -&gt; prints false
******************************
Normalized:
Set&lt;String&gt; users = new HashSet&lt;&gt;(Arrays.asList("Alice", "Bob"));

System.out.println(users.contains("Alice"));
// -&gt; prints true

System.out.println(users.contains("Jack"));
// -&gt; prints false
******************************
Original:
@TestPropertySource(properties=
{"spring.autoconfigure.exclude=comma.seperated.ClassNames,com.example.FooAutoConfiguration"})
@SpringBootTest
public class MySpringTest {...}
******************************
Normalized:
******************************
Original:
@TestPropertySource(properties=
{"spring.autoconfigure.exclude=comma.seperated.ClassNames,com.example.FooAutoConfiguration"})
@SpringBootTest
public class MySpringTest {...}
******************************
Normalized:
@TestPropertySource(properties=
{"spring.autoconfigure.exclude=comma.seperated.ClassNames,com.example.FooAutoConfiguration"})
@SpringBootTest
public class MySpringTest {...}
******************************
Original:
// use '..' in the args expression if you have zero or more parameters at that point
@Before("execution(* com.mkyong.customer.bo.CustomerBo.addCustomer(..)) &amp;&amp; args(yourString,..)")
******************************
Normalized:
******************************
Original:
// use '..' in the args expression if you have zero or more parameters at that point
@Before("execution(* com.mkyong.customer.bo.CustomerBo.addCustomer(..)) &amp;&amp; args(yourString,..)")
******************************
Normalized:
// use '..' in the args expression if you have zero or more parameters at that point
@Before("execution(* com.mkyong.customer.bo.CustomerBo.addCustomer(..)) &amp;&amp; args(yourString,..)")
******************************
Original:
mvn eclipse:eclipse
******************************
Normalized:
******************************
Original:
mvn eclipse:eclipse
******************************
Normalized:
mvn eclipse:eclipse
******************************
Original:
java -cp "$LIB/*"
******************************
Normalized:
******************************
Original:
java -cp "$LIB/*"
******************************
Normalized:
java -cp "$LIB/*"
******************************
Original:
&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd" &gt;
&lt;log4j:configuration debug="false"&gt;

    &lt;appender name="default.console" class="org.apache.log4j.ConsoleAppender"&gt;
        &lt;param name="target" value="System.out" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="default.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/mylogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="another.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/anotherlogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;logger name="com.yourcompany.SomeClass" additivity="false"&gt;
        &lt;level value="debug" /&gt;
        &lt;appender-ref ref="another.file" /&gt;
    &lt;/logger&gt;

    &lt;root&gt;
        &lt;priority value="info" /&gt;
        &lt;appender-ref ref="default.console" /&gt;
        &lt;appender-ref ref="default.file" /&gt;
    &lt;/root&gt;
&lt;/log4j:configuration&gt;
******************************
Normalized:
******************************
Original:
&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd" &gt;
&lt;log4j:configuration debug="false"&gt;

    &lt;appender name="default.console" class="org.apache.log4j.ConsoleAppender"&gt;
        &lt;param name="target" value="System.out" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="default.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/mylogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="another.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/anotherlogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;logger name="com.yourcompany.SomeClass" additivity="false"&gt;
        &lt;level value="debug" /&gt;
        &lt;appender-ref ref="another.file" /&gt;
    &lt;/logger&gt;

    &lt;root&gt;
        &lt;priority value="info" /&gt;
        &lt;appender-ref ref="default.console" /&gt;
        &lt;appender-ref ref="default.file" /&gt;
    &lt;/root&gt;
&lt;/log4j:configuration&gt;
******************************
Normalized:
&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd" &gt;
&lt;log4j:configuration debug="false"&gt;

    &lt;appender name="default.console" class="org.apache.log4j.ConsoleAppender"&gt;
        &lt;param name="target" value="System.out" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="default.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/mylogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;appender name="another.file" class="org.apache.log4j.FileAppender"&gt;
        &lt;param name="file" value="/log/anotherlogfile.log" /&gt;
        &lt;param name="append" value="false" /&gt;
        &lt;param name="threshold" value="debug" /&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%d{ISO8601} %-5p [%c{1}] - %m%n" /&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;

    &lt;logger name="com.yourcompany.SomeClass" additivity="false"&gt;
        &lt;level value="debug" /&gt;
        &lt;appender-ref ref="another.file" /&gt;
    &lt;/logger&gt;

    &lt;root&gt;
        &lt;priority value="info" /&gt;
        &lt;appender-ref ref="default.console" /&gt;
        &lt;appender-ref ref="default.file" /&gt;
    &lt;/root&gt;
&lt;/log4j:configuration&gt;
******************************
Original:
Supplier&lt;List&lt;Shape&gt;&gt; supplier = () -&gt; new LinkedList&lt;Shape&gt;();

List&lt;Shape&gt; blue = shapes.stream()
            .filter(s -&gt; s.getColor() == BLUE)
            .collect(Collectors.toCollection(supplier));
******************************
Normalized:
******************************
Original:
Supplier&lt;List&lt;Shape&gt;&gt; supplier = () -&gt; new LinkedList&lt;Shape&gt;();

List&lt;Shape&gt; blue = shapes.stream()
            .filter(s -&gt; s.getColor() == BLUE)
            .collect(Collectors.toCollection(supplier));
******************************
Normalized:
Supplier&lt;List&lt;Shape&gt;&gt; supplier = () -&gt; new LinkedList&lt;Shape&gt;();

List&lt;Shape&gt; blue = shapes.stream()
            .filter(s -&gt; s.getColor() == BLUE)
            .collect(Collectors.toCollection(supplier));
******************************
Original:
Criterion topPercentFromRange(Comparator&lt;Widget&gt; cmp, double from, double to) {
    return stream -&gt; {
        List&lt;Widget&gt; temp =
            stream.sorted(cmp).collect(toList());
        return temp.stream()
                   .skip((long)(temp.size() * from))
                   .limit((long)(temp.size() * (to - from)));
    };
}
******************************
Normalized:
******************************
Original:
Criterion topPercentFromRange(Comparator&lt;Widget&gt; cmp, double from, double to) {
    return stream -&gt; {
        List&lt;Widget&gt; temp =
            stream.sorted(cmp).collect(toList());
        return temp.stream()
                   .skip((long)(temp.size() * from))
                   .limit((long)(temp.size() * (to - from)));
    };
}
******************************
Normalized:
Criterion topPercentFromRange(Comparator&lt;Widget&gt; cmp, double from, double to) {
    return stream -&gt; {
        List&lt;Widget&gt; temp =
            stream.sorted(cmp).collect(toList());
        return temp.stream()
                   .skip((long)(temp.size() * from))
                   .limit((long)(temp.size() * (to - from)));
    };
}
******************************
Original:
Scanner s = new Scanner(new File("filepath"));
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
while (s.hasNext()){
    list.add(s.next());
}
s.close();
******************************
Normalized:
******************************
Original:
Scanner s = new Scanner(new File("filepath"));
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
while (s.hasNext()){
    list.add(s.next());
}
s.close();
******************************
Normalized:
Scanner s = new Scanner(new File("filepath"));
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
while (s.hasNext()){
    list.add(s.next());
}
s.close();
******************************
Original:
Stream&lt;String&gt; texts = optional.stream();
******************************
Normalized:
******************************
Original:
Stream&lt;String&gt; texts = optional.stream();
******************************
Normalized:
Stream&lt;String&gt; texts = optional.stream();
******************************
Original:
ObjectListing listing = s3.listObjects( bucketName, prefix );
List&lt;S3ObjectSummary&gt; summaries = listing.getObjectSummaries();

while (listing.isTruncated()) {
   listing = s3.listNextBatchOfObjects (listing);
   summaries.addAll (listing.getObjectSummaries());
}
******************************
Normalized:
******************************
Original:
ObjectListing listing = s3.listObjects( bucketName, prefix );
List&lt;S3ObjectSummary&gt; summaries = listing.getObjectSummaries();

while (listing.isTruncated()) {
   listing = s3.listNextBatchOfObjects (listing);
   summaries.addAll (listing.getObjectSummaries());
}
******************************
Normalized:
ObjectListing listing = s3.listObjects( bucketName, prefix );
List&lt;S3ObjectSummary&gt; summaries = listing.getObjectSummaries();

while (listing.isTruncated()) {
   listing = s3.listNextBatchOfObjects (listing);
   summaries.addAll (listing.getObjectSummaries());
}
******************************
Original:
/*[local-name()='workbook'
    and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheets'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheet'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main'][1]
******************************
Normalized:
******************************
Original:
/*[local-name()='workbook'
    and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheets'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheet'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main'][1]
******************************
Normalized:
/*[local-name()='workbook'
    and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheets'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main']
  /*[local-name()='sheet'
      and namespace-uri()='http://schemas.openxmlformats.org/spreadsheetml/2006/main'][1]
******************************
Original:
/**
 * Stateful filter. T is type of stream element, K is type of extracted key.
 */
static class DistinctByKey&lt;T,K&gt; {
    Map&lt;K,Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;();
    Function&lt;T,K&gt; keyExtractor;
    public DistinctByKey(Function&lt;T,K&gt; ke) {
        this.keyExtractor = ke;
    }
    public boolean filter(T t) {
        return seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
    }
}
******************************
Normalized:
******************************
Original:
/**
 * Stateful filter. T is type of stream element, K is type of extracted key.
 */
static class DistinctByKey&lt;T,K&gt; {
    Map&lt;K,Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;();
    Function&lt;T,K&gt; keyExtractor;
    public DistinctByKey(Function&lt;T,K&gt; ke) {
        this.keyExtractor = ke;
    }
    public boolean filter(T t) {
        return seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
    }
}
******************************
Normalized:
/**
 * Stateful filter. T is type of stream element, K is type of extracted key.
 */
static class DistinctByKey&lt;T,K&gt; {
    Map&lt;K,Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;();
    Function&lt;T,K&gt; keyExtractor;
    public DistinctByKey(Function&lt;T,K&gt; ke) {
        this.keyExtractor = ke;
    }
    public boolean filter(T t) {
        return seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
    }
}
******************************
Original:
List&lt;String&gt; species = Arrays.asList(speciesArr);
******************************
Normalized:
******************************
Original:
List&lt;String&gt; species = Arrays.asList(speciesArr);
******************************
Normalized:
List&lt;String&gt; species = Arrays.asList(speciesArr);
******************************
Original:
ObjectMapper mapper = new ObjectMapper();
Map&lt;String,Object&gt; map = mapper.readValue(json, Map.class);
******************************
Normalized:
******************************
Original:
ObjectMapper mapper = new ObjectMapper();
Map&lt;String,Object&gt; map = mapper.readValue(json, Map.class);
******************************
Normalized:
ObjectMapper mapper = new ObjectMapper();
Map&lt;String,Object&gt; map = mapper.readValue(json, Map.class);
******************************
Original:
for (initialization statement; condition check; update)
    loop body;
******************************
Normalized:
******************************
Original:
for (initialization statement; condition check; update)
    loop body;
******************************
Normalized:
for (initialization statement; condition check; update)
    loop body;
******************************
Original:
public class ArrayIndexComparator implements Comparator&lt;Integer&gt;
{
    private final String[] array;

    public ArrayIndexComparator(String[] array)
    {
        this.array = array;
    }

    public Integer[] createIndexArray()
    {
        Integer[] indexes = new Integer[array.length];
        for (int i = 0; i &lt; array.length; i++)
        {
            indexes[i] = i; // Autoboxing
        }
        return indexes;
    }

    @Override
    public int compare(Integer index1, Integer index2)
    {
         // Autounbox from Integer to int to use as array indexes
        return array[index1].compareTo(array[index2]);
    }
}
******************************
Normalized:
******************************
Original:
public class ArrayIndexComparator implements Comparator&lt;Integer&gt;
{
    private final String[] array;

    public ArrayIndexComparator(String[] array)
    {
        this.array = array;
    }

    public Integer[] createIndexArray()
    {
        Integer[] indexes = new Integer[array.length];
        for (int i = 0; i &lt; array.length; i++)
        {
            indexes[i] = i; // Autoboxing
        }
        return indexes;
    }

    @Override
    public int compare(Integer index1, Integer index2)
    {
         // Autounbox from Integer to int to use as array indexes
        return array[index1].compareTo(array[index2]);
    }
}
******************************
Normalized:
public class ArrayIndexComparator implements Comparator&lt;Integer&gt;
{
    private final String[] array;

    public ArrayIndexComparator(String[] array)
    {
        this.array = array;
    }

    public Integer[] createIndexArray()
    {
        Integer[] indexes = new Integer[array.length];
        for (int i = 0; i &lt; array.length; i++)
        {
            indexes[i] = i; // Autoboxing
        }
        return indexes;
    }

    @Override
    public int compare(Integer index1, Integer index2)
    {
         // Autounbox from Integer to int to use as array indexes
        return array[index1].compareTo(array[index2]);
    }
}
******************************
Original:
android {
    ....
    ....

    sourceSets {
        main.java.srcDirs += 'src/main/&lt;YOUR DIRECTORY&gt;'
    }

}
******************************
Normalized:
******************************
Original:
android {
    ....
    ....

    sourceSets {
        main.java.srcDirs += 'src/main/&lt;YOUR DIRECTORY&gt;'
    }

}
******************************
Normalized:
android {
    ....
    ....

    sourceSets {
        main.java.srcDirs += 'src/main/&lt;YOUR DIRECTORY&gt;'
    }

}
******************************
Original:
import org.mockito.internal.util.MockUtil;

new MockUtil().isMock(obj)
******************************
Normalized:
******************************
Original:
import org.mockito.internal.util.MockUtil;

new MockUtil().isMock(obj)
******************************
Normalized:
import org.mockito.internal.util.MockUtil;

new MockUtil().isMock(obj)
******************************
Original:
[A-Za-z0-9.,-:]*
******************************
Normalized:
******************************
Original:
[A-Za-z0-9.,-:]*
******************************
Normalized:
[A-Za-z0-9.,-:]*
******************************
Original:
Consumer&lt;String&gt; p = ""::equals;
******************************
Normalized:
******************************
Original:
Consumer&lt;String&gt; p = ""::equals;
******************************
Normalized:
Consumer&lt;String&gt; p = ""::equals;
******************************
Original:
# cat Athrow.j 
.source Athrow.j
.class public Athrow
.super java/lang/Object

.method public &lt;init&gt;()V
    aload_0
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    return
.end method

.method public static main([Ljava/lang/String;)V
    .limit stack 2

    new java/lang/Object
    dup
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    athrow

    return
.end method

# java -jar jasmin.jar Athrow.j 
Generated: Athrow.class

# java Athrow
Exception in thread "main" java.lang.VerifyError: (class: Athrow, method: main signature: ([Ljava/lang/String;)V) Can only throw Throwable objects
******************************
Normalized:
******************************
Original:
# cat Athrow.j 
.source Athrow.j
.class public Athrow
.super java/lang/Object

.method public &lt;init&gt;()V
    aload_0
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    return
.end method

.method public static main([Ljava/lang/String;)V
    .limit stack 2

    new java/lang/Object
    dup
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    athrow

    return
.end method

# java -jar jasmin.jar Athrow.j 
Generated: Athrow.class

# java Athrow
Exception in thread "main" java.lang.VerifyError: (class: Athrow, method: main signature: ([Ljava/lang/String;)V) Can only throw Throwable objects
******************************
Normalized:
# cat Athrow.j 
.source Athrow.j
.class public Athrow
.super java/lang/Object

.method public &lt;init&gt;()V
    aload_0
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    return
.end method

.method public static main([Ljava/lang/String;)V
    .limit stack 2

    new java/lang/Object
    dup
    invokenonvirtual java/lang/Object/&lt;init&gt;()V
    athrow

    return
.end method

# java -jar jasmin.jar Athrow.j 
Generated: Athrow.class

# java Athrow
Exception in thread "main" java.lang.VerifyError: (class: Athrow, method: main signature: ([Ljava/lang/String;)V) Can only throw Throwable objects
******************************
Original:
&lt;manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:sharedUserId="android.uid.shared"
    android:sharedUserLabel="@string/sharedUserLabel"
    ...&gt;
******************************
Normalized:
******************************
Original:
&lt;manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:sharedUserId="android.uid.shared"
    android:sharedUserLabel="@string/sharedUserLabel"
    ...&gt;
******************************
Normalized:
&lt;manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:sharedUserId="android.uid.shared"
    android:sharedUserLabel="@string/sharedUserLabel"
    ...&gt;
******************************
Original:
ExecutorService executor = Executors.newSingleThreadExecutor();

    // LAMBDA COMPILED INTO A 'Callable&lt;?&gt;'
    executor.submit(() -&gt; {
        while (true)
            throw new Exception();
    });

    // LAMBDA COMPILED INTO A 'Runnable': EXCEPTIONS MUST BE HANDLED BY LAMBDA ITSELF!
    executor.submit(() -&gt; {
        boolean value = true;
        while (value)
            throw new Exception();
    });
******************************
Normalized:
******************************
Original:
ExecutorService executor = Executors.newSingleThreadExecutor();

    // LAMBDA COMPILED INTO A 'Callable&lt;?&gt;'
    executor.submit(() -&gt; {
        while (true)
            throw new Exception();
    });

    // LAMBDA COMPILED INTO A 'Runnable': EXCEPTIONS MUST BE HANDLED BY LAMBDA ITSELF!
    executor.submit(() -&gt; {
        boolean value = true;
        while (value)
            throw new Exception();
    });
******************************
Normalized:
ExecutorService executor = Executors.newSingleThreadExecutor();

    // LAMBDA COMPILED INTO A 'Callable&lt;?&gt;'
    executor.submit(() -&gt; {
        while (true)
            throw new Exception();
    });

    // LAMBDA COMPILED INTO A 'Runnable': EXCEPTIONS MUST BE HANDLED BY LAMBDA ITSELF!
    executor.submit(() -&gt; {
        boolean value = true;
        while (value)
            throw new Exception();
    });
******************************
Original:
public void webmethod(@RequestParam("date") String strDate) {
    Date date = ... // manually parse the date
 }
******************************
Normalized:
******************************
Original:
public void webmethod(@RequestParam("date") String strDate) {
    Date date = ... // manually parse the date
 }
******************************
Normalized:
public void webmethod(@RequestParam("date") String strDate) {
    Date date = ... // manually parse the date
 }
******************************
Original:
(throws IOException)

Image image = null;
try {
    URL url = new URL("http://www.yahoo.com/image_to_read.jpg");
    image = ImageIO.read(url);
} catch (IOException e) {
}
******************************
Normalized:
******************************
Original:
(throws IOException)

Image image = null;
try {
    URL url = new URL("http://www.yahoo.com/image_to_read.jpg");
    image = ImageIO.read(url);
} catch (IOException e) {
}
******************************
Normalized:
(throws IOException)

Image image = null;
try {
    URL url = new URL("http://www.yahoo.com/image_to_read.jpg");
    image = ImageIO.read(url);
} catch (IOException e) {
}
******************************
Original:
&lt;style name="MyTheme" parent="android:Theme.Holo.Light"&gt;
    &lt;item name="actionButtonStyle"&gt;@style/MyActionButtonStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="MyActionButtonStyle" parent="Widget.ActionButton"&gt;
    &lt;item name="android:minWidth"&gt;28dip&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
******************************
Original:
&lt;style name="MyTheme" parent="android:Theme.Holo.Light"&gt;
    &lt;item name="actionButtonStyle"&gt;@style/MyActionButtonStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="MyActionButtonStyle" parent="Widget.ActionButton"&gt;
    &lt;item name="android:minWidth"&gt;28dip&lt;/item&gt;
&lt;/style&gt;
******************************
Normalized:
&lt;style name="MyTheme" parent="android:Theme.Holo.Light"&gt;
    &lt;item name="actionButtonStyle"&gt;@style/MyActionButtonStyle&lt;/item&gt;
&lt;/style&gt;

&lt;style name="MyActionButtonStyle" parent="Widget.ActionButton"&gt;
    &lt;item name="android:minWidth"&gt;28dip&lt;/item&gt;
&lt;/style&gt;
